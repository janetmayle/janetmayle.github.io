<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust学习笔记#2：变量声明、绑定与引用</title>
      <link href="posts/f80c8a5a.html"/>
      <url>posts/f80c8a5a.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Rust中的变量分局部变量和全局变量两种，且必须先声明后使用，常见的声明语法为：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 声明局部变量，使用let关键字</span><span class="token keyword">let</span> var<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明全局变量，使用static关键字</span><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </code></pre><p>由于Rust非常注重内存安全，因此全局变量的使用有许多限制，我们日常使用最多的还是局部变量。与传统的C/C++语言相比，Rust的变量声明语法不同，这样设计主要有下列三种优点：</p><ul><li>语法分析更容易：Rust的局部变量声明一定是以关键字<code>let</code>开头，类型一定跟在<code>:</code>后面，语法歧义更少，语法分析器更容易编写。</li><li>类型推导更方便：Rust的变量声明的一个重要特点是，要声明的变量前置，对它的类型描述后置。这是吸取了其他语言的教训后的结果，因为在变量声明语句中，最重要的是变量本身，类型只是附属的额外描述，并非必不可少的部分，类型可以由编译器自动推导获得，因此类型后置的语法更合适。</li><li>支持模式解构：<code>let</code>不仅能声明局部变量，还具有模式结构（pattern destructure）的功能，这里暂且不表。</li></ul><p>Rust中变量声明默认是“只读”的，如果需要让变量可写，则需要使用<code>mut</code>关键字，<code>mut</code>是<code>mutable</code>的简写：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x为只读变量，因此会报编译错误</span><span class="token keyword">let</span> <span class="token keyword">mut</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用mut关键字声明一个可写变量</span>y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>Rust中变量必须被初始化后才可以使用，否则会报编译错误。因此，不被初始化的变量是没有默认值的。变量既可以在声明时初始化，也可以在使用前初始化：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> i32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明变量x</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化变量x，不需要x是mut，因为这是初始化不是修改</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Rust中的合法标识符（包括变量名、函数名等）必须由数字、字母、下划线组成，且不能以数字开头。注意，单独的下划线是一个特殊的标识符，在编译器内部是被特殊处理的，不能作为普通变量使用，其具体用法这里暂且不表。Rust中关于变量的命名规范是蛇形命名法，使用下划线，一般用小写，即<code>file_name</code>。</p><h4 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h4><p>Rust中允许在同一个代码块中声明同样名字的变量，如果这样做，后面声明的变量会将前面声明的变量遮蔽（Shadowing）起来，从而前面的变量将无法访问。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面这种形式的代码在很多编程语言中是无法编译通过的，因为变量x被重复声明，但在Rust中是可以编译通过的：前后两个<code>x</code>是完全不同的两个变量，内存空间不同，类型也不同，只是恰巧名字相同。</p><p>Rust这种设计有时非常实用，例如，我们需要在同一个函数内部把一个变量转换为另一个类型的变量，但又不想给它们起不同的名字。但是，我个人认为变量遮蔽可能会带来阅读代码时的歧义，但以我现在的水平尚不能仔细分析变量遮蔽这一特性的利弊权衡，或许未来能够在RFC中找到答案。</p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>Rust编译器的类型推导功能很强大，不仅可以从变量声明的当前语句中获取信息进行推导，而且还能通过上下文信息进行推导。类型推导和“动态类型”是两码事，Rust仍然是静态类型的，所有变量的类型都必须在编译阶段确定，类型推导只是辅助我们不需要显示写出类型而已。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用<code>type</code>关键字给同一个类型起个别名，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">type</span> Age <span class="token operator">=</span> u32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// u32代表无符号的32位整数类型</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> Age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>可以用<code>static</code>关键字声明静态变量，这也是Rust中唯一的声明全局变量的方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>为了保证内存安全，全局变量的使用有很多限制：</p><ul><li>必须在声明时立即初始化</li><li>初始化必须是编译期可确定的常量</li><li>带有<code>mut</code>修饰的全局变量，在使用的时候必须使用<code>unsafe</code>关键字。</li></ul><p><code>unsafe</code>关键字用于逃过Rust编译器的检查以写一些可能存在危险的代码，当下无须深入研究。从上面第三条限制可以看出，Rust并不鼓励我们使用可变的全局变量，更希望我们把全局变量用成全局常量。注意，全局变量的声明周期是整个程序，从启动到退出。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>可以使用<code>const</code>关键字声明一个常量：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">const</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>常量和静态变量最大的区别在于：编译器不一定会给常量分配内存空间，可能会在编译过程中将常量內联优化。</p><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>通过<code>let</code>关键字来创建变量，这是Rust语言从函数式语言中借鉴的语法形式。<code>let</code>创建的变量一般称为绑定（binding），而不是我们通常说的赋值，因为它表明了位置表达式和值表达式之间建立的一种关联关系。</p><p>Rust中的表达式可以分为位置表达式和值表达式，在其他语言中，一般称为左值和右值。</p><ul><li>位置表达式：表示内存位置的表达式，有本地变量、静态变量、解引用、数组索引和字段引用五种。通过位置表达式可以对某个数据单元的内存进行读写。</li><li>值表达式：只引用了某个存储单元地址中的数据，相当于数据值，只能进行读操作。值表达式要么是字面量，要么是表达式求值过程中创建的临时值。</li></ul><p>表达式的求值过程在不同的上下文中会有不同的结果，求值上下文也分位置上下文和值上下文。下面几种表达式属于位置上下文（不必看懂，知道就好）：</p><ul><li>赋值或者复合赋值语句左侧的操作数</li><li>一元引用表达式的独立操作数</li><li>包含隐式借用的操作数</li><li>match判别式或let绑定右侧在使用ref模式匹配的时候也是位置上下文</li></ul><p>除了上述几种情况，其余表达式都属于值上下文。一般情况下，值表达式出现在值上下文中，位置表达式出现在位置上下文中，但也存在特殊情况：</p><ul><li>值表达式不能出现在位置上下文中，否则会报错：</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// error[E0070]: invalid left-hand side of assignment</span><span class="token string">"hello"</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ul><li>当位置表达式出现在值上下文中时，该位置表达式会把<strong>所有权</strong>转移给另外一个位置表达式。</li></ul><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>我们刚刚看到了一个新名词，“所有权（ownership）”，所有权代表着以下意义：</p><ul><li>每个值在Rust中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者。</li><li>每个值在一个时间点上只有一个管理者。</li><li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li></ul><p>当位置表达式出现在值上下文中时，这种所有权转移在Rust中称为移动语义。但在日常开发中，有时候并不需要转移所有权，Rust提供了引用操作符<code>&amp;</code>，可以直接获得位置表达式的内存地址，并通过该地址进行读写操作，解引用使用<code>*</code>操作符。下面看一个引用和解引用的示例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的代码中，32这个值的所有权归变量x所有，变量y中存储的是其地址，最后通过解引用操作符<code>*</code>将引用y中的值取出来，以供<code>assert_eq!</code>宏使用，因为变量x仍旧保留它们的所有权，所以引用也被称为借用。</p><p>生命周期是Rust的核心概念，而所有权、借用等概念又和生命周期息息相关，但目前先不去深入了解它，待把基础语法掌握后，再去学习Rust的精髓，方能事半功倍。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#1：一个猜谜游戏小项目</title>
      <link href="posts/8ab0a41e.html"/>
      <url>posts/8ab0a41e.html</url>
      
        <content type="html"><![CDATA[<p>在深入探索Rust语法的细枝末节之前，先通过一个麻雀虽小但五脏俱全的小项目来整体把握Rust，这样可以避免迷失在细节的海洋中。我们可能会通过这个小项目一下子接触到很多新概念，但不必惊慌，我们只需浅尝辄止对这些概念有个印象即可。</p><p>《TRPL》（Rustaceans对《The Rust Programming Language》的爱称）中就给出了一个经典的猜谜游戏的例子，我们一起来学习它。</p><blockquote><p>猜谜游戏：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜对了，它会打印祝贺信息并退出。</p></blockquote><h3 id="Rust如何管理项目"><a href="#Rust如何管理项目" class="headerlink" title="Rust如何管理项目"></a>Rust如何管理项目</h3><p>并不是所有的代码都像<code>hello_world.rs</code>一样，一个文件就可以搞定。一个项目往往具有复杂的代码，我们需要一种机制来管理这种复杂性，将一个项目切分成若干小部分，每个部分再进行切分，层层抽象，直到达到人脑可以处理的规模。每种编程语言都有这样的机制，例如Java的package机制，Rust也不例外。</p><p>Rust用了两个概念来管理项目：一个是crate（项目），一个是mod（模块）。模块是用于在crate内部进行分层和封装的机制，模块内部可以包含模块。</p><ul><li>crate：可以简单理解为一个项目，crate是Rust中的独立编译单元（compile unit），每个crate对应生成一个库或者可执行文件。作为对比，我们比较熟悉的C语言中，一个单独的.c文件和其所有的include文件组成一个编译单元，每个.c生成一个.o，然后将这些.o链接起来生成可执行文件。</li><li>mod：可以简单理解为命名空间。mod可以嵌套（注意crate之间不能出现循环引用），还可以控制内部元素的可见性。</li></ul><p>说到可见性问题，在Rust中，元素默认都是私有的，用<code>pub</code>关键字修饰的才是公开的。公开和私有的访问权限规定如下：</p><ul><li>如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问</li><li>如果一个元素是公开的，那么可以在本模块外的作用域访问它。</li></ul><p>模块是一种抽象的概念，文件是承载这个概念的实体，但是模块和文件并不是简单的一一对应关系。在一个crate内部创建mod的方式有下面三种：</p><ul><li>在一个rs文件中创建内嵌模块，直接使用<code>mod</code>关键字即可。</li><li>独立的一个rs文件就是一个模块，文件名即是模块名。</li><li>一个文件夹也可以创建一个模块，文件夹内部要有一个<code>xxx.rs</code>文件，这个文件是这个模块的入口。必须要在这个<code>xxx.rs</code>中声明其子模块，否则子模块无法被当成这个项目的源码进行编译。</li></ul><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>cargo不仅是Rust的包管理器，还可以用于创建项目。使用下列命令可以创建一个名为<code>guessing_game</code>的项目：</p><pre class=" language-bash"><code class="language-bash">cargo new guessing_game --bin</code></pre><p>注意，后面的<code>--bin</code>意味着我们希望项目生成的是可执行程序，如果希望是library，则可以使用<code>--lib</code>选项。</p><p>以上为在命令行中手工创建项目，在Clion中可以点击<code>File-&gt;New Project</code>后如下图填写，然后点击<code>Create</code>按钮：</p><p><img src="../images/4.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>我们可以使用<code>tree</code>命令或者直接在Clion中查看当前的文件夹结构，如下图所示：</p><p><img src="../images/5.png"></p><ul><li>src/main.rs：这是cargo自动生成的rs文件。还记得前面讲的crate和mod的概念吗？在这个项目中，<code>guessing_game</code>是crate，<code>src</code>文件夹是mod，<code>main.rs</code>是<code>src</code>mod的入口。我们可以在<code>src</code>mod中创建子模块，但注意，这些子模块都要在<code>main.rs</code>中声明，否则无法参与编译。</li><li>.gitignore：这是git忽略文件，不懂其作用的同学可以自行搜索。这里重点要说的是通过<code>cargo new</code>创建的项目天然就是一个git项目，这也印证了Rust对开源的拥护。</li><li>Cargo.toml：这是项目管理配置文件。TOML是一种非常简洁好用的配置文件格式，TOML是<code>Tom&#39;s Obvious, Minimal Language</code>的首字母缩写，这里的Tom是Github的联合创始人之一，感兴趣的同学可以进一步自行了解TOML配置文件的写法。</li><li>Cargo.lock：该文件包含项目依赖项的确切信息，由Cargo维护，我们无须关心它。</li></ul><h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><p>在<code>src/main.rs</code>里cargo已经自动生成了输出<code>Hello, world!</code>的代码，我们来运行一下它看能否正常输出。</p><p>插一句题外话，在你日后漫长的Rust编码生涯中，你会发现，你将在处理编译错误上耗费大量的时间。还记得吗，Rust 的一大特色是保证内存安全，这保证了Rust代码只要运行起来就几乎不会发生内存错误，这么诱人的效果的背后的代价就是，我们要在编码时付出额外的努力。Rust为了保证内存安全设计了一套复杂的规则，这导致我们的代码一不留神就会编译不过。所以，在你日后经常用的一个操作就是检查能否编译通过，而不是直接编译，因为直接编译还要进行代码优化等操作所以会相对费时。可以使用下列命令检查编译错误：</p><pre class=" language-bash"><code class="language-bash">cargo check</code></pre><p>在Clion中需要新加一个Configuration来执行<code>cargo check</code>命令，如下图所示：</p><p><img src="../images/6.png"></p><p>确保<code>cargo check</code>通过后，可以执行<code>cargo build</code>来执行编译。编译后会产生一个<code>target</code>文件夹，在<code>target/debug</code>下会有一个和crate同名的可执行文件。但一般为了方便，可以直接执行<code>cargo run</code>，这条命令等价于先编译后执行。下图是执行<code>cargo run</code>后Clion的控制台输出：</p><p><img src="../images/7.png"></p><h3 id="猜谜游戏"><a href="#猜谜游戏" class="headerlink" title="猜谜游戏"></a>猜谜游戏</h3><p>在完成了项目搭建后，接下来就要开始猜谜游戏的代码编写了，我将它们分成六部分：创建变量、输入、输出、错误处理、随机数生成、完整代码。</p><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><p>使用<code>let</code>语句创建变量，需要注意的是，在Rust中，变量默认是不可变的，可以在变量名前使用<code>mut</code>来使得变量可变：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不可变</span><span class="token keyword">let</span> <span class="token keyword">mut</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可变</span></code></pre><p>在上面的<code>let</code>语句中，我们并没有显示声明变量的类型，但这并不代表Rust是动态类型的，Rust仍然是静态类型的，只不过Rust有一个可以通过上下文推断类型的强大编译器。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>我们早已在<code>hello_world.rs</code>中见识过了最基本的输出方式：</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>需要注意的是，这里的<code>println!</code>是一个宏，而非一个函数，println后面的感叹号就是宏的标志。Rust中的宏与C/C++中的宏是完全不一样的东西，简单说，可以把它理解为一种安全版的编译期语法扩展。这里之所以使用输出宏而非函数，是因为标准输出宏可以完成编译期格式检查，更加安全。</p><p>如果需要输出某个变量的值，可以使用占位符<code>&#123;&#125;</code>，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x = {} and y = {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其输出结果为：</p><pre class=" language-bash"><code class="language-bash">x <span class="token operator">=</span> 0 and y <span class="token operator">=</span> 10</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>为了从控制台中获取用户的输入，需要使用标准库<code>std::io</code>。使用<code>use</code>语句将该库引入当前作用域：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span></code></pre><p>我们可以使用<code>io</code>库中的函数<code>stdin</code>：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个字符串类型的可变变量</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>stdin</code>函数返回一个<code>std::io::Stdin</code>的实例，这代表终端标准输入句柄的类型。然后调用<code>read_line</code>方法，可以从标准输入中读取一行并存入到<code>guess</code>变量中去。<code>&amp;</code>表示这是一个引用，这是一个复杂的特性，我们现在无须了解它。</p><p>读取用户输入后，我们需要判断用户是否正确输入了数字。<code>String</code>类型带有处理字符串处理的一些方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Please type a number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>字符串的 <code>parse </code>方法将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess </code>后的冒号<code>:</code>告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型，u32 是一个无符号的 32 位整型。<code>trim</code>方法用于消除回车空格等符号。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>上一小节代码中还有一个<code>expect</code>没有分析，而这就涉及到Rust中的错误处理机制了。<code>read_line</code>的返回值类型是<code>io::Result</code>，它是<code>Result</code>类型在<code>io</code>模块的特化版本。<code>Result</code>是枚举类型，其成员为<code>Ok</code>和<code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err </code>成员则意味着操作失败，并且包含失败的前因后果。</p><p><code>Result</code>类型的作用是编码错误处理信息。<code>Result </code>类型像其他类型一样，拥有定义于其上的方法。<code>io::Result</code>的实例拥有<code>expect</code>方法。如果 <code>io::Result </code>实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并打印参数传递给 <code>expect </code>的信息。如果<code>io::Result</code>实例的值是 <code>Ok</code>，<code>expect </code>会获取 <code>Ok </code>中的值并返回。在本例中，这个值是用户输入到标准输入中的字节数。</p><h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h4><p>猜谜游戏需要能够自动生成随机数。Rust标准库中尚未包含随机数功能，但我们可以通过引入外部crate来获得随机数功能。还记得Rust的官方开源仓库吗，那里可是有很多宝贝的。打开<code>https://crates.io/</code>，在搜索框中键入<code>rand</code>来搜索具有随机数功能的crate，出来的第一个结果就是我们需要的crate。</p><p><img src="../images/8.png"></p><p>现在我们将这个库引入到我们的项目中。打开<code>Cargo.toml</code>，在<code>[dependencies]</code>下添加：</p><pre class=" language-toml"><code class="language-toml">[dependencies]rand = "0.8.3"</code></pre><p><code>[dependencies]</code> 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。</p><p>下面使用<code>rand</code>库来产生随机数。首先，使用<code>use</code>语句引入<code>rand</code>，<code>use rand::Rng;</code>。然后调用下列函数产生一个1和100之间的数：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>猜谜游戏的完整代码如下。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cmp<span class="token punctuation">:</span><span class="token punctuation">:</span>Ordering<span class="token punctuation">;</span><span class="token keyword">use</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span>Rng<span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Guess the number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> secret_number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Please input your guess."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Ok</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> num<span class="token punctuation">,</span>            <span class="token function">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">continue</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You guessed: {}"</span><span class="token punctuation">,</span> guess<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>secret_number<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Less <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too small!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Greater <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too big!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Equal <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You win!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，涉及控制流操作的<code>loop</code>、<code>match</code>、<code>continue</code>、<code>break</code>等语法，大家应当能够望文生义。对于这个完整代码，大家能够阅读并知道每一行干了啥即可，不必纠结于语法细节。</p><p>猜谜游戏运行结果如下：</p><p><img src="../images/9.png"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《The Rust Programming Language》</li><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#0：初窥门径</title>
      <link href="posts/56021c3e.html"/>
      <url>posts/56021c3e.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么选择Rust"><a href="#为什么选择Rust" class="headerlink" title="为什么选择Rust"></a>为什么选择Rust</h3><p>这个世界上的编程语言不计其数，仅在 <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>（开发语言排行榜）上被纳入统计范围的就有273种之多，下图是当下最流行的前20种编程语言。</p><p><img src="../images/1.png"></p><p>这些优秀的编程语言往往都有自己的绝活，例如C性能非常高，Java便于抽象擅长组织大型程序，Python适合小巧的脚本，等等。但同样，它们也并非完美，性能高的C容易产生段错误（segfault，由访问不属于本程序拥有的内存所造成的崩溃，例如空指针解引用等），擅长抽象的Java需要垃圾回收（GC），上手快的Python解释执行速度较慢。所以，编程语言的设计和发展仍有进步的空间，而Rust就是近年来涌现的新一代的综合各大编程语言优点的集大成者。</p><p>Rust的设计者是这样定位这门语言的：</p><blockquote><p> Rust is a system’s programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>Rust的突出优势可以总结为以下三点（无须看懂，知道Rust很厉害就完事了）：</p><ul><li>内存安全：Rust最重要的特点就是可以提供内存安全保证，而且没有额外的性能损失。保证内存安全即不会出现内存访问错误，为此，Rust建立了严格的内存安全管理模型：<ul><li>所有权系统：每个被分配的内存都有一个独占其所有权的指针，只有当该指针被销毁时，其对应的内存才能随之被释放。所有权系统借鉴了C++的RAII机制，这是Rust无GC但是可以安全管理内存的基石。</li><li>借用和生命周期：每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。</li></ul></li><li>零成本抽象：抽象表达能力是使用编程语言高效开发的必要条件，有些语言的抽象表达能力是靠牺牲性能换来的，而Rust的抽象表达能力不会存在运行时性能开销。Rust零成本抽象的基石是泛型和trait。</li><li>并发：内存安全的bug和并发安全的bug产生都是由内存的不正当访问造成的，所以，利用装载了所有权的强大类型系统，Rust能够在编译期检查出多线程并发代码中的数据竞争问题。</li></ul><p>Rust以其独特的魅力已经连续多年荣膺StackOverflow网站最受程序员欢迎的编程语言，虽然目前其在TIOBE榜单上还未入前列，但未来互联网必定更加注重安全和高性能，所以应运而生的Rust必将大有可为。</p><p>在学习Rust的语法之前，我们先一起来了解一下Rust的周边知识。</p><h3 id="Rust常用网站"><a href="#Rust常用网站" class="headerlink" title="Rust常用网站"></a>Rust常用网站</h3><ul><li>官方网站：点击<a href="https://www.rust-lang.org/">这里</a>。在这里你可以找到官方教材TRPL等许多重要内容，所以探索一下此网站大有裨益。</li><li>编译器是开源的：点击<a href="https://github.com/rust-lang/rust">这里</a>。对Rust语言来说，开源社区也是语言的一部分，这是和其他商用语言的区别所在。</li><li>语言设计和相关讨论：点击<a href="https://github.com/rust-lang/rfcs">这里</a>。Rust每增加一个重要语言特性，都会经过标准的RFC流程，RFC文档是涵盖了语言特性的设计意图、详细设计、优缺点的完整技术方案。这对于我们学习者来说，可以通过阅读RFC来深入了解某个语言特性的来龙去脉，这将是一个极其宝贵的学习资源，有助于了解某个特性背后的原理。</li><li>官方开源仓库：点击<a href="https://crates.io/">这里</a>。该网站储存了Rust社区热门的开源库。</li></ul><h3 id="版本和发布策略"><a href="#版本和发布策略" class="headerlink" title="版本和发布策略"></a>版本和发布策略</h3><p>Rust编译器的版本号采用了“语义化版本号”（Semantic Versioning）的方案，版本格式为：主版本号.次版本号.修订号，其递增规则如下：</p><ul><li>主版本号：当做了不兼容的API修改</li><li>次版本号：当做了向下兼容的功能性新增</li><li>修订号：当做了向下兼容的问题修正</li></ul><p>Rust团队维护三个发行分支：</p><ul><li>开发版（nightly）：最新的功能将首先发布在此分支，供用户试用。</li><li>测试版（beta）：将nightly版本中验证过的功能开放给用户使用，可以看作是stable版本的预发布版本。</li><li>稳定版（stable）：每隔6个星期发布的稳定可靠的版本。</li></ul><p>Rust语言每个相对复杂一点的新功能，都要经历如下步骤才算真正稳定可用：</p><blockquote><p>RFC -&gt; Nightly -&gt; Beta -&gt; Stable</p></blockquote><p>有时一些新功能确实需要一定程度上破坏兼容性，为了最大程度上减少这些变动给用户带来的影响，Rust设计组又提出一个所谓的edition方案，目前有 2015 和 2018两种edition，我们可以设置”edition=2018”来告诉编译器我们使用的版本。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>根据官网的<a href="https://www.rust-lang.org/tools/install">推荐</a>，可以使用一个叫rustup的工具安装Rust相关的一整套工具链。命令如下：</p><pre class=" language-bash"><code class="language-bash">curl --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> sh</code></pre><p>我们可以使用rustup工具管理工具链：</p><pre class=" language-bash"><code class="language-bash">// 更新rustup本身rustup self update// 更新工具链rustup update</code></pre><p>也可以用它在stable/beta/nightly三种版本中轻松切换：</p><pre class=" language-bash"><code class="language-bash">// 安装nightly版本的工具链rustup <span class="token function">install</span> nightly// 设置默认工具链是nightly版本rustup default nightly</code></pre><p>若执行下列命令能够正确输出版本号则说明Rust安装成功：</p><pre class=" language-bash"><code class="language-bash">rustc --version</code></pre><p>若安装不成功，请尝试将<code>~/.cargo/bin</code>加入PATH环境变量中去。</p><p>在<code>~/.cargo/bin</code>目录下可以找到Rust的一些常用工具，如下图所示：</p><p><img src="../images/2.png"></p><ul><li>cargo：Rust的包管理器，类似于Python的pip、Node.js的npm。但cargo不仅局限于包管理，它还为Rust生态系统提供了标准的工作流，能够管理整个工作流程，从创建项目、运行单元测试和基准测试，到构建发布链接库，再到运行可执行文件，等等。</li><li>rustc：Rust的编译器，负责将Rust源代码编译为可执行文件或其他库文件。rustc是Rust开发的，其输出的错误信息非常友好和详尽，远超你见过的任何一款编译器。</li><li>rustdoc：文档生成器。</li><li>rls和racer：为编辑器准备的代码提示工具。</li><li>cargo-fmt和rustfmt：源代码格式化工具，有了这个，再也不用争论大括号是写在行尾还是另起一行了。</li><li>rust-gdb和rust-lldb：调试器。</li></ul><p>对于IDE，Rust尚没有专属的IDE，我推荐Clion+Rust插件，已经非常好用了。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>配置好了开发环境，如何能不写一个充满仪式感的Hello World程序呢？来，新建一个文件，命名为<code>hello_world.rs</code>，内容如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// hello_world.rs</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后使用rustc编译它，可看到当前文件夹下生成了一个名为<code>hello_world</code>的可执行程序：</p><p><img src="../images/3.png"></p><h3 id="Rust的设计哲学"><a href="#Rust的设计哲学" class="headerlink" title="Rust的设计哲学"></a>Rust的设计哲学</h3><p>Rust是具有混合范式的“面向过程”式的编程语言，它包含了面向对象、函数式和泛型三种编程范式，其设计哲学如下：</p><ul><li>内存安全为第一准则</li><li>注重并发安全，避免数据竞争</li><li>持续提升性能</li><li>保持语言的高度一致性</li><li>语言必须有可见的实用性</li><li>注重开发体验和学习体验</li><li>现代化语言特性</li><li>拥抱开源社区</li></ul><h3 id="学习Rust的建议"><a href="#学习Rust的建议" class="headerlink" title="学习Rust的建议"></a>学习Rust的建议</h3><p>这些建议来自于张汉东老师，我认为还是十分中肯的，所以列在此处和大家分享。</p><ul><li>从整体出发，不要让自己陷入到细节中去。先有高屋建瓴的结构性的认知，再深入语法细节，有利于建立知识网络，可以事半功倍。</li><li>抛弃一次性学会的念头，分层次递进式学习。</li><li>和你已知的知识建立联系。新语言新特性的出现的本质原因是为了解决某个问题，因此，当我们学习Rust的新特性时，可以和其他语言的旧特性进行对比，了解其改进的动机和方式，这有助于增强对语法的记忆和理解。</li><li>学会阅读源码，从源码中学习。建议在学习语法时，顺带阅读源码。</li><li>通过主题式阅读来填补知识空白。可以从其他语言的相同特性中了解语法的概念，观察不同语言对同一概念的不同实现方式，</li><li>时刻把握Rust设计哲学。我们要从Rust的设计哲学去思考某种特性这样设计的原因。</li><li>有意识的构建Rust的心智模型。有意识的训练以Rust的方法思考代码编写的方式。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
