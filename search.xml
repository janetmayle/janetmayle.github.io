<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust学习笔记#3：类型</title>
      <link href="posts/879d15dc.html"/>
      <url>posts/879d15dc.html</url>
      
        <content type="html"><![CDATA[<p>类型于20世纪50年代被FORTRAN语言引入，发展到今日，类型已经成为了各大编程语言的核心基础，Rust也不例外。所谓类型，就是对表示信息的值进行的细粒度的区分，比如整数、小数、文本等。不同的类型占用的内存不同，与直接操作比特位相比，直接操作类型可以更安全更有效地利用内存 。</p><p>Rust是一个<strong>强显式静态类型</strong>的语言。下面解释一下何为“强显式静态类型”：</p><ul><li>在编译期进行类型检查的语言属于静态类型，在运行期进行类型检查的语言属于动态类型。</li><li>不允许类型的自动隐式转换的语言属于强类型，反之则是弱类型。</li><li>在静态类型语言中，依靠编译器自动推导类型而不需要显式指定类型的语言属于显式静态类型，反之则是隐式。Rust的编译器具有自动推导类型的能力，但还不够强大，在很多地方仍需要显式指定类型，类型仍然是Rust语法的一部分。</li></ul><p>Rust中一切皆表达式，表达式皆有值，值皆有类型，因此，Rust中一切皆类型。Rust中包含基本的原生类型和复合类型，也包含线程崩溃等无返回值的never类型。Rust类型系统吸收百家之长，基本囊括了编程中会遇到的各种情况，一般不会有未定义的行为出现，所以说，Rust是类型安全的语言。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p> Rust内置了布尔类型，类型名为<code>bool</code>，它有两个值：<code>true</code>和<code>false</code>。示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不显示声明类型，自动推断x为bool类型</span><span class="token keyword">let</span> y<span class="token punctuation">:</span> bool <span class="token operator">=</span> <span class="token operator">!</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取反运算</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 逻辑与，带短路功能</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">||</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 逻辑或，带短路功能</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">&amp;</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位与</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">|</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位或</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位异或</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用布尔值的主要场景是条件表达式，但注意，Rust并不支持将数字转换为<code>bool</code>类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> x <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// error[E0308]: mismatched types, expected `bool`, found integer</span></code></pre><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>字符类型由<code>char</code>表示，用单引号定义，代表一个unicode标量值。由于<code>char</code>类型的设计目的是描述任意一个unicode字符，所以它占据的空间不是1个字节，而是4个字节。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> heart_eyed_cat <span class="token operator">=</span> <span class="token string">'😻'</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> heart_eyed_cat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>Rust中，各种整数类型之间的主要区分特征是：有符号/无符号，占据空间大小。</p><table><thead><tr><th align="center">长度</th><th align="center">有符号</th><th align="center">无符号</th></tr></thead><tbody><tr><td align="center">8-bit</td><td align="center"><code>i8</code></td><td align="center"><code>u8</code></td></tr><tr><td align="center">16-bit</td><td align="center"><code>i16</code></td><td align="center"><code>u16</code></td></tr><tr><td align="center">32-bit</td><td align="center"><code>i32</code></td><td align="center"><code>u32</code></td></tr><tr><td align="center">64-bit</td><td align="center"><code>i64</code></td><td align="center"><code>u64</code></td></tr><tr><td align="center">128-bit</td><td align="center"><code>i128</code></td><td align="center"><code>u128</code></td></tr><tr><td align="center">arch</td><td align="center"><code>isize</code></td><td align="center"><code>usize</code></td></tr></tbody></table><p>有无符号代表数字能否为负值：</p><ul><li>有符号：每一个有符号的类型的表达范围为 [$-2^{n-1}$,  $2^{n-1} - 1$]，其中n为类型的长度。</li><li>无符号：每一个无符号的类型的表达范围为 [0,  $2^n - 1$]，其中n为类型的长度。</li></ul><p>另外，<code>isize</code>和<code>usize</code>依赖于运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。其他一些琐碎的知识点一并体现在下面的代码注释中：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 若编译器无法推断变量的具体类型，则自动默认为i32类型</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0x开头代表十六进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0o开头代表八进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0o55</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0b开头代表二进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0b1001</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可在数字字面量中任意地方添加下划线，以方便阅读</span><span class="token keyword">let</span> var <span class="token operator">=</span> 0x_1234_ABCD<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 字面量后面可以添加后缀，以标明具体类型</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">32u8</span><span class="token punctuation">;</span></code></pre><p>Rust的数字表达策略和C语言不同，C语言标准中对许多类型的大小并没有做强制规定，比如<code>int</code>类型在不同平台上可能是不同的大小，这给程序员带来了许多不必要的麻烦。相反，Rust在语言标准中规定好各个类型的大小，让编译器针对不同平台做适配，生成不同的代码，是更合理的选择。</p><p>整数运算中有一个让人头疼的问题是“溢出”。在C语言中，对于无符号类型，如果超过表示范围，则自动舍弃高位数据；对于有符号类型，如果超过表示范围，C标准规定这是未定义行为，这就是说编译器随便怎么处理都可以。未定义行为有利于编译器做一些更激进的性能优化，但这容易在极端场景下产生诡异的bug。</p><p>Rust的设计思路更倾向于预防bug，而不是无条件地压榨效率，Rust设计者希望尽可能减少整数溢出这种未定义行为。Rust的处理方式如下：</p><ul><li>debug模式：编译器会自动插入整数溢出检查，一旦发生溢出，则会引发panic（一种崩溃机制，暂且不表）;</li><li>release模式：不检查整数溢出，而是采用自动舍弃高位的方式。</li></ul><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>Rust提供了基于IEEE 754标准的浮点类型，按占据空间大小区分，分别为<code>f32</code>和<code>f64</code>，其使用方法与整型差别不大。如果不加后缀或没有指定类型，Rust会默认推断浮点数为<code>f64</code>类型，因为在现代CPU中，它与<code>f32</code>速度几乎一样，且精度还更高。</p><ul><li><code>f32</code>：数值范围为[$-3.4\times 10^{38}$, $3.4\times 10^{38}$]​</li><li><code>f64</code>：数值范围为[$-1.8\times 10^{308}$, $1.8\times 10^{308}$]</li></ul><p>浮点类型相对于整数类型的麻烦之处在于：它不仅可以表达正常的数值，还可以表达不正常的数值。参见下面的代码：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token operator">/</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}, y is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码的输出结果为<code>x is inf, y is NaN</code>，<code>inf</code>代表无穷大（infinite），<code>NaN</code>代表不是数字（Not a Number）。在标准库中，有一个<code>std::num::FpCategory</code>枚举类，表示了浮点数可能的状态：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> FpCategory <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// "Not a Number", often obtained by dividing by zero.</span>    Nan<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Positive or negative infinity.</span>    Infinite<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Positive or negative zero.</span>    Zero<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// De-normalized floating point representation (less precise than `Normal`).</span>    Subnormal<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// A regular floating point number.</span>    Normal<span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h4 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h4><p>我们一般将表示内存地址的类型称为指针。例如之前学习过的引用，它本质上就是一种非空指针，编译器会对引用进行借用检查，以保证内存安全和类型安全。原生指针主要用于<code>unsafe</code>代码块中，直接使用原生指针是不安全的，因为其可能为null，所以需要程序员自己保证安全。<code>unsafe</code>距离我们还很遥远，所以原生指针相关的只是暂且不表。</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是Rust内建的原始集合类型 ，数组的类型签名是<code>[T:N]</code>，其中T代表数组中元素的类型，N代表数组的长度，N为编译期常量，必须在编译时确定其值。对于两个数组类型，只有元素类型和元素个数都完全相同，这两个数组才是同类型的，才可以互相赋值。数组的特点为：</p><ul><li>数组大小固定</li><li>元素均为同类型</li><li>默认不可变</li></ul><p>Rust 中，数组中的值位于中括号内的逗号分隔的列表中。下面代码中定义了类型为<code>[i32; 3]</code>的数组，该数组是固定长度的，不允许对其添加或删除元素。即使通过<code>let mut</code>关键字定义，也只能修改已存在于索引位上的元素。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[1, 2, 3]</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[4, 2, 3]</span></code></pre><p>如果希望创建一个每个元素都相同的数组，可以在中括号内指定其初始值，后跟分号，再后跟数组的长度，如下所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[3, 3, 3, 3, 3]</span></code></pre><p>Rust会在编译期尽可能地检查数组索引是否小于数组的长度，如果发现问题，会报编译错误：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: index out of bounds</span></code></pre><p>但静态分析的能力有限，数组越界错误不能够全部在编译期查出来，Rust会在运行时继续检查索引是否小于数组的长度，如果超出，则会panic。</p><p>一般情况下，<strong>Rust不鼓励大量使用索引操作</strong>，因为索引操作都会执行一次边界检查，所以其效率会比不执行边界检查的C/C++略低，更推荐的做法是使用迭代器。</p><h4 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h4><p>Rust内置了范围（Range）类型，包括左闭右开和全闭两种区间，语法为<code>begin..end</code>。<code>1..5</code>表示左闭右开区间，它是<code>std::ops::Range</code>的实例；<code>1..=5</code>表示全闭区间，它是<code>std::ops::RangeInclusive</code>的实例。每个<code>Range</code>都是一个迭代器，可以直接使用<code>for</code>循环进行打印：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片类型（Slice）是对一个数组的引用片段，切片代表一个指向数组起始位置的指针和数组长度。切片有利于安全有效地访问数组的一部分，因为切片引用的是已经存在的变量。使用引用操作符<code>&amp;</code>对数组进行引用，就产生了一个切片，也可以结合范围类型对数组进行切割：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：[1, 2, 3, 4, 5]</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：[3, 4]</span></code></pre><p>对于数组<code>[T;N]</code>，其借用指针的类型是<code>&amp;[T;N]</code>，但其切片的类型是<code>&amp;[T]</code>。<code>&amp;[T;N]</code>占用的空间大小和普通引用相同，而<code>&amp;[T]</code>占用的空间大小是普通引用的两倍：</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;i32 size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span>i32<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;i32 size is 8</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;[i32; 3] size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;[i32; 3] size is 8</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;[i32] size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;[i32] size is 16</span></code></pre><p>可以看到，数组切片的大小的确是普通引用的两倍，因为数组切片不止包含一个指向数组的指针，切片本身还含带长度信息。因此，切片还有一个非常形象的名字：胖指针（fat pointer）。胖指针的设计，避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题，保证了类型安全。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>出于内存安全的考虑，Rust提供了两种字符串类型：一种是固定长度字符串，不可以随便更改其长度，就是<code>str</code>字符串；另一种是可增长字符串，可以随便改变其长度，就是<code>String</code>字符串。</p><p>说到<code>str</code>，就不得不提到一个概念，动态大小类型（Dynamic Sized Type，DST），是指在编译阶段无法确定占用空间大小的类型。为了安全，指向DST的指针一般是胖指针。<code>str</code>就是DST类型，我们不能在栈上声明一个不定长大小的变量示例，也不能用它作为函数的参数和返回值。但是，<code>&amp;str</code>的大小是确定的，因此，<code>&amp;str</code>类型可以用作变量实例、函数参数和返回值。<code>&amp;str</code>又被称作字符串切片类型，平时对字符串常量的绑定也是获得的其切片：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">"jack"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：jack</span></code></pre><p>Rust的字符串内部默认使用<code>utf-8</code>编码格式，而内置的<code>char</code>类型是4字节的unicode，所以Rust里面的字符串不能视为<code>char</code>类型的数组，而更接近<code>u8</code>类型的数组。这样设计的缺点是不能支持<code>O(1)</code>复杂度的索引操作，它的复杂度是<code>O(n)</code>，因为<code>utf-8</code>是变长编码，如果不从头开始过一遍，根本不知道第n个字符的地址在什么地方。</p><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p>Rust提供了一种特殊数据类型，never类型，用<code>!</code>表示，代表永远不可能有返回值的计算类型，比如线程退出的时候，就不可能有返回值。Rust是一个类型安全的语言，所以也需要将这种情况纳入类型系统中进行统一管理。见下面的代码：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token keyword">match</span> num <span class="token punctuation">{</span>    <span class="token function">Some</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> num<span class="token punctuation">,</span>    None <span class="token operator">=</span><span class="token operator">></span> <span class="token function">panic!</span><span class="token punctuation">(</span><span class="token string">"Nothing!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：42</span></code></pre><p>上面的代码中使用了一种当下还没学到的语法，不过不必在意，只需知道<code>match</code>表达式要求所有的分支都必须返回相同的类型，而<code>num</code>是<code>i32</code>类型，<code>panic!</code>宏会返回<code>!</code>类型，但这里没有报错，是因为never类型是可以强制转换为其他任何类型的。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>为了防止隐藏的bug，Rust希望类型转换时要显式地标记出来，类型转换使用关键字<code>as</code>。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a<span class="token punctuation">:</span> i8 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> i16 <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0308]: mismatched types</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> i16 <span class="token operator">=</span> a <span class="token keyword">as</span> i16<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确写法</span></code></pre><p>注意，<code>as</code>关键字也不是随便可以用的，它只允许编译器认为合理的类型转换。对于表达式<code>e as U</code>，下图中是所允许的类型转换。</p><p><img src="../images/10.png"></p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Rust提供了3种常用的复合数据类型，且都是异构数据类型，即可以使用它们将多种类型构建为统一的数据类型：</p><ul><li>元组（Tuple）</li><li>结构体（Struct）</li><li>枚举体（Enum）</li></ul><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p><code>tuple</code>指的是“元组”类型，它通过圆括号包含一组表达式构成，<code>tuple</code>内的元素没有名字，<code>tuple</code>是把几个类型组合到一起的最简单的方式。访问<code>tuple</code>内部元素可以通过模式匹配或者数字索引。示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有一个元素的元组要加一个逗号以区分表达式和元组</span><span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模式匹配访问元组元素</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> p<span class="token number">.0</span><span class="token punctuation">,</span> p<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数字索引访问元组元素</span></code></pre><p>元组内部也可以一个元素都没有，称为<code>unit</code>，占用0内存空间。</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：0</span></code></pre><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p><code>struct</code>和<code>tuple</code>的区别是它的每个元素都有自己的名字，每个元素之间采用逗号分开，类型依旧跟在冒号后面，但必须显示指定不能省略：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Point <span class="token punctuation">{</span>    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>    y<span class="token punctuation">:</span> i32<span class="token punctuation">}</span></code></pre><p><code>struct</code>类型的初始化使用<code>成员-冒号-值</code>的方式，如果有局部变量名字恰好和成员名字一致，则可以省略成员名字：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> p <span class="token operator">=</span> Point<span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> p <span class="token operator">=</span> Point<span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>访问结构体内部的元素使用“点”加变量名的方式，也可以使用模式匹配。</p><h4 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h4><p><code>tuple</code>本身和其元素都没有名字，<code>struct</code>本身和其元素都有名字，<code>tuple struct</code>本身有名字，但其元素没有名字：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token function">Color</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>tuple struct</code>有一个特殊的用法，即当它只包含一个元素的时候，就是所谓的<code>newtype idiom</code>，可以让我们很方便地在一个类型的基础上创建一个新的类型。</p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>与C/C++中的枚举相比，Rust中的<code>enum</code>要强大得多，它可以为每个成员指定附属的类型信息。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> Number <span class="token punctuation">{</span>    <span class="token function">Int</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">Float</span><span class="token punctuation">(</span>f32<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p><code>enum</code>中每个元素可以像空结构体一样，不指定它的类型；也可以像<code>tuple struct</code>一样，用圆括号加无名成员；还可以像正常结构体一样，用大括号加带名字的成员。</p><p>Rust标准库中有一个极其常用的<code>enum</code>类型<code>Option&lt;T&gt;</code>，它的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    None<span class="token punctuation">,</span>    <span class="token function">Some</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>其中T代表的是类型，这是一种泛型的写法。<code>Option&lt;T&gt;</code>的含义是“要么存在，要么不存在”，可以有效提升程序的健壮性。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#2：变量声明、绑定与引用</title>
      <link href="posts/f80c8a5a.html"/>
      <url>posts/f80c8a5a.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Rust中的变量分局部变量和全局变量两种，且必须先声明后使用，常见的声明语法为：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 声明局部变量，使用let关键字</span><span class="token keyword">let</span> var<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明全局变量，使用static关键字</span><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </code></pre><p>由于Rust非常注重内存安全，因此全局变量的使用有许多限制，我们日常使用最多的还是局部变量。与传统的C/C++语言相比，Rust的变量声明语法不同，这样设计主要有下列三种优点：</p><ul><li>语法分析更容易：Rust的局部变量声明一定是以关键字<code>let</code>开头，类型一定跟在<code>:</code>后面，语法歧义更少，语法分析器更容易编写。</li><li>类型推导更方便：Rust的变量声明的一个重要特点是，要声明的变量前置，对它的类型描述后置。这是吸取了其他语言的教训后的结果，因为在变量声明语句中，最重要的是变量本身，类型只是附属的额外描述，并非必不可少的部分，类型可以由编译器自动推导获得，因此类型后置的语法更合适。</li><li>支持模式解构：<code>let</code>不仅能声明局部变量，还具有模式结构（pattern destructure）的功能，这里暂且不表。</li></ul><p>Rust中变量声明默认是“只读”的，如果需要让变量可写，则需要使用<code>mut</code>关键字，<code>mut</code>是<code>mutable</code>的简写：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x为只读变量，因此会报编译错误</span><span class="token keyword">let</span> <span class="token keyword">mut</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用mut关键字声明一个可写变量</span>y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>Rust中变量必须被初始化后才可以使用，否则会报编译错误。因此，不被初始化的变量是没有默认值的。变量既可以在声明时初始化，也可以在使用前初始化：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> i32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明变量x</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化变量x，不需要x是mut，因为这是初始化不是修改</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>不过，为了减少代码阅读的负担，笔者还是建议在变量声明时就初始化。</p><p>Rust中的合法标识符（包括变量名、函数名等）必须由数字、字母、下划线组成，且不能以数字开头。注意，单独的下划线是一个特殊的标识符，在编译器内部是被特殊处理的，不能作为普通变量使用，其具体用法这里暂且不表。Rust中关于变量的命名规范是蛇形命名法，使用下划线，一般用小写，即<code>file_name</code>。</p><h4 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h4><p>Rust中允许在同一个代码块中声明同样名字的变量，如果这样做，后面声明的变量会将前面声明的变量遮蔽（Shadowing）起来，从而前面的变量将无法访问。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面这种形式的代码在很多编程语言中是无法编译通过的，因为变量x被重复声明，但在Rust中是可以编译通过的：前后两个<code>x</code>是完全不同的两个变量，内存空间不同，类型也不同，只是恰巧名字相同。</p><p>Rust这种设计有时非常实用，例如，我们需要在同一个函数内部把一个变量转换为另一个类型的变量，但又不想给它们起不同的名字。但是，我个人认为变量遮蔽可能会带来阅读代码时的歧义，不建议滥用，建议有限使用，例如函数参数是字符串类型的<code>file_path</code>，这是使用变量遮蔽将其转换为Path类型的<code>file_path</code>就比较合适。但以我现在的水平尚不能仔细分析变量遮蔽这一特性的利弊权衡，或许未来能够在RFC中找到答案。</p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>Rust编译器的类型推导功能很强大，不仅可以从变量声明的当前语句中获取信息进行推导，而且还能通过上下文信息进行推导。类型推导和“动态类型”是两码事，Rust仍然是静态类型的，所有变量的类型都必须在编译阶段确定，类型推导只是辅助我们在某些情况下不需要显示写出类型而已。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用<code>type</code>关键字给同一个类型起个别名，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">type</span> Age <span class="token operator">=</span> u32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// u32代表无符号的32位整数类型</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> Age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>可以用<code>static</code>关键字声明静态变量，这也是Rust中唯一的声明全局变量的方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>为了保证内存安全，全局变量的使用有很多限制：</p><ul><li>必须在声明时立即初始化</li><li>初始化必须是编译期可确定的常量</li><li>带有<code>mut</code>修饰的全局变量，在使用的时候必须使用<code>unsafe</code>关键字。</li></ul><p><code>unsafe</code>关键字用于逃过Rust编译器的检查以写一些可能存在危险的代码，当下无须深入研究。从上面第三条限制可以看出，Rust并不鼓励我们使用可变的全局变量，更希望我们把全局变量用成全局常量。注意，全局变量的声明周期是整个程序从启动到退出。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>可以使用<code>const</code>关键字声明一个常量：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">const</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>常量和静态变量最大的区别在于：编译器不一定会给常量分配内存空间，可能会在编译过程中将常量內联优化。</p><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>通过<code>let</code>关键字来创建变量，这是Rust语言从函数式语言中借鉴的语法形式。<code>let</code>创建的变量一般称为绑定（binding），而不是我们通常说的赋值，因为它表达的是位置表达式和值表达式之间建立的一种关联关系。</p><p>Rust中的表达式可以分为位置表达式和值表达式，在其他语言中，一般称为左值和右值。</p><ul><li>位置表达式：表示内存位置的表达式，有本地变量、静态变量、解引用、数组索引和字段引用五种。通过位置表达式可以对某个数据单元的内存进行读写。</li><li>值表达式：只引用了某个存储单元地址中的数据，相当于数据值，只能进行读操作。值表达式要么是字面量，要么是表达式求值过程中创建的临时值。</li></ul><p>表达式的求值过程在不同的上下文中会有不同的结果，求值上下文也分位置上下文和值上下文。下面几种表达式属于位置上下文（不必看懂，了解就好）：</p><ul><li>赋值或者复合赋值语句左侧的操作数</li><li>一元引用表达式的独立操作数</li><li>包含隐式借用的操作数</li><li>match判别式或let绑定右侧在使用ref模式匹配的时候也是位置上下文</li></ul><p>除了上述几种情况，其余表达式都属于值上下文。一般情况下，值表达式出现在值上下文中，位置表达式出现在位置上下文中，但也存在特殊情况：</p><ul><li>值表达式不能出现在位置上下文中，否则会报错：</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// error[E0070]: invalid left-hand side of assignment</span><span class="token string">"hello"</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ul><li>当位置表达式出现在值上下文中时，该位置表达式会把<strong>所有权</strong>转移给另外一个位置表达式。</li></ul><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>我们刚刚看到了一个新名词，“所有权（ownership）”，所有权代表着以下意义：</p><ul><li>每个值在Rust中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者。</li><li>每个值在一个时间点上只有一个管理者。</li><li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li></ul><p>当位置表达式出现在值上下文中时，这种所有权转移在Rust中称为移动语义。但在日常开发中，有时候并不需要转移所有权，Rust提供了引用操作符<code>&amp;</code>，可以直接获得位置表达式的内存地址，并通过该地址进行读写操作，解引用使用<code>*</code>操作符。下面看一个引用和解引用的示例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的代码中，32这个值的所有权归变量x所有，变量y中存储的是其地址，最后通过解引用操作符<code>*</code>将引用y中的值取出来，以供<code>assert_eq!</code>宏使用，因为变量x仍旧保留它们的所有权，所以引用也被称为借用。</p><p>生命周期是Rust的核心概念，而所有权、借用等概念又和生命周期息息相关，但目前先不必去深入了解它，待把基础语法掌握后，再去学习Rust的精髓，方能事半功倍。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#1：一个猜谜游戏小项目</title>
      <link href="posts/8ab0a41e.html"/>
      <url>posts/8ab0a41e.html</url>
      
        <content type="html"><![CDATA[<p>在深入探索Rust语法的细枝末节之前，先通过一个麻雀虽小但五脏俱全的小项目来整体把握Rust，这样可以避免迷失在细节的海洋中。我们可能会通过这个小项目一下子接触到很多新概念，但不必惊慌，我们只需浅尝辄止对这些概念有个印象即可。</p><p>《TRPL》（Rustaceans对《The Rust Programming Language》的爱称）中就给出了一个经典的猜谜游戏的例子，我们一起来学习它。</p><blockquote><p>猜谜游戏：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜错了，会请玩家继续猜测；如果猜对了，它会打印祝贺信息并退出。</p></blockquote><h3 id="Rust如何管理项目"><a href="#Rust如何管理项目" class="headerlink" title="Rust如何管理项目"></a>Rust如何管理项目</h3><p>并不是所有的代码都像<code>hello_world.rs</code>一样，一个文件就可以搞定。一个项目往往具有复杂的代码，我们需要一种机制来管理这种复杂性，将一个项目切分成若干小部分，每个部分再进行切分，层层抽象，直到达到人脑可以处理的规模。每种编程语言都有这样的机制，例如Java的package机制，Rust也不例外。</p><p>Rust用了两个概念来管理项目：一个是crate（项目），一个是mod（模块）。模块（mod）是用于在项目（crate）内部进行分层和封装的机制，模块内部可以包含模块。</p><ul><li>crate：可以简单理解为一个项目，crate是Rust中的独立编译单元（compile unit），每个crate对应生成一个库或者可执行文件。作为对比，我们比较熟悉的C语言中，一个单独的.c文件和其所有的include文件组成一个编译单元，每个.c生成一个.o，然后将这些.o链接起来生成可执行文件。</li><li>mod：可以简单理解为命名空间。mod可以嵌套（注意crate之间不能出现循环引用），还可以控制内部元素的可见性。</li></ul><p>说到可见性问题，在Rust中，元素默认都是私有的，用<code>pub</code>关键字修饰的元素才是公开的。公开和私有的访问权限规定如下：</p><ul><li>如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问</li><li>如果一个元素是公开的，那么可以在本模块外的作用域访问它。</li></ul><p>模块是一种抽象的概念，文件是承载这个概念的实体，但是模块和文件并不是简单的一一对应关系。在一个crate内部创建mod的方式有下面三种：</p><ul><li>在一个rs文件中创建内嵌模块，直接使用<code>mod</code>关键字即可。</li><li>独立的一个rs文件就是一个模块，文件名即是模块名。</li><li>一个文件夹也可以视为一个模块，文件夹内部要有一个<code>mod.rs</code>文件，这个文件是这个模块的入口。注意必须要在这个<code>mod.rs</code>中声明其子模块，否则子模块无法被当成这个项目的源码进行编译；另外，也需要在该文件夹所在的mod的入口文件中声明该文件夹。</li></ul><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>cargo不仅是Rust的包管理器，还可以用于创建项目。使用下列命令可以创建一个名为<code>guessing_game</code>的项目：</p><pre class=" language-bash"><code class="language-bash">cargo new guessing_game --bin</code></pre><p>注意，后面的<code>--bin</code>意味着我们希望项目生成的是可执行程序，如果希望是library，则可以使用<code>--lib</code>选项。</p><p>以上为在命令行中手工创建项目，在Clion中可以点击<code>File-&gt;New Project</code>后如下图填写，然后点击<code>Create</code>按钮：</p><p><img src="../images/4.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>我们可以使用<code>tree</code>命令或者直接在Clion中查看当前的文件夹结构，如下图所示：</p><p><img src="../images/5.png"></p><ul><li>src/main.rs：这是cargo自动生成的rs文件。还记得前面讲的crate和mod的概念吗？在这个项目中，<code>guessing_game</code>是crate，<code>src</code>文件夹是mod，<code>main.rs</code>是<code>src</code>mod的入口（相应的，<code>lib.rs</code>是library类型crate的入口）。我们可以在<code>src</code>mod中创建子模块，但注意，这些子模块都要在<code>main.rs</code>中声明，否则无法参与编译。</li><li>.gitignore：这是git忽略文件，不懂其作用的同学可以自行搜索。这里重点要说的是通过<code>cargo new</code>创建的项目天然就是一个git项目，这也印证了Rust对开源的拥护。</li><li>Cargo.toml：这是项目管理配置文件。TOML是一种非常简洁好用的配置文件格式，TOML是<code>Tom&#39;s Obvious, Minimal Language</code>的首字母缩写，这里的Tom是Github的联合创始人之一，感兴趣的同学可以进一步自行了解TOML配置文件的写法。</li><li>Cargo.lock：该文件包含项目依赖项的确切信息，由Cargo维护，我们无须关心它。</li></ul><h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><p>在<code>src/main.rs</code>里cargo已经自动生成了输出<code>Hello, world!</code>的代码，我们来运行一下它看能否正常输出。</p><p>插一句题外话，在你日后漫长的Rust编码生涯中，你会发现，你将在处理编译错误上耗费大量的时间。还记得吗，Rust 的一大特色是保证内存安全，这保证了Rust代码只要运行起来就几乎不会发生内存错误，这么诱人的效果的背后的代价就是，我们要在编码时付出额外的努力。Rust为了保证内存安全设计了一套复杂的规则，这导致我们的代码一不留神就会编译不过。所以，在你日后经常用的一个操作就是检查能否编译通过，而不是直接编译，因为直接编译还要进行代码优化等操作所以会相对费时。可以使用下列命令检查编译错误：</p><pre class=" language-bash"><code class="language-bash">cargo check</code></pre><p>在Clion中需要新加一个Configuration来执行<code>cargo check</code>命令，如下图所示：</p><p><img src="../images/6.png"></p><p>确保<code>cargo check</code>通过后，可以执行<code>cargo build</code>来执行编译。编译后会产生一个<code>target</code>文件夹，在<code>target/debug</code>下会有一个和crate同名的可执行文件。但一般为了方便，可以直接执行<code>cargo run</code>，这条命令等价于先编译后执行。下图是执行<code>cargo run</code>后Clion的控制台输出：</p><p><img src="../images/7.png"></p><h3 id="猜谜游戏"><a href="#猜谜游戏" class="headerlink" title="猜谜游戏"></a>猜谜游戏</h3><p>在完成了项目搭建后，接下来就要开始猜谜游戏的代码编写了，我将它们分成六部分：创建变量、输入、输出、错误处理、随机数生成、完整代码。</p><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><p>使用<code>let</code>语句创建变量，需要注意的是，在Rust中，变量默认是不可变的，可以在变量名前使用<code>mut</code>来使得变量可变：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不可变</span><span class="token keyword">let</span> <span class="token keyword">mut</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可变</span></code></pre><p>在上面的<code>let</code>语句中，我们并没有显示声明变量的类型，但这并不代表Rust是动态类型的，Rust仍然是静态类型的，只不过Rust有一个可以通过上下文推断类型的强大编译器。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>我们早已在<code>hello_world.rs</code>中见识过了最基本的输出方式：</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>需要注意的是，这里的<code>println!</code>是一个宏，而非一个函数，println后面的感叹号就是宏的标志。Rust中的宏与C/C++中的宏是完全不一样的东西，简单说，可以把它理解为一种安全版的编译期语法扩展。这里之所以使用输出宏而非函数，是因为标准输出宏可以完成编译期格式检查，更加安全。</p><p>如果需要输出某个变量的值，可以使用占位符<code>&#123;&#125;</code>，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x = {} and y = {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其输出结果为：</p><pre class=" language-bash"><code class="language-bash">x <span class="token operator">=</span> 0 and y <span class="token operator">=</span> 10</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>为了从控制台中获取用户的输入，需要使用标准库<code>std::io</code>。使用<code>use</code>语句将该库引入当前作用域：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span></code></pre><p>我们可以使用<code>io</code>库中的函数<code>stdin</code>：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个字符串类型的可变变量</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>stdin</code>函数返回一个<code>std::io::Stdin</code>的实例，这代表终端标准输入句柄的类型。然后调用<code>read_line</code>方法，可以从标准输入中读取一行并存入到<code>guess</code>变量中去。<code>&amp;</code>表示这是一个引用，这是一个复杂的特性，我们现在无须了解它。</p><p>读取用户输入后，我们需要判断用户是否正确输入了数字。<code>String</code>类型带有处理字符串处理的一些方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Please type a number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>字符串的 <code>parse </code>方法将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess </code>后的冒号<code>:</code>告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型，u32 是一个无符号的 32 位整型。<code>trim</code>方法用于消除回车空格等符号。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>上一小节代码中还有一个<code>expect</code>没有分析，而这就涉及到Rust中的错误处理机制了。<code>read_line</code>的返回值类型是<code>io::Result</code>，它是<code>Result</code>类型在<code>io</code>模块的特化版本。<code>Result</code>是枚举类型，其成员为<code>Ok</code>和<code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err </code>成员则意味着操作失败，内部包含失败的前因后果。</p><p><code>Result</code>类型的作用是编码错误处理信息。<code>Result </code>类型像其他类型一样，拥有定义于其上的方法。<code>io::Result</code>的实例拥有<code>expect</code>方法。如果 <code>io::Result </code>实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并打印参数传递给 <code>expect </code>的信息。如果<code>io::Result</code>实例的值是 <code>Ok</code>，<code>expect </code>会获取 <code>Ok </code>中的值并返回。在本例中，这个值是用户输入到标准输入中的字节数。</p><h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h4><p>猜谜游戏需要能够自动生成随机数。Rust标准库中并未包含随机数功能，但我们可以通过引入外部crate来获得随机数功能。还记得Rust的官方开源仓库吗，那里可是有很多宝贝的。打开<code>https://crates.io/</code>，在搜索框中键入<code>rand</code>来搜索具有随机数功能的crate，出来的第一个结果就是我们需要的crate。</p><p><img src="../images/8.png"></p><p>现在我们将这个库引入到我们的项目中。打开<code>Cargo.toml</code>，在<code>[dependencies]</code>下添加：</p><pre class=" language-toml"><code class="language-toml">[dependencies]rand = "0.8.3"</code></pre><p><code>[dependencies]</code> 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。</p><p>下面使用<code>rand</code>库来产生随机数。首先，使用<code>use</code>语句引入<code>rand</code>，<code>use rand::Rng;</code>。然后调用下列函数产生一个1和100之间的数：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>猜谜游戏的完整代码如下。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cmp<span class="token punctuation">:</span><span class="token punctuation">:</span>Ordering<span class="token punctuation">;</span><span class="token keyword">use</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span>Rng<span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Guess the number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> secret_number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Please input your guess."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Ok</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> num<span class="token punctuation">,</span>            <span class="token function">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">continue</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You guessed: {}"</span><span class="token punctuation">,</span> guess<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>secret_number<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Less <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too small!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Greater <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too big!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Equal <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You win!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，涉及控制流操作的<code>loop</code>、<code>match</code>、<code>continue</code>、<code>break</code>等语法，大家应当能够望文生义。对于这个完整代码，大家能够阅读并大概知道每一行干了啥即可，不必纠结于语法细节。</p><p>猜谜游戏运行结果如下：</p><p><img src="../images/9.png"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《The Rust Programming Language》</li><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#0：初窥门径</title>
      <link href="posts/56021c3e.html"/>
      <url>posts/56021c3e.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么选择Rust"><a href="#为什么选择Rust" class="headerlink" title="为什么选择Rust"></a>为什么选择Rust</h3><p>这个世界上的编程语言不计其数，仅在 <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>（开发语言排行榜）上被纳入统计范围的就有273种之多，下图是当下最流行的前20种编程语言。</p><p><img src="../images/1.png"></p><p>这些优秀的编程语言往往都有自己的绝活，例如C性能非常高，Java便于抽象擅长组织大型程序，Python适合小巧的脚本，等等。但同样，它们也并非完美，性能高的C容易产生段错误（segfault，由访问不属于本程序拥有的内存所造成的崩溃，例如空指针解引用等），擅长抽象的Java需要垃圾回收（GC），上手快的Python解释执行速度较慢。所以，编程语言的设计和发展仍有进步的空间，而Rust就是近年来涌现的新一代的综合各大编程语言优点的集大成者。</p><p>Rust的设计者是这样定位这门语言的：</p><blockquote><p> Rust is a system’s programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>Rust的突出优势可以总结为以下三点（无须看懂，知道Rust很厉害就完事了）：</p><ul><li>内存安全：Rust最重要的特点就是可以提供内存安全保证，而且没有额外的性能损失。保证内存安全即不会出现内存访问错误，为此，Rust建立了严格的内存安全管理模型：<ul><li>所有权系统：每个被分配的内存都有一个独占其所有权的指针，只有当该指针被销毁时，其对应的内存才能随之被释放。所有权系统借鉴了C++的RAII机制，这是Rust无GC但是可以安全管理内存的基石。</li><li>借用和生命周期：每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。</li></ul></li><li>零成本抽象：抽象表达能力是使用编程语言高效开发的必要条件，有些语言的抽象表达能力是靠牺牲性能换来的，而Rust的抽象表达能力不会存在运行时性能开销。Rust零成本抽象的基石是泛型和trait。</li><li>并发：内存安全的bug和并发安全的bug产生都是由内存的不正当访问造成的，所以，利用装载了所有权的强大类型系统，Rust能够在编译期检查出多线程并发代码中的数据竞争问题。</li></ul><p>Rust以其独特的魅力已经连续多年荣膺StackOverflow网站最受程序员欢迎的编程语言，虽然目前其在TIOBE榜单上还未入前列，但未来互联网必定更加注重安全和高性能，所以应运而生的Rust必将大有可为。</p><p>在学习Rust的语法之前，我们先一起来了解一下Rust的周边知识。</p><h3 id="Rust常用网站"><a href="#Rust常用网站" class="headerlink" title="Rust常用网站"></a>Rust常用网站</h3><ul><li>官方网站：点击<a href="https://www.rust-lang.org/">这里</a>。在这里你可以找到官方教材TRPL等许多重要内容，所以探索一下此网站大有裨益。</li><li>编译器是开源的：点击<a href="https://github.com/rust-lang/rust">这里</a>。对Rust语言来说，开源社区也是语言的一部分，这是和其他商用语言的区别所在。</li><li>语言设计和相关讨论：点击<a href="https://github.com/rust-lang/rfcs">这里</a>。Rust每增加一个重要语言特性，都会经过标准的RFC流程，RFC文档是涵盖了语言特性的设计意图、详细设计、优缺点的完整技术方案。这对于我们学习者来说，可以通过阅读RFC来深入了解某个语言特性的来龙去脉，这将是一个极其宝贵的学习资源，有助于了解某个特性背后的原理。</li><li>官方开源仓库：点击<a href="https://crates.io/">这里</a>。该网站储存了Rust社区热门的开源库。</li></ul><h3 id="版本和发布策略"><a href="#版本和发布策略" class="headerlink" title="版本和发布策略"></a>版本和发布策略</h3><p>Rust编译器的版本号采用了“语义化版本号”（Semantic Versioning）的方案，版本格式为：主版本号.次版本号.修订号，其递增规则如下：</p><ul><li>主版本号：当做了不兼容的API修改</li><li>次版本号：当做了向下兼容的功能性新增</li><li>修订号：当做了向下兼容的问题修正</li></ul><p>Rust团队维护三个发行分支：</p><ul><li>开发版（nightly）：最新的功能将首先发布在此分支，供用户试用。</li><li>测试版（beta）：将nightly版本中验证过的功能开放给用户使用，可以看作是stable版本的预发布版本。</li><li>稳定版（stable）：每隔6个星期发布的稳定可靠的版本。</li></ul><p>Rust语言每个相对复杂一点的新功能，都要经历如下步骤才算真正稳定可用：</p><blockquote><p>RFC -&gt; Nightly -&gt; Beta -&gt; Stable</p></blockquote><p>有时一些新功能确实需要一定程度上破坏兼容性，为了最大程度上减少这些变动给用户带来的影响，Rust设计组又提出一个所谓的edition方案，目前有 2015 和 2018两种edition，我们可以设置”edition=2018”来告诉编译器我们使用的版本。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>根据官网的<a href="https://www.rust-lang.org/tools/install">推荐</a>，可以使用一个叫rustup的工具安装Rust相关的一整套工具链。命令如下：</p><pre class=" language-bash"><code class="language-bash">curl --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> sh</code></pre><p>我们可以使用rustup工具管理工具链：</p><pre class=" language-bash"><code class="language-bash">// 更新rustup本身rustup self update// 更新工具链rustup update</code></pre><p>也可以用它在<code>stable/beta/nightly</code>三种版本中轻松切换：</p><pre class=" language-bash"><code class="language-bash">// 安装nightly版本的工具链rustup <span class="token function">install</span> nightly// 设置默认工具链是nightly版本rustup default nightly</code></pre><p>若执行下列命令能够正确输出版本号则说明Rust安装成功：</p><pre class=" language-bash"><code class="language-bash">rustc --version</code></pre><p>若安装不成功，请尝试将<code>~/.cargo/bin</code>加入PATH环境变量中去。</p><p>在<code>~/.cargo/bin</code>目录下可以找到Rust的一些常用工具，如下图所示：</p><p><img src="../images/2.png"></p><ul><li>cargo：Rust的包管理器，类似于Python的pip、Node.js的npm。但cargo不仅局限于包管理，它还为Rust生态系统提供了标准的工作流，能够管理整个工作流程，从创建项目、运行单元测试和基准测试，到构建发布链接库，再到运行可执行文件，等等。</li><li>rustc：Rust的编译器，负责将Rust源代码编译为可执行文件或其他库文件。rustc使用Rust语言开发，其输出的错误信息非常友好和详尽，远超你见过的任何一款编译器。</li><li>rustdoc：文档生成器。</li><li>rls和racer：为编辑器准备的代码提示工具。</li><li>cargo-fmt和rustfmt：源代码格式化工具，有了这个，再也不用争论大括号是写在行尾还是另起一行了。</li><li>rust-gdb和rust-lldb：调试器。</li></ul><p>对于IDE，Rust尚没有专属的IDE，我推荐Clion+Rust插件，已经非常好用了。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>配置好了开发环境，如何能不写一个充满仪式感的Hello World程序呢？来，新建一个文件，命名为<code>hello_world.rs</code>，内容如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// hello_world.rs</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后使用rustc编译它，可看到当前文件夹下生成了一个名为<code>hello_world</code>的可执行程序：</p><p><img src="../images/3.png"></p><h3 id="Rust的设计哲学"><a href="#Rust的设计哲学" class="headerlink" title="Rust的设计哲学"></a>Rust的设计哲学</h3><p>Rust是具有混合范式的“面向过程”式的编程语言，它包含了面向对象、函数式和泛型三种编程范式，其设计哲学如下：</p><ul><li>内存安全为第一准则</li><li>注重并发安全，避免数据竞争</li><li>持续提升性能</li><li>保持语言的高度一致性</li><li>语言必须有可见的实用性</li><li>注重开发体验和学习体验</li><li>现代化语言特性</li><li>拥抱开源社区</li></ul><h3 id="学习Rust的建议"><a href="#学习Rust的建议" class="headerlink" title="学习Rust的建议"></a>学习Rust的建议</h3><p>这些建议来自于张汉东老师，我认为还是十分中肯的，所以列在此处和大家分享。</p><ul><li>从整体出发，不要让自己陷入到细节中去。先有高屋建瓴的结构性的认知，再深入语法细节，有利于建立知识网络，可以事半功倍。</li><li>抛弃一次性学会的念头，分层次递进式学习。</li><li>和你已知的知识建立联系。新语言新特性出现的本质原因是为了解决某个问题，因此，当我们学习Rust的新特性时，可以和其他语言的旧特性进行对比，了解其改进的动机和方式，这有助于增强对语法的记忆和理解。</li><li>学会阅读源码，从源码中学习。建议在学习语法时，顺带阅读源码。</li><li>通过主题式阅读来填补知识空白。可以从其他语言的相同特性中了解语法的概念，观察不同语言对同一概念的不同实现方式，</li><li>时刻把握Rust设计哲学。我们要从Rust的设计哲学去思考某种特性这样设计的原因。</li><li>有意识地构建Rust的心智模型，有意识地训练以Rust的方法思考代码编写的方式。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
