<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust学习笔记#5：函数和trait</title>
      <link href="posts/74ae38f8.html"/>
      <url>posts/74ae38f8.html</url>
      
        <content type="html"><![CDATA[<h3 id="函数">函数</h3><h4 id="基本语法">基本语法</h4><p>Rust的函数使用<code>fn</code>关键字开头，函数可以有一系列的输入参数，还有一个返回类型。函数返回可以使用<code>return</code>语句，可以使用表达式。下面是一个标准函数的示例，<code>add</code>函数接受两个<code>i32</code>的参数，然后计算它们的和并返回：</p><pre class=" language-language-rust"><code class="language-language-rust">fn add(a: i32, b: i32) -> i32 {    a + b}println!("{}", add(1, 2)); // 输出：3</code></pre><p>函数返回值如果不显示标明，默认是<code>()</code>。函数返回值类型也可以是never类型<code>!</code>，这一类函数叫做发散函数，代表这个函数不能够正常返回，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">fn diverges() -> ! {    panic!("This function never return!")}</code></pre><p>Rust编写的可执行程序的入口是<code>fn main() -&gt; ()</code>函数。一般情况下，一个进程开始执行的时候可以接受一系列的参数，退出的时候也可以返回一个错误码，所以很多编程语言会为<code>main</code>函数设计参数和返回值类型，例如C语言中的<code>int main(int argc, char **argv)</code>。但是，Rust的<code>main</code>函数无参数也无返回值，其传递参数和返回状态码都通过单独的API来完成，示例如下：</p><pre class=" language-language-rust"><code class="language-language-rust">fn main() {    for arg in std::env::args() {        println!("Arg: {}", arg);    }}</code></pre><p>可以通过<code>std::env::args()</code>函数获取参数，通过<code>exit()</code>函数的参数传递错误码，通过<code>std::env::var()</code>读取环境变量。</p><h4 id="函数递归与TCO">函数递归与TCO</h4><p>函数递归是我们常用的一种思维方式，Rust也支持函数递归调用。下面用经典的<code>Fibonacci</code>数列来举例：</p><pre class=" language-language-rust"><code class="language-language-rust">fn fib(index: u32) -> u64 {    match index {        1 | 2 => 1,        _ => fib(index - 1) + fib(index - 2),    }}println!("{}", fib(25)); // 输出：75025</code></pre><p>谈起递归，我们都会想到尾递归优化的概念（TCO，Tail Call Optimization）。TCO可以把尾递归在编译阶段转换为迭代循环从而降低时间和空间开销，需要注意的是，Rust并不支持TCO，某个RFC的作者给出了以下理由：</p><ul><li>可移植性问题，LLVM当时在某些指定架构上特别是MIPS和WebAssembly，不支持正确尾调用。</li><li>LLVM中正确尾调用实际上可能会由于它们当时的实现方式而造成性能损失。</li><li>TCO让调试变得更加困难，因为它重写了栈上的值。</li></ul><h3 id="方法">方法</h3><p>在一些编程语言中，函数和方法往往是对同一种东西的两种称呼，但在Rust中，它们是有明确区分的。方法和函数的语法完全相同：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该函数时会执行的代码。但是，只有在结构体上下文中被定义的函数才能称为方法。</p><p>方法分为成员方法和静态方法，它们的区别在于第一个参数是否为<code>self</code>，若是则为成员方法，反之为静态方法。Rust中的<code>Self</code>和<code>self</code>都是关键字，其中<code>Self</code>是类型名，<code>self</code>是变量名，<code>self</code>代表调用该方法的结构体实例，静态方法属于结构体类型所有，所以不需要<code>self</code>。常见的<code>Self</code>和<code>self</code>的组合有： <code>self: Self</code>（获得所有权）、<code>self: &amp;Self</code>（仅仅读取）、<code>self: &amp;mut Self</code>（做出修改），因为它们的使用频率很高，Rust也提供了相应的语法糖来简写：<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>。</p><h4 id="成员方法">成员方法</h4><p>可以使用<code>impl</code>为结构体实现成员方法，如下面的代码所示。将函数移到<code>impl</code>块中，并将第一个参数改成<code>self</code>，就把函数变成了成员方法。和其他编程语言类似，调用成员方法只需在结构体示例后加<code>.</code>即可。每个结构体可以拥有多个<code>impl</code>块。</p><pre class=" language-language-rust"><code class="language-language-rust">struct Rectangle {    width: u32,    height: u32,}impl Rectangle {    fn area(&self) -> u32 {        self.width * self.height    }}fn main() {    let rect = Rectangle { width: 30, height: 50 };    println!(        "The area of the rectangle is {} square pixels.",        rect.area()    );}</code></pre><h4 id="静态方法">静态方法</h4><p>在<code>impl</code>块中定义的不以<code>self</code>作为第一个参数的方法就是静态方法，见下面的代码。可以使用结构体名和<code>::</code>运算符来调用静态方法，例如<code>let sq = Rectangle::square(3);</code>来获得一个大小为3的正方形。</p><pre class=" language-language-rust"><code class="language-language-rust">// 接上面impl Rectangle {    fn square(size: u32) -> Rectangle {        Rectangle { width: size, height: size }    }}</code></pre><h3 id="trait">trait</h3><h4 id="基本语法-2">基本语法</h4><p>trait的功能类似于Java中的接口，trait可以翻译为“特性”，它可以为多种类型抽象出共同拥有的一些功能。一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义将方法签名组合起来，目的是定义一个实现某些目的所必需的行为的集合。这些方法既可以是成员方法，也可以是静态方法。trait可以用关键字<code>trait</code>来声明，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">trait Shape {    fn area(&self) -> u32;    fn hello();}</code></pre><p>上面的代码声明了一个名为<code>Shape</code>的trait，它有一个名为<code>area</code>的方法，即，若某个类型拥有<code>Shape</code>这个特性，那么它一定可以求面积。为某个类型实现trait使用<code>impl...for</code>关键字，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">struct Rectangle {    width: u32,    height: u32,}trait Shape {    fn area(&self) -> u32;    fn hello();}impl Shape for Rectangle {    fn area(&self) -> u32 {        self.width * self.height    }    fn hello() {        println!("Just say hello!")    }}fn main() {    let rect = Rectangle {        width: 30,        height: 50,    };    println!(        "The area of the rectangle is {} square pixels.",        rect.area()    );    Rectangle::hello();}</code></pre><p>trait中的方法也可以有默认实现，那么在针对具体类型实现的时候，就可以不用重写。我们也可以利用trait为其他类型扩展方法，哪怕这个类型不是我们自己写的。例如，可以为内置类型<code>i32</code>添加一个方法：</p><pre class=" language-language-rust"><code class="language-language-rust">trait Double {    fn double(&self) -> i32;}impl Double for i32 {    fn double(&self) -> i32 {        *self * 2    }}fn main() {    let i: i32 = 5;    println!("{}", i.double()); // 输出：10}</code></pre><h4 id="孤儿规则">孤儿规则</h4><p>使用trait为类型扩展方法也要受到一定的限制，在声明trait和impl trait的时候，Rust规定了一个一致性规则，也称为孤儿规则：impl块要么与trait的声明在同一个crate中，要么与类型的声明在同一个crate中。也就是说，如果trait和类型都来自于外部的crate，那么便不允许为这个类型实现该trait。这是因为，该类型没有实现该trait，这可能是该类型作者有意的设计，强行实现可能会导致bug。</p><h4 id="trait和接口的区别">trait和接口的区别</h4><p>之前我们说trait和接口在功能上类似，但它们在使用中是有区别的。trait本身不是具体类型，也不是指针类型，它只是定义了针对类型的抽象的约束，不同的类型可以实现同一个trait，而这些类型可能具有不同的大小，因此trait在编译阶段没有固定大小，所以，Rust中不能直接使用trait作为实例变量、参数和返回值，这一点和接口的习惯用法是不同的。例如，下面的代码就是编译错误的：</p><pre class=" language-language-rust"><code class="language-language-rust">trait Shape {    fn area(&self) -> u32;}fn test(shape: Shape) {}// error[E0277]: the size for values of type `(dyn Shape + 'static)` cannot be known at compilation time</code></pre><h4 id="trait继承">trait继承</h4><p>trait允许继承，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">trait Base {}trait Derived: Base {}</code></pre><p>这表示<code>Derived</code>继承了<code>Base</code>，它意味着，满足<code>Derived</code>的类型，必然也满足<code>Base</code>，所以，在针对一个具体类型<code>impl Derived</code>的时候，编译器也会要求同时<code>impl Base</code>，否则会报编译错误：</p><pre class=" language-language-rust"><code class="language-language-rust">trait Base {}trait Derived: Base {}struct T;// error[E0277]: the trait bound `T: Base` is not satisfiedimpl Derived for T {}</code></pre><h3 id="常见trait简介">常见trait简介</h3><p>标准库中有很多常见且很有用的trait，我们一起学习一下。</p><h4 id="Display和Debug">Display和Debug</h4><p><code>Display</code>和<code>Debug</code>的定义如下：</p><pre class=" language-language-rust"><code class="language-language-rust">pub trait Display {    fn fmt(&self, f: &mut Formatter<'_>) -> Result;}pub trait Debug {    fn fmt(&self, f: &mut Formatter<'_>) -> Result;}</code></pre><p>这两个trait主要用在类似<code>println!</code>这样进行输出的地方。只有实现了<code>Display</code>的类型，才能用<code>&#123;&#125;</code>格式打印出来；只有实现了<code>Debug</code>的类型，才能用<code>&#123;:?&#125;</code>和<code>&#123;:#?&#125;</code>格式打印出来。它们之间的更多区别如下：</p><ul><li><code>Display</code>假定了这个类型可以用<code>utf-8</code>格式的字符串表示，它是准备给最终用户看的，并不是所有的类型都应该实现这个trait。标准库中还有一个常用的trait叫作<code>std::string::ToString</code>，对于所有实现<code>Display</code>的类型， 都自动实现了这个<code>ToString</code>trait，它包含了一个<code>to_string(&amp;self)-&gt;String</code>方法。</li><li><code>Debug</code>主要是为了调试使用，建议所有的作为API的公开类型都应当实现这个trait，以方便调试。</li></ul><h4 id="PartialOrd-Ord-PartialEq-Eq">PartialOrd/Ord/PartialEq/Eq</h4><p>我们首先介绍一下全序和偏序的概念。对于集合<code>X</code>中的元素<code>a,b,c</code>：</p><ul><li>如果<code>a &lt; b</code>则一定有<code>!(a &gt; b)</code>，称为反对称性；</li><li>如果<code>a &lt; b</code>且<code>b &lt; c</code>则一定有<code>a &lt; c</code>，称为传递性；</li><li>对于<code>X</code>中的所有元素，都存在<code>a &lt; b</code>或<code>a &gt; b</code>或者<code>a == b</code>，三者必居其一，称为完全性。</li></ul><p>如果集合中的元素只具备上述前两条特征，则称<code>X</code>是偏序；同时具备以上所有特征，则称<code>X</code>是全序。</p><p>Rust设计了两个trait来对全序和偏序进行描述，<code>PartialOrd</code>代表偏序，<code>Ord</code>代表全序。只有满足全序的类型才可以进行排序，像浮点数这样的偏序类型就无法排序。同理，<code>PartialEq</code>用来描述只能部分元素进行相等比较，<code>Eq</code>表示全部元素都可以进行相等比较。这样的设计可以让我们在更早的阶段发现错误。</p><h4 id="Sized">Sized</h4><p>这个trait表示类型是否有大小，它定义在<code>std::marker</code>模块中，它没有任何的成员方法，它与普通trait不同，编译器对它有特殊处理，用户也不能针对自己的类型实现这个trait。一个类型是否满足<code>Sized</code>约束完全是由编译器推导的，用户无权指定。</p><h4 id="Default">Default</h4><p>Rust中没有C++中构造函数的概念，因为相比普通函数，构造函数本身并没有提供额外的抽象能力，反倒增加了语法上的负担，因此，Rust推荐使用普通的静态函数作为类型的构造器，例如<code>String::new()</code>。对于那种无参数无错误处理的简单情况，标准库提供了<code>Default</code>来做统一抽象，其定义如下：</p><pre class=" language-language-rust"><code class="language-language-rust">pub trait Default: Sized {    fn default() -> Self;}</code></pre><h3 id="属性与derive">属性与derive</h3><p>Rust中有一种语法，属性（attribute），基本格式类似于<code>#[xxx]</code>。属性可以用来注释声明，类似于Java中的注解。有一种非常实用的属性<code>derive</code>，可以帮助我们自动<code>impl</code>某些trait，因为实现某些<code>trait</code>的时候，逻辑是非常机械化的，例如<code>Debug</code>。示例如下：</p><pre class=" language-language-rust"><code class="language-language-rust">#[derive(Debug)]struct Rectangle {    width: u32,    height: u32,}fn main() {    let rect = Rectangle {        width: 10,        height: 20,    };    // 输出：Rectangle { width: 10, height: 20 }    println!("{:?}", rect); }</code></pre><p>目前，Rust支持的可以自动<code>derive</code>的trait有以下这些：</p><pre class=" language-language-rust"><code class="language-language-rust">Debug Clone Copy Hash RustcEncodable RustcDecodable PartialEq Eq ParialOrd Ord Default FromPrimitive Send Sync</code></pre><h3 id="参考文献">参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#4：语句和表达式</title>
      <link href="posts/5c979c5.html"/>
      <url>posts/5c979c5.html</url>
      
        <content type="html"><![CDATA[<p>严格的说，Rust中的所有东西只分为两类：表达式（Expression）和语句（Statement）。</p><ul><li>表达式：在维基百科的<a href="https://en.wikipedia.org/wiki/Expression_(computer_science)">定义</a>中，表达式是指由变量、常量和操作符等组合成的可求值的语法实体。</li><li>语句：语句分为声明语句和表达式语句两种。声明语句用于声明变量、结构体、函数等各种项以及通过<code>use</code>等关键字引入包等。表达式语句，由一个表达式和一个分号组成，即在表达式后面加一个分号就将一个表达式转变为了一个语句。</li></ul><p>可见，表达式在Rust中扮演了至关重要的角色，Rust基本上就是一个表达式语言。在Rust程序中，表达式可以是语句的一部分，反过来，语句也可以是表达式的一部分。<strong>一个表达式总是会产生一个值，因此它必然有类型</strong>；语句不产生值，它的类型永远是<code>()</code>。如果把一个表达式加上分号，那么它就变成了一个语句；如果把语句放到一个语句块中包起来，那么它就可以被当成一个表达式使用。</p><h3 id="表达式的副作用">表达式的副作用</h3><p>从传统意义上讲，表达式的作用就是求值，它除了产生一个计算结果外，不应该改变参与计算过程的任何变量的值，这样的表达式称为无副作用的表达式。若一个表达式在求值过程中，改变了所使用的变量的值，则这样的表达式称为有副作用的表达式。例如：</p><pre class=" language-language-rust"><code class="language-language-rust">// 没有改变任何变量的值，其为无副作用的表达式5 + x // 改变了变量y的值，其为有副作用的表达式y = x + 1 </code></pre><p>表达式语句就是表达式副作用的重要应用。任何表达式加一个分号都可以作为一个语句来使用，但无副作用的表达式语句没有任何意义，例如<code>5+x;</code>这个表达式语句就没有意义。</p><p>Rust有很多种表达式类型，具体可参见《Rust Reference》，点击<a href="https://doc.rust-lang.org/reference/expressions.html">这里</a>。下面介绍几种常见的表达式。</p><h3 id="运算表达式">运算表达式</h3><p>运算表达式是含有运算符的表达式。运算符可分为以下几类：</p><ul><li>算术运算符：加（<code>+</code>），减（<code>-</code>），乘（<code>*</code>），除（<code>/</code>），求余（<code>%</code>）</li><li>比较运算符：等于（<code>==</code>），不等于（<code>!=</code>），小于（<code>&lt;</code>），大于（<code>&gt;</code>），小于等于（<code>&lt;=</code>），大于等于（<code>&gt;=</code>）。比较表达式的类型是<code>bool</code>。</li><li>逻辑运算符：逻辑与（<code>&amp;&amp;</code>），逻辑或（<code>||</code>），逻辑取反（<code>!</code>）</li><li>位运算符：按位取反（<code>!</code>），按位与（<code>&amp;</code>），按位或（<code>|</code>），按位异或（<code>^</code>），左移（<code>&lt;&lt;</code>），右移（<code>&gt;&gt;</code>）</li><li>复合运算符： <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>和 <code>&gt;&gt;</code>都可以和<code>=</code>组成复合运算符</li></ul><p>这些运算符的用法和C/C++中基本一致，需要注意的是以下两点：</p><ul><li>Rust禁止连续比较，例如<code>a == b == c</code>这是错误的，必须要加上括号才行。这样设计对减少歧义有很大好处。</li><li>按位取反和逻辑取反都是运算符<code>!</code>：如果被操作数是<code>bool</code>类型，则是逻辑取反，其他情况是按位取反。</li></ul><p>关于运算符之间优先级的细微知识这里就不展开讲了，因为不论在哪种编程语言中，我都建议，如果碰到复杂的表达式，要使用小括号来明确表达计算顺序。</p><h3 id="赋值表达式">赋值表达式</h3><p>一个左值表达式、赋值运算符（<code>=</code>）和右值表达式，可以构成一个赋值表达式。关于左值右值的知识可以参考《Rust学习笔记#2：变量声明、绑定与引用》。需要注意的是，赋值表达式的类型为<code>()</code>，这和C语言是不同的，C语言中赋值表达式的类型是左值表达式的类型。这样设计的好处有两点：</p><ul><li>防止连续赋值：<code>x = y = z</code>会产生编译错误，因为赋值运算符<code>=</code>要求两边的表达式同类型，而<code>y = z</code>是<code>()</code>类型所以会产生编译错误。</li><li>防止把<code>==</code>写成<code>=</code>：Rust中要求条件表达式的类型必须为<code>bool</code>，而赋值表达式的类型是<code>()</code>，会产生编译错误。</li></ul><h3 id="语句块表达式">语句块表达式</h3><p>语句块由<code>&#123;&#125;</code>构成，其类型是语句块中最后一个表达式的类型。也就是说，如果最后一个表达式带了分号，那么语句块的类型就是语句的类型<code>()</code>；如果没带，就是表达式的类型。例如：</p><pre class=" language-language-rust"><code class="language-language-rust">let x: () = {5;}; // x的类型为()let x: i32 = {5}; // x的类型为i32</code></pre><p>这样设计的好处是在写函数返回值时可以直接去掉最后一个语句的分号作为返回值，而不必写<code>return</code>。例如：</p><pre class=" language-language-rust"><code class="language-language-rust">fn fun() -> i32 {100}// 等价于fn fun() -> i32 {return 100;}</code></pre><h3 id="条件表达式">条件表达式</h3><p><code>if-else</code>表达式在C语言中也有，我们这里讲一些不一样的地方：</p><ul><li><p><code>if-else</code>后必须要有大括号，不得省略，这样可以避免悬空<code>else</code>所导致的bug。</p></li><li><p>条件表达式不需要用小括号括起来，如果加上小括号，编译器会提示这是一个多余的小括号。</p></li><li><p><code>if-else</code>表达式的所有分支必须返回同一个类型的值，<code>if-else</code>的求值策略和语句块表达式相同。如果<code>else</code>分支省略，则默认<code>else</code>分支的类型为<code>()</code>。见下面的例子：</p><pre class=" language-language-rust"><code class="language-language-rust">let a = 1;let b = if a > 10 {a * 2} else {a * 3};println!("{}", b); // 输出：3</code></pre></li></ul><h3 id="循环表达式">循环表达式</h3><p>Rust中包括三种循环表达式：<code>while</code>、<code>loop</code>和<code>for...in</code>，其用法和其他编程语言相应的表达式基本类似，也可以使用<code>continue</code>和<code>break</code>控制循环流程。注意，Rust中没有C语言中那种三段式<code>for</code>循环，这里的<code>for...in</code>本质上就是一个迭代器。</p><p><code>loop</code>表示一个无限死循环，<code>while</code>是带条件判断的循环语句。注意，<code>loop</code>和<code>while true</code>是不同的。相对于其他语言，Rust要做更多的静态分析，Rust认为<code>while</code>循环的条件可真可假，所以循环体里的表达式也会忽略不会进行分析，看下面的示例：</p><pre class=" language-language-rust"><code class="language-language-rust">let x;while true {    x = 1;    break;}println!("{}", x); // error[E0381]: borrow of possibly-uninitialized variable: `x`</code></pre><p>Rust无法得知变量<code>x</code>的值在<code>while</code>循环块里被初始化过，从而会报使用未初始化变量的错。</p><h3 id="match表达式">match表达式</h3><p>Rust提供了<code>match</code>表达式用于匹配各种情况，有点类似于C语言中的<code>switch...case</code>语句，但功能更加强大。先看一个简单的<code>match</code>示例：</p><pre class=" language-language-rust"><code class="language-language-rust">enum Direction {    East,    West,    South,    North,}let x = Direction::East;match x {    Direction::East => println!("East"),    Direction::West => println!("West"),    Direction::South => println!("South"),    Direction::North => println!("North"),}// 输出：East</code></pre><p>上面的用法和<code>switch...case</code>语句很类似，下面讲讲不一样的地方：</p><ul><li><p>exhaustive特性：exhaustive的意思是无遗漏的，也就是说，Rust要求<code>match</code>必须对所有的情况做完整的、无遗漏的匹配，如果漏掉了某些情况，是不能通过编译的。这样做的好处是可以强迫程序员对所有的情况进行考虑，从而减少bug的发生。</p><pre class=" language-language-rust"><code class="language-language-rust">// 同上面的代码match x {     Direction::East => println!("East"),    Direction::West => println!("West"),    Direction::South => println!("South"),}// error[E0004]: non-exhaustive patterns: `North` not covered</code></pre></li><li><p>下划线：当不想把每种情况一一列出时，可以用一个下划线来表达“除了列出来的那些之外的其他情况”。下划线存在的另外一个意义是，如果我们引用了他人的库中的某个<code>enum</code>类，但该类添加了新成员，这就会导致我们的代码编译失败。因此，不论何时，都推荐使用下划线作为容错措施。</p><pre class=" language-language-rust"><code class="language-language-rust">// 同上面的代码match x {    Direction::East => println!("East"),    _ => println!("Else"),}// 输出：East</code></pre></li><li><p>match可以作为表达式，但要求其每一个分支都返回相同的类型。</p><pre class=" language-language-rust"><code class="language-language-rust">let x = Direction::East;let y = match x {    Direction::East => 1,    _ => 0,};println!("{}", y); // 输出：1</code></pre></li><li><p>可以使用范围作为匹配条件：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 'X';match x {    'a'..='z' => println!("lowercase"),    'A'..='Z' => println!("uppercase"),    _ => println!("something else"),}// 输出：uppercase</code></pre></li><li><p>可以使用<code>if</code>作为匹配条件，当匹配成功且符合<code>if</code>条件时，才执行后面的语句：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = Some(5);match x {    Some(i) if i > 10 => println!("{}", i),    _ => println!("Nothing!"),}// 输出：Nothing!</code></pre></li></ul><p>另外，Rust提供了<code>if let</code>语法糖来简化某些情况下的<code>match</code>表达式。如果我们有一个<code>Option&lt;T&gt;</code>类型的变量<code>opt_val</code>，如果我们需要取出里面的值，可以这样做：</p><pre class=" language-language-rust"><code class="language-language-rust">match opt_val {    Some(x) => {        // handle x    },    _ => (),}</code></pre><p>但这样写比较冗长，而使用<code>if let</code>语法，可以这样做：</p><pre class=" language-language-rust"><code class="language-language-rust">if let Some(x) = opt_val {    // handle x}</code></pre><p><code>if let</code>的语法为：<code>if let PATTERN = EXPRESSION &#123;BODY&#125;</code>，它和<code>match</code>的区别是：它不需要完整匹配，只匹配感兴趣的某个特定分支即可。</p><h3 id="参考文献">参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#3：类型</title>
      <link href="posts/879d15dc.html"/>
      <url>posts/879d15dc.html</url>
      
        <content type="html"><![CDATA[<p>类型于20世纪50年代被FORTRAN语言引入，发展到今日，类型已经成为了各大编程语言的核心基础，Rust也不例外。所谓类型，就是对表示信息的值进行的细粒度的区分，比如整数、小数、文本等。不同的类型占用的内存不同，与直接操作比特位相比，直接操作类型可以更安全更有效地利用内存 。</p><p>Rust是一个<strong>强显式静态类型</strong>的语言。下面解释一下何为“强显式静态类型”：</p><ul><li>在编译期进行类型检查的语言属于静态类型，在运行期进行类型检查的语言属于动态类型。</li><li>不允许类型的自动隐式转换的语言属于强类型，反之则是弱类型。</li><li>在静态类型语言中，依靠编译器自动推导类型而不需要显式指定类型的语言属于显式静态类型，反之则是隐式。Rust的编译器具有自动推导类型的能力，但还不够强大，在很多地方仍需要显式指定类型，类型仍然是Rust语法的一部分。</li></ul><p>Rust中一切皆表达式，表达式皆有值，值皆有类型，因此，Rust中一切皆类型。Rust中包含基本的原生类型和复合类型，也包含线程崩溃等无返回值的never类型。Rust类型系统吸收百家之长，基本囊括了编程中会遇到的各种情况，一般不会有未定义的行为出现，所以说，Rust是类型安全的语言。</p><h3 id="基本数据类型">基本数据类型</h3><h4 id="布尔类型">布尔类型</h4><p>Rust内置了布尔类型，类型名为<code>bool</code>，它有两个值：<code>true</code>和<code>false</code>。示例如下：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = true; // 不显示声明类型，自动推断x为bool类型let y: bool = !x; // 取反运算println!("{}", y);let z = x && y; // 逻辑与，带短路功能println!("{}", z);let z = x || y; // 逻辑或，带短路功能println!("{}", z);let z = x & y; // 按位与println!("{}", z);let z = x | y; // 按位或println!("{}", z);let z = x ^ y; // 按位异或println!("{}", z);</code></pre><p>使用布尔值的主要场景是条件表达式，但注意，Rust并不支持将数字转换为<code>bool</code>类型。</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 1;if x {} // error[E0308]: mismatched types, expected `bool`, found integer</code></pre><h4 id="字符类型">字符类型</h4><p>字符类型由<code>char</code>表示，用单引号定义，代表一个unicode标量值。由于<code>char</code>类型的设计目的是描述任意一个unicode字符，所以它占据的空间不是1个字节，而是4个字节。</p><pre class=" language-language-rust"><code class="language-language-rust">let a = 'a';println!("{}", a);let heart_eyed_cat = '😻';println!("{}", heart_eyed_cat);</code></pre><h4 id="整数类型">整数类型</h4><p>Rust中，各种整数类型之间的主要区分特征是：有符号/无符号，占据空间大小。</p><table><thead><tr><th style="text-align:center">长度</th><th style="text-align:center">有符号</th><th style="text-align:center">无符号</th></tr></thead><tbody><tr><td style="text-align:center">8-bit</td><td style="text-align:center"><code>i8</code></td><td style="text-align:center"><code>u8</code></td></tr><tr><td style="text-align:center">16-bit</td><td style="text-align:center"><code>i16</code></td><td style="text-align:center"><code>u16</code></td></tr><tr><td style="text-align:center">32-bit</td><td style="text-align:center"><code>i32</code></td><td style="text-align:center"><code>u32</code></td></tr><tr><td style="text-align:center">64-bit</td><td style="text-align:center"><code>i64</code></td><td style="text-align:center"><code>u64</code></td></tr><tr><td style="text-align:center">128-bit</td><td style="text-align:center"><code>i128</code></td><td style="text-align:center"><code>u128</code></td></tr><tr><td style="text-align:center">arch</td><td style="text-align:center"><code>isize</code></td><td style="text-align:center"><code>usize</code></td></tr></tbody></table><p>有无符号代表数字能否为负值：</p><ul><li>有符号：每一个有符号的类型的表达范围为 [$-2^{n-1}$,  $2^{n-1} - 1$]，其中n为类型的长度。</li><li>无符号：每一个无符号的类型的表达范围为 [0,  $2^n - 1$]，其中n为类型的长度。</li></ul><p>另外，<code>isize</code>和<code>usize</code>依赖于运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。其他一些琐碎的知识点一并体现在下面的代码注释中：</p><pre class=" language-language-rust"><code class="language-language-rust">// 若编译器无法推断变量的具体类型，则自动默认为i32类型let var = 32;// 以0x开头代表十六进制表示let var = 0xFF;// 以0o开头代表八进制表示let var = 0o55;// 以0b开头代表二进制表示let var = 0b1001;// 可在数字字面量中任意地方添加下划线，以方便阅读let var = 0x_1234_ABCD;// 字面量后面可以添加后缀，以标明具体类型let var = 32u8;</code></pre><p>Rust的数字表达策略和C语言不同，C语言标准中对许多类型的大小并没有做强制规定，比如<code>int</code>类型在不同平台上可能是不同的大小，这给程序员带来了许多不必要的麻烦。相反，Rust在语言标准中规定好各个类型的大小，让编译器针对不同平台做适配，生成不同的代码，是更合理的选择。</p><p>整数运算中有一个让人头疼的问题是“溢出”。在C语言中，对于无符号类型，如果超过表示范围，则自动舍弃高位数据；对于有符号类型，如果超过表示范围，C标准规定这是未定义行为，这就是说编译器随便怎么处理都可以。未定义行为有利于编译器做一些更激进的性能优化，但这容易在极端场景下产生诡异的bug。</p><p>Rust的设计思路更倾向于预防bug，而不是无条件地压榨效率，Rust设计者希望尽可能减少整数溢出这种未定义行为。Rust的处理方式如下：</p><ul><li>debug模式：编译器会自动插入整数溢出检查，一旦发生溢出，则会引发panic（一种崩溃机制，暂且不表）;</li><li>release模式：不检查整数溢出，而是采用自动舍弃高位的方式。</li></ul><h4 id="浮点类型">浮点类型</h4><p>Rust提供了基于IEEE 754标准的浮点类型，按占据空间大小区分，分别为<code>f32</code>和<code>f64</code>，其使用方法与整型差别不大。如果不加后缀或没有指定类型，Rust会默认推断浮点数为<code>f64</code>类型，因为在现代CPU中，它与<code>f32</code>速度几乎一样，且精度还更高。</p><ul><li><code>f32</code>：数值范围为[$-3.4\times 10^{38}$, $3.4\times 10^{38}$]​</li><li><code>f64</code>：数值范围为[$-1.8\times 10^{308}$, $1.8\times 10^{308}$]</li></ul><p>浮点类型相对于整数类型的麻烦之处在于：它不仅可以表达正常的数值，还可以表达不正常的数值。参见下面的代码：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 1.0 / 0.0;let y = 0.0 / 0.0;println!("x is {}, y is {}", x, y);</code></pre><p>上面代码的输出结果为<code>x is inf, y is NaN</code>，<code>inf</code>代表无穷大（infinite），<code>NaN</code>代表不是数字（Not a Number）。在标准库中，有一个<code>std::num::FpCategory</code>枚举类，表示了浮点数可能的状态：</p><pre class=" language-language-rust"><code class="language-language-rust">enum FpCategory {    // "Not a Number", often obtained by dividing by zero.    Nan,    // Positive or negative infinity.    Infinite,    // Positive or negative zero.    Zero,    // De-normalized floating point representation (less precise than `Normal`).    Subnormal,    // A regular floating point number.    Normal,}</code></pre><h4 id="原生指针">原生指针</h4><p>我们一般将表示内存地址的类型称为指针。例如之前学习过的引用，它本质上就是一种非空指针，编译器会对引用进行借用检查，以保证内存安全和类型安全。原生指针主要用于<code>unsafe</code>代码块中，直接使用原生指针是不安全的，因为其可能为null，所以需要程序员自己保证安全。<code>unsafe</code>距离我们还很遥远，所以原生指针相关的只是暂且不表。</p><h4 id="数组类型">数组类型</h4><p>数组是Rust内建的原始集合类型 ，数组的类型签名是<code>[T:N]</code>，其中T代表数组中元素的类型，N代表数组的长度，N为编译期常量，必须在编译时确定其值。对于两个数组类型，只有元素类型和元素个数都完全相同，这两个数组才是同类型的，才可以互相赋值。数组的特点为：</p><ul><li>数组大小固定</li><li>元素均为同类型</li><li>默认不可变</li></ul><p>Rust 中，数组中的值位于中括号内的逗号分隔的列表中。下面代码中定义了类型为<code>[i32; 3]</code>的数组，该数组是固定长度的，不允许对其添加或删除元素。即使通过<code>let mut</code>关键字定义，也只能修改已存在于索引位上的元素。</p><pre class=" language-language-rust"><code class="language-language-rust">let mut arr: [i32; 3] = [1, 2, 3];println!("{:?}", arr); // 输出[1, 2, 3]arr[0] = 4;println!("{:?}", arr); // 输出[4, 2, 3]</code></pre><p>如果希望创建一个每个元素都相同的数组，可以在中括号内指定其初始值，后跟分号，再后跟数组的长度，如下所示：</p><pre class=" language-language-rust"><code class="language-language-rust">let arr = [3; 5];println!("{:?}", arr); // 输出[3, 3, 3, 3, 3]</code></pre><p>Rust会在编译期尽可能地检查数组索引是否小于数组的长度，如果发现问题，会报编译错误：</p><pre class=" language-language-rust"><code class="language-language-rust">let arr = [3; 5];println!("{}", arr[5]); // error: index out of bounds</code></pre><p>但静态分析的能力有限，数组越界错误不能够全部在编译期查出来，Rust会在运行时继续检查索引是否小于数组的长度，如果超出，则会panic。</p><p>一般情况下，<strong>Rust不鼓励大量使用索引操作</strong>，因为索引操作都会执行一次边界检查，所以其效率会比不执行边界检查的C/C++略低，更推荐的做法是使用迭代器。</p><h4 id="范围类型">范围类型</h4><p>Rust内置了范围（Range）类型，包括左闭右开和全闭两种区间，语法为<code>begin..end</code>。<code>1..5</code>表示左闭右开区间，它是<code>std::ops::Range</code>的实例；<code>1..=5</code>表示全闭区间，它是<code>std::ops::RangeInclusive</code>的实例。每个<code>Range</code>都是一个迭代器，可以直接使用<code>for</code>循环进行打印：</p><pre class=" language-language-rust"><code class="language-language-rust">for x in 1..5 {println!("{}", x);}</code></pre><h4 id="切片类型">切片类型</h4><p>切片类型（Slice）是对一个数组的引用片段，切片代表一个指向数组起始位置的指针和数组长度。切片有利于安全有效地访问数组的一部分，因为切片引用的是已经存在的变量。使用引用操作符<code>&amp;</code>对数组进行引用，就产生了一个切片，也可以结合范围类型对数组进行切割：</p><pre class=" language-language-rust"><code class="language-language-rust">let arr = [1, 2, 3, 4, 5];let slice = &arr;println!("{:?}", slice); // 输出：[1, 2, 3, 4, 5]let slice = &arr[2..4];println!("{:?}", slice); // 输出：[3, 4]</code></pre><p>对于数组<code>[T;N]</code>，其借用指针的类型是<code>&amp;[T;N]</code>，但其切片的类型是<code>&amp;[T]</code>。<code>&amp;[T;N]</code>占用的空间大小和普通引用相同，而<code>&amp;[T]</code>占用的空间大小是普通引用的两倍：</p><pre class=" language-language-rust"><code class="language-language-rust">println!("&i32 size is {}", std::mem::size_of::<&i32>()); // 输出：&i32 size is 8println!("&[i32; 3] size is {}", std::mem::size_of::<&[i32; 3]>()); // 输出：&[i32; 3] size is 8println!("&[i32] size is {}", std::mem::size_of::<&[i32]>()); // 输出：&[i32] size is 16</code></pre><p>可以看到，数组切片的大小的确是普通引用的两倍，因为数组切片不止包含一个指向数组的指针，切片本身还含带长度信息。因此，切片还有一个非常形象的名字：胖指针（fat pointer）。胖指针的设计，避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题，保证了类型安全。</p><h4 id="字符串类型">字符串类型</h4><p>出于内存安全的考虑，Rust提供了两种字符串类型：一种是固定长度字符串，不可以随便更改其长度，就是<code>str</code>字符串；另一种是可增长字符串，可以随便改变其长度，就是<code>String</code>字符串。</p><p>说到<code>str</code>，就不得不提到一个概念，动态大小类型（Dynamic Sized Type，DST），是指在编译阶段无法确定占用空间大小的类型。为了安全，指向DST的指针一般是胖指针。<code>str</code>就是DST类型，我们不能在栈上声明一个不定长大小的变量示例，也不能用它作为函数的参数和返回值。但是，<code>&amp;str</code>的大小是确定的，因此，<code>&amp;str</code>类型可以用作变量实例、函数参数和返回值。<code>&amp;str</code>又被称作字符串切片类型，平时对字符串常量的绑定也是获得的其切片：</p><pre class=" language-language-rust"><code class="language-language-rust">let name: &str = "jack";println!("{}", name); // 输出：jack</code></pre><p>Rust的字符串内部默认使用<code>utf-8</code>编码格式，而内置的<code>char</code>类型是4字节的unicode，所以Rust里面的字符串不能视为<code>char</code>类型的数组，而更接近<code>u8</code>类型的数组。这样设计的缺点是不能支持<code>O(1)</code>复杂度的索引操作，它的复杂度是<code>O(n)</code>，因为<code>utf-8</code>是变长编码，如果不从头开始过一遍，根本不知道第n个字符的地址在什么地方。</p><h4 id="never类型">never类型</h4><p>Rust提供了一种特殊数据类型，never类型，用<code>!</code>表示，代表永远不可能有返回值的计算类型，比如线程退出的时候，就不可能有返回值。Rust是一个类型安全的语言，所以也需要将这种情况纳入类型系统中进行统一管理。见下面的代码：</p><pre class=" language-language-rust"><code class="language-language-rust">let num = Some(42);let num = match num {Some(num) => num,None => panic!("Nothing!"),};println!("{}", num); // 输出：42</code></pre><p>上面的代码中使用了一种当下还没学到的语法，不过不必在意，只需知道<code>match</code>表达式要求所有的分支都必须返回相同的类型，而<code>num</code>是<code>i32</code>类型，<code>panic!</code>宏会返回<code>!</code>类型，但这里没有报错，是因为never类型是可以强制转换为其他任何类型的。</p><h3 id="类型转换">类型转换</h3><p>为了防止隐藏的bug，Rust希望类型转换时要显式地标记出来，类型转换使用关键字<code>as</code>。</p><pre class=" language-language-rust"><code class="language-language-rust">let a: i8 = 10;let b: i16 = a; // error[E0308]: mismatched typeslet b: i16 = a as i16; // 正确写法</code></pre><p>注意，<code>as</code>关键字也不是随便可以用的，它只允许编译器认为合理的类型转换。对于表达式<code>e as U</code>，下图中是所允许的类型转换。</p><p><img src="../images/10.png" alt=""></p><h3 id="复合数据类型">复合数据类型</h3><p>Rust提供了3种常用的复合数据类型，且都是异构数据类型，即可以使用它们将多种类型构建为统一的数据类型：</p><ul><li>元组（Tuple）</li><li>结构体（Struct）</li><li>枚举体（Enum）</li></ul><h4 id="tuple">tuple</h4><p><code>tuple</code>指的是“元组”类型，它通过圆括号包含一组表达式构成，<code>tuple</code>内的元素没有名字，<code>tuple</code>是把几个类型组合到一起的最简单的方式。访问<code>tuple</code>内部元素可以通过模式匹配或者数字索引。示例如下：</p><pre class=" language-language-rust"><code class="language-language-rust">let p = (10, false);let q = (0,); // 只有一个元素的元组要加一个逗号以区分表达式和元组let (a, b) = p; // 模式匹配访问元组元素println!("{}, {}", a, b);println!("{}, {}", p.0, p.1); // 数字索引访问元组元素</code></pre><p>元组内部也可以一个元素都没有，称为<code>unit</code>，占用0内存空间。</p><pre class=" language-language-rust"><code class="language-language-rust">println!("{}", std::mem::size_of::<()>()); // 输出：0</code></pre><h4 id="struct">struct</h4><p><code>struct</code>和<code>tuple</code>的区别是它的每个元素都有自己的名字，每个元素之间采用逗号分开，类型依旧跟在冒号后面，但必须显示指定不能省略：</p><pre class=" language-language-rust"><code class="language-language-rust">struct Point {    x: i32,    y: i32}</code></pre><p><code>struct</code>类型的初始化使用<code>成员-冒号-值</code>的方式，如果有局部变量名字恰好和成员名字一致，则可以省略成员名字：</p><pre class=" language-language-rust"><code class="language-language-rust">let p = Point{x: 0, y: 0};let x = 10;let y = 10;let p = Point{x, y};</code></pre><p>访问结构体内部的元素使用“点”加变量名的方式，也可以使用模式匹配。</p><h4 id="tuple-struct">tuple struct</h4><p><code>tuple</code>本身和其元素都没有名字，<code>struct</code>本身和其元素都有名字，<code>tuple struct</code>本身有名字，但其元素没有名字：</p><pre class=" language-language-rust"><code class="language-language-rust">struct Color(i32, i32, i32);</code></pre><p><code>tuple struct</code>有一个特殊的用法，即当它只包含一个元素的时候，就是所谓的<code>newtype idiom</code>，可以让我们很方便地在一个类型的基础上创建一个新的类型。</p><h4 id="enum">enum</h4><p>与C/C++中的枚举相比，Rust中的<code>enum</code>要强大得多，它可以为每个成员指定附属的类型信息。例如：</p><pre class=" language-language-rust"><code class="language-language-rust">enum Number {Int(i32),Float(f32),}</code></pre><p><code>enum</code>中每个元素可以像空结构体一样，不指定它的类型；也可以像<code>tuple struct</code>一样，用圆括号加无名成员；还可以像正常结构体一样，用大括号加带名字的成员。</p><p>Rust标准库中有一个极其常用的<code>enum</code>类型<code>Option&lt;T&gt;</code>，它的定义如下：</p><pre class=" language-language-rust"><code class="language-language-rust">enum Option<T> {None,Some(T),}</code></pre><p>其中T代表的是类型，这是一种泛型的写法。<code>Option&lt;T&gt;</code>的含义是“要么存在，要么不存在”，可以有效提升程序的健壮性。</p><h3 id="参考文献">参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#2：变量声明、绑定与引用</title>
      <link href="posts/f80c8a5a.html"/>
      <url>posts/f80c8a5a.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量声明">变量声明</h3><h4 id="基础知识">基础知识</h4><p>Rust中的变量分局部变量和全局变量两种，且必须先声明后使用，常见的声明语法为：</p><pre class=" language-language-rust"><code class="language-language-rust">// 声明局部变量，使用let关键字let var: i32 = 100;// 声明全局变量，使用static关键字static GLOBAL: i32 = 0; </code></pre><p>由于Rust非常注重内存安全，因此全局变量的使用有许多限制，我们日常使用最多的还是局部变量。与传统的C/C++语言相比，Rust的变量声明语法不同，这样设计主要有下列三种优点：</p><ul><li>语法分析更容易：Rust的局部变量声明一定是以关键字<code>let</code>开头，类型一定跟在<code>:</code>后面，语法歧义更少，语法分析器更容易编写。</li><li>类型推导更方便：Rust的变量声明的一个重要特点是，要声明的变量前置，对它的类型描述后置。这是吸取了其他语言的教训后的结果，因为在变量声明语句中，最重要的是变量本身，类型只是附属的额外描述，并非必不可少的部分，类型可以由编译器自动推导获得，因此类型后置的语法更合适。</li><li>支持模式解构：<code>let</code>不仅能声明局部变量，还具有模式结构（pattern destructure）的功能，这里暂且不表。</li></ul><p>Rust中变量声明默认是“只读”的，如果需要让变量可写，则需要使用<code>mut</code>关键字，<code>mut</code>是<code>mutable</code>的简写：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 5;x = 10; // x为只读变量，因此会报编译错误let mut y = 5; // 使用mut关键字声明一个可写变量y = 10;</code></pre><p>Rust中变量必须被初始化后才可以使用，否则会报编译错误。因此，不被初始化的变量是没有默认值的。变量既可以在声明时初始化，也可以在使用前初始化：</p><pre class=" language-language-rust"><code class="language-language-rust">let x: i32; // 声明变量xx = 1; // 初始化变量x，不需要x是mut，因为这是初始化不是修改println!("{}", x);</code></pre><p>不过，为了减少代码阅读的负担，笔者还是建议在变量声明时就初始化。</p><p>Rust中的合法标识符（包括变量名、函数名等）必须由数字、字母、下划线组成，且不能以数字开头。注意，单独的下划线是一个特殊的标识符，在编译器内部是被特殊处理的，不能作为普通变量使用，其具体用法这里暂且不表。Rust中关于变量的命名规范是蛇形命名法，使用下划线，一般用小写，即<code>file_name</code>。</p><h4 id="变量遮蔽">变量遮蔽</h4><p>Rust中允许在同一个代码块中声明同样名字的变量，如果这样做，后面声明的变量会将前面声明的变量遮蔽（Shadowing）起来，从而前面的变量将无法访问。例如：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = "hello";println!("x is {}", x);let x = 5;println!("x is {}", x);</code></pre><p>上面这种形式的代码在很多编程语言中是无法编译通过的，因为变量x被重复声明，但在Rust中是可以编译通过的：前后两个<code>x</code>是完全不同的两个变量，内存空间不同，类型也不同，只是恰巧名字相同。</p><p>Rust这种设计有时非常实用，例如，我们需要在同一个函数内部把一个变量转换为另一个类型的变量，但又不想给它们起不同的名字。但是，我个人认为变量遮蔽可能会带来阅读代码时的歧义，不建议滥用，建议有限使用，例如函数参数是字符串类型的<code>file_path</code>，这是使用变量遮蔽将其转换为Path类型的<code>file_path</code>就比较合适。但以我现在的水平尚不能仔细分析变量遮蔽这一特性的利弊权衡，或许未来能够在RFC中找到答案。</p><h4 id="类型推导">类型推导</h4><p>Rust编译器的类型推导功能很强大，不仅可以从变量声明的当前语句中获取信息进行推导，而且还能通过上下文信息进行推导。类型推导和“动态类型”是两码事，Rust仍然是静态类型的，所有变量的类型都必须在编译阶段确定，类型推导只是辅助我们在某些情况下不需要显示写出类型而已。</p><h4 id="类型别名">类型别名</h4><p>可以使用<code>type</code>关键字给同一个类型起个别名，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">type Age = u32; // u32代表无符号的32位整数类型let x: Age = 20;println!("x is {}", x);</code></pre><h4 id="静态变量">静态变量</h4><p>可以用<code>static</code>关键字声明静态变量，这也是Rust中唯一的声明全局变量的方法：</p><pre class=" language-language-rust"><code class="language-language-rust">static GLOBAL: i32 = 0;</code></pre><p>为了保证内存安全，全局变量的使用有很多限制：</p><ul><li>必须在声明时立即初始化</li><li>初始化必须是编译期可确定的常量</li><li>带有<code>mut</code>修饰的全局变量，在使用的时候必须使用<code>unsafe</code>关键字。</li></ul><p><code>unsafe</code>关键字用于逃过Rust编译器的检查以写一些可能存在危险的代码，当下无须深入研究。从上面第三条限制可以看出，Rust并不鼓励我们使用可变的全局变量，更希望我们把全局变量用成全局常量。注意，全局变量的声明周期是整个程序从启动到退出。</p><h4 id="常量">常量</h4><p>可以使用<code>const</code>关键字声明一个常量：</p><pre class=" language-language-rust"><code class="language-language-rust">const GLOBAL: i32 = 0;</code></pre><p>常量和静态变量最大的区别在于：编译器不一定会给常量分配内存空间，可能会在编译过程中将常量內联优化。</p><h3 id="变量绑定">变量绑定</h3><p>通过<code>let</code>关键字来创建变量，这是Rust语言从函数式语言中借鉴的语法形式。<code>let</code>创建的变量一般称为绑定（binding），而不是我们通常说的赋值，因为它表达的是位置表达式和值表达式之间建立的一种关联关系。</p><p>Rust中的表达式可以分为位置表达式和值表达式，在其他语言中，一般称为左值和右值。</p><ul><li>位置表达式：表示内存位置的表达式，有本地变量、静态变量、解引用、数组索引和字段引用五种。通过位置表达式可以对某个数据单元的内存进行读写。</li><li>值表达式：只引用了某个存储单元地址中的数据，相当于数据值，只能进行读操作。值表达式要么是字面量，要么是表达式求值过程中创建的临时值。</li></ul><p>表达式的求值过程在不同的上下文中会有不同的结果，求值上下文也分位置上下文和值上下文。下面几种表达式属于位置上下文（不必看懂，了解就好）：</p><ul><li>赋值或者复合赋值语句左侧的操作数</li><li>一元引用表达式的独立操作数</li><li>包含隐式借用的操作数</li><li>match判别式或let绑定右侧在使用ref模式匹配的时候也是位置上下文</li></ul><p>除了上述几种情况，其余表达式都属于值上下文。一般情况下，值表达式出现在值上下文中，位置表达式出现在位置上下文中，但也存在特殊情况：</p><ul><li>值表达式不能出现在位置上下文中，否则会报错：</li></ul><pre class=" language-language-rust"><code class="language-language-rust">// error[E0070]: invalid left-hand side of assignment"hello" = 1;</code></pre><ul><li>当位置表达式出现在值上下文中时，该位置表达式会把<strong>所有权</strong>转移给另外一个位置表达式。</li></ul><h3 id="变量引用">变量引用</h3><p>我们刚刚看到了一个新名词，“所有权（ownership）”，所有权代表着以下意义：</p><ul><li>每个值在Rust中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者。</li><li>每个值在一个时间点上只有一个管理者。</li><li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li></ul><p>当位置表达式出现在值上下文中时，这种所有权转移在Rust中称为移动语义。但在日常开发中，有时候并不需要转移所有权，Rust提供了引用操作符<code>&amp;</code>，可以直接获得位置表达式的内存地址，并通过该地址进行读写操作，解引用使用<code>*</code>操作符。下面看一个引用和解引用的示例：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 32;let y = &x;assert_eq!(32, *y);</code></pre><p>在上面的代码中，32这个值的所有权归变量x所有，变量y中存储的是其地址，最后通过解引用操作符<code>*</code>将引用y中的值取出来，以供<code>assert_eq!</code>宏使用，因为变量x仍旧保留它们的所有权，所以引用也被称为借用。</p><p>生命周期是Rust的核心概念，而所有权、借用等概念又和生命周期息息相关，但目前先不必去深入了解它，待把基础语法掌握后，再去学习Rust的精髓，方能事半功倍。</p><h3 id="参考文献">参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#1：一个猜谜游戏小项目</title>
      <link href="posts/8ab0a41e.html"/>
      <url>posts/8ab0a41e.html</url>
      
        <content type="html"><![CDATA[<p>在深入探索Rust语法的细枝末节之前，先通过一个麻雀虽小但五脏俱全的小项目来整体把握Rust，这样可以避免迷失在细节的海洋中。我们可能会通过这个小项目一下子接触到很多新概念，但不必惊慌，我们只需浅尝辄止对这些概念有个印象即可。</p><p>《TRPL》（Rustaceans对《The Rust Programming Language》的爱称）中就给出了一个经典的猜谜游戏的例子，我们一起来学习它。</p><blockquote><p>猜谜游戏：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜错了，会请玩家继续猜测；如果猜对了，它会打印祝贺信息并退出。</p></blockquote><h3 id="Rust如何管理项目">Rust如何管理项目</h3><p>并不是所有的代码都像<code>hello_world.rs</code>一样，一个文件就可以搞定。一个项目往往具有复杂的代码，我们需要一种机制来管理这种复杂性，将一个项目切分成若干小部分，每个部分再进行切分，层层抽象，直到达到人脑可以处理的规模。每种编程语言都有这样的机制，例如Java的package机制，Rust也不例外。</p><p>Rust用了两个概念来管理项目：一个是crate（项目），一个是mod（模块）。模块（mod）是用于在项目（crate）内部进行分层和封装的机制，模块内部可以包含模块。</p><ul><li>crate：可以简单理解为一个项目，crate是Rust中的独立编译单元（compile unit），每个crate对应生成一个库或者可执行文件。作为对比，我们比较熟悉的C语言中，一个单独的.c文件和其所有的include文件组成一个编译单元，每个.c生成一个.o，然后将这些.o链接起来生成可执行文件。</li><li>mod：可以简单理解为命名空间。mod可以嵌套（注意crate之间不能出现循环引用），还可以控制内部元素的可见性。</li></ul><p>说到可见性问题，在Rust中，元素默认都是私有的，用<code>pub</code>关键字修饰的元素才是公开的。公开和私有的访问权限规定如下：</p><ul><li>如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问</li><li>如果一个元素是公开的，那么可以在本模块外的作用域访问它。</li></ul><p>模块是一种抽象的概念，文件是承载这个概念的实体，但是模块和文件并不是简单的一一对应关系。在一个crate内部创建mod的方式有下面三种：</p><ul><li>在一个rs文件中创建内嵌模块，直接使用<code>mod</code>关键字即可。</li><li>独立的一个rs文件就是一个模块，文件名即是模块名。</li><li>一个文件夹也可以视为一个模块，文件夹内部要有一个<code>mod.rs</code>文件，这个文件是这个模块的入口。注意必须要在这个<code>mod.rs</code>中声明其子模块，否则子模块无法被当成这个项目的源码进行编译；另外，也需要在该文件夹所在的mod的入口文件中声明该文件夹。</li></ul><h3 id="新建项目">新建项目</h3><p>cargo不仅是Rust的包管理器，还可以用于创建项目。使用下列命令可以创建一个名为<code>guessing_game</code>的项目：</p><pre class=" language-language-bash"><code class="language-language-bash">cargo new guessing_game --bin</code></pre><p>注意，后面的<code>--bin</code>意味着我们希望项目生成的是可执行程序，如果希望是library，则可以使用<code>--lib</code>选项。</p><p>以上为在命令行中手工创建项目，在Clion中可以点击<code>File-&gt;New Project</code>后如下图填写，然后点击<code>Create</code>按钮：</p><p><img src="../images/4.png" alt=""></p><h3 id="项目结构">项目结构</h3><p>我们可以使用<code>tree</code>命令或者直接在Clion中查看当前的文件夹结构，如下图所示：</p><p><img src="../images/5.png" alt=""></p><ul><li>src/main.rs：这是cargo自动生成的rs文件。还记得前面讲的crate和mod的概念吗？在这个项目中，<code>guessing_game</code>是crate，<code>src</code>文件夹是mod，<code>main.rs</code>是<code>src</code>mod的入口（相应的，<code>lib.rs</code>是library类型crate的入口）。我们可以在<code>src</code>mod中创建子模块，但注意，这些子模块都要在<code>main.rs</code>中声明，否则无法参与编译。</li><li>.gitignore：这是git忽略文件，不懂其作用的同学可以自行搜索。这里重点要说的是通过<code>cargo new</code>创建的项目天然就是一个git项目，这也印证了Rust对开源的拥护。</li><li>Cargo.toml：这是项目管理配置文件。TOML是一种非常简洁好用的配置文件格式，TOML是<code>Tom's Obvious, Minimal Language</code>的首字母缩写，这里的Tom是Github的联合创始人之一，感兴趣的同学可以进一步自行了解TOML配置文件的写法。</li><li>Cargo.lock：该文件包含项目依赖项的确切信息，由Cargo维护，我们无须关心它。</li></ul><h3 id="编译执行">编译执行</h3><p>在<code>src/main.rs</code>里cargo已经自动生成了输出<code>Hello, world!</code>的代码，我们来运行一下它看能否正常输出。</p><p>插一句题外话，在你日后漫长的Rust编码生涯中，你会发现，你将在处理编译错误上耗费大量的时间。还记得吗，Rust 的一大特色是保证内存安全，这保证了Rust代码只要运行起来就几乎不会发生内存错误，这么诱人的效果的背后的代价就是，我们要在编码时付出额外的努力。Rust为了保证内存安全设计了一套复杂的规则，这导致我们的代码一不留神就会编译不过。所以，在你日后经常用的一个操作就是检查能否编译通过，而不是直接编译，因为直接编译还要进行代码优化等操作所以会相对费时。可以使用下列命令检查编译错误：</p><pre class=" language-language-bash"><code class="language-language-bash">cargo check</code></pre><p>在Clion中需要新加一个Configuration来执行<code>cargo check</code>命令，如下图所示：</p><p><img src="../images/6.png" alt=""></p><p>确保<code>cargo check</code>通过后，可以执行<code>cargo build</code>来执行编译。编译后会产生一个<code>target</code>文件夹，在<code>target/debug</code>下会有一个和crate同名的可执行文件。但一般为了方便，可以直接执行<code>cargo run</code>，这条命令等价于先编译后执行。下图是执行<code>cargo run</code>后Clion的控制台输出：</p><p><img src="../images/7.png" alt=""></p><h3 id="猜谜游戏">猜谜游戏</h3><p>在完成了项目搭建后，接下来就要开始猜谜游戏的代码编写了，我将它们分成六部分：创建变量、输入、输出、错误处理、随机数生成、完整代码。</p><h4 id="创建变量">创建变量</h4><p>使用<code>let</code>语句创建变量，需要注意的是，在Rust中，变量默认是不可变的，可以在变量名前使用<code>mut</code>来使得变量可变：</p><pre class=" language-language-rust"><code class="language-language-rust">let a = 5; // 不可变let mut b = 10; // 可变</code></pre><p>在上面的<code>let</code>语句中，我们并没有显示声明变量的类型，但这并不代表Rust是动态类型的，Rust仍然是静态类型的，只不过Rust有一个可以通过上下文推断类型的强大编译器。</p><h4 id="输出">输出</h4><p>我们早已在<code>hello_world.rs</code>中见识过了最基本的输出方式：</p><pre class=" language-language-rust"><code class="language-language-rust">println!("Hello, world!");</code></pre><p>需要注意的是，这里的<code>println!</code>是一个宏，而非一个函数，println后面的感叹号就是宏的标志。Rust中的宏与C/C++中的宏是完全不一样的东西，简单说，可以把它理解为一种安全版的编译期语法扩展。这里之所以使用输出宏而非函数，是因为标准输出宏可以完成编译期格式检查，更加安全。</p><p>如果需要输出某个变量的值，可以使用占位符<code>&#123;&#125;</code>，例如：</p><pre class=" language-language-rust"><code class="language-language-rust">let x = 0;let y = 10;println!("x = {} and y = {}", x, y);</code></pre><p>其输出结果为：</p><pre class=" language-language-bash"><code class="language-language-bash">x = 0 and y = 10</code></pre><h4 id="输入">输入</h4><p>为了从控制台中获取用户的输入，需要使用标准库<code>std::io</code>。使用<code>use</code>语句将该库引入当前作用域：</p><pre class=" language-language-rust"><code class="language-language-rust">use std::io;</code></pre><p>我们可以使用<code>io</code>库中的函数<code>stdin</code>：</p><pre class=" language-language-rust"><code class="language-language-rust">let mut guess = String::new(); // 创建一个字符串类型的可变变量io::stdin().read_line(&mut guess).expect("Failed to read line");</code></pre><p><code>stdin</code>函数返回一个<code>std::io::Stdin</code>的实例，这代表终端标准输入句柄的类型。然后调用<code>read_line</code>方法，可以从标准输入中读取一行并存入到<code>guess</code>变量中去。<code>&amp;</code>表示这是一个引用，这是一个复杂的特性，我们现在无须了解它。</p><p>读取用户输入后，我们需要判断用户是否正确输入了数字。<code>String</code>类型带有处理字符串处理的一些方法：</p><pre class=" language-language-rust"><code class="language-language-rust">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre><p>字符串的 <code>parse </code>方法将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess </code>后的冒号<code>:</code>告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型，u32 是一个无符号的 32 位整型。<code>trim</code>方法用于消除回车空格等符号。</p><h4 id="错误处理">错误处理</h4><p>上一小节代码中还有一个<code>expect</code>没有分析，而这就涉及到Rust中的错误处理机制了。<code>read_line</code>的返回值类型是<code>io::Result</code>，它是<code>Result</code>类型在<code>io</code>模块的特化版本。<code>Result</code>是枚举类型，其成员为<code>Ok</code>和<code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err </code>成员则意味着操作失败，内部包含失败的前因后果。</p><p><code>Result</code>类型的作用是编码错误处理信息。<code>Result </code>类型像其他类型一样，拥有定义于其上的方法。<code>io::Result</code>的实例拥有<code>expect</code>方法。如果 <code>io::Result </code>实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并打印参数传递给 <code>expect </code>的信息。如果<code>io::Result</code>实例的值是 <code>Ok</code>，<code>expect </code>会获取 <code>Ok </code>中的值并返回。在本例中，这个值是用户输入到标准输入中的字节数。</p><h4 id="随机数生成">随机数生成</h4><p>猜谜游戏需要能够自动生成随机数。Rust标准库中并未包含随机数功能，但我们可以通过引入外部crate来获得随机数功能。还记得Rust的官方开源仓库吗，那里可是有很多宝贝的。打开<code>https://crates.io/</code>，在搜索框中键入<code>rand</code>来搜索具有随机数功能的crate，出来的第一个结果就是我们需要的crate。</p><p><img src="../images/8.png" alt=""></p><p>现在我们将这个库引入到我们的项目中。打开<code>Cargo.toml</code>，在<code>[dependencies]</code>下添加：</p><pre class=" language-language-toml"><code class="language-language-toml">[dependencies]rand = "0.8.3"</code></pre><p><code>[dependencies]</code> 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。</p><p>下面使用<code>rand</code>库来产生随机数。首先，使用<code>use</code>语句引入<code>rand</code>，<code>use rand::Rng;</code>。然后调用下列函数产生一个1和100之间的数：</p><pre class=" language-language-rust"><code class="language-language-rust">let number = rand::thread_rng().gen_range(1..=100);</code></pre><h4 id="完整代码">完整代码</h4><p>猜谜游戏的完整代码如下。</p><pre class=" language-language-rust"><code class="language-language-rust">use std::io;use std::cmp::Ordering;use rand::Rng;fn main() {    println!("Guess the number!");    let secret_number = rand::thread_rng().gen_range(1..=100);    loop {        println!("Please input your guess.");        let mut guess = String::new();        io::stdin().read_line(&mut guess)            .expect("Failed to read line");        let guess: u32 = match guess.trim().parse() {            Ok(num) => num,            Err(_) => continue,        };        println!("You guessed: {}", guess);        match guess.cmp(&secret_number) {            Ordering::Less => println!("Too small!"),            Ordering::Greater => println!("Too big!"),            Ordering::Equal => {                println!("You win!");                break;            }        }    }}</code></pre><p>其中，涉及控制流操作的<code>loop</code>、<code>match</code>、<code>continue</code>、<code>break</code>等语法，大家应当能够望文生义。对于这个完整代码，大家能够阅读并大概知道每一行干了啥即可，不必纠结于语法细节。</p><p>猜谜游戏运行结果如下：</p><p><img src="../images/9.png" alt=""></p><h3 id="参考文献">参考文献</h3><ul><li>《The Rust Programming Language》</li><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#0：初窥门径</title>
      <link href="posts/56021c3e.html"/>
      <url>posts/56021c3e.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么选择Rust">为什么选择Rust</h3><p>这个世界上的编程语言不计其数，仅在 <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>（开发语言排行榜）上被纳入统计范围的就有273种之多，下图是当下最流行的前20种编程语言。</p><p><img src="../images/1.png" alt=""></p><p>这些优秀的编程语言往往都有自己的绝活，例如C性能非常高，Java便于抽象擅长组织大型程序，Python适合小巧的脚本，等等。但同样，它们也并非完美，性能高的C容易产生段错误（segfault，由访问不属于本程序拥有的内存所造成的崩溃，例如空指针解引用等），擅长抽象的Java需要垃圾回收（GC），上手快的Python解释执行速度较慢。所以，编程语言的设计和发展仍有进步的空间，而Rust就是近年来涌现的新一代的综合各大编程语言优点的集大成者。</p><p>Rust的设计者是这样定位这门语言的：</p><blockquote><p>Rust is a system’s programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>Rust的突出优势可以总结为以下三点（无须看懂，知道Rust很厉害就完事了）：</p><ul><li>内存安全：Rust最重要的特点就是可以提供内存安全保证，而且没有额外的性能损失。保证内存安全即不会出现内存访问错误，为此，Rust建立了严格的内存安全管理模型：<ul><li>所有权系统：每个被分配的内存都有一个独占其所有权的指针，只有当该指针被销毁时，其对应的内存才能随之被释放。所有权系统借鉴了C++的RAII机制，这是Rust无GC但是可以安全管理内存的基石。</li><li>借用和生命周期：每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。</li></ul></li><li>零成本抽象：抽象表达能力是使用编程语言高效开发的必要条件，有些语言的抽象表达能力是靠牺牲性能换来的，而Rust的抽象表达能力不会存在运行时性能开销。Rust零成本抽象的基石是泛型和trait。</li><li>并发：内存安全的bug和并发安全的bug产生都是由内存的不正当访问造成的，所以，利用装载了所有权的强大类型系统，Rust能够在编译期检查出多线程并发代码中的数据竞争问题。</li></ul><p>Rust以其独特的魅力已经连续多年荣膺StackOverflow网站最受程序员欢迎的编程语言，虽然目前其在TIOBE榜单上还未入前列，但未来互联网必定更加注重安全和高性能，所以应运而生的Rust必将大有可为。</p><p>在学习Rust的语法之前，我们先一起来了解一下Rust的周边知识。</p><h3 id="Rust常用网站">Rust常用网站</h3><ul><li>官方网站：点击<a href="https://www.rust-lang.org">这里</a>。在这里你可以找到官方教材TRPL等许多重要内容，所以探索一下此网站大有裨益。</li><li>编译器是开源的：点击<a href="https://github.com/rust-lang/rust">这里</a>。对Rust语言来说，开源社区也是语言的一部分，这是和其他商用语言的区别所在。</li><li>语言设计和相关讨论：点击<a href="https://github.com/rust-lang/rfcs">这里</a>。Rust每增加一个重要语言特性，都会经过标准的RFC流程，RFC文档是涵盖了语言特性的设计意图、详细设计、优缺点的完整技术方案。这对于我们学习者来说，可以通过阅读RFC来深入了解某个语言特性的来龙去脉，这将是一个极其宝贵的学习资源，有助于了解某个特性背后的原理。</li><li>官方开源仓库：点击<a href="https://crates.io/">这里</a>。该网站储存了Rust社区热门的开源库。</li></ul><h3 id="版本和发布策略">版本和发布策略</h3><p>Rust编译器的版本号采用了“语义化版本号”（Semantic Versioning）的方案，版本格式为：主版本号.次版本号.修订号，其递增规则如下：</p><ul><li>主版本号：当做了不兼容的API修改</li><li>次版本号：当做了向下兼容的功能性新增</li><li>修订号：当做了向下兼容的问题修正</li></ul><p>Rust团队维护三个发行分支：</p><ul><li>开发版（nightly）：最新的功能将首先发布在此分支，供用户试用。</li><li>测试版（beta）：将nightly版本中验证过的功能开放给用户使用，可以看作是stable版本的预发布版本。</li><li>稳定版（stable）：每隔6个星期发布的稳定可靠的版本。</li></ul><p>Rust语言每个相对复杂一点的新功能，都要经历如下步骤才算真正稳定可用：</p><blockquote><p>RFC -&gt; Nightly -&gt; Beta -&gt; Stable</p></blockquote><p>有时一些新功能确实需要一定程度上破坏兼容性，为了最大程度上减少这些变动给用户带来的影响，Rust设计组又提出一个所谓的edition方案，目前有 2015 和 2018两种edition，我们可以设置&quot;edition=2018&quot;来告诉编译器我们使用的版本。</p><h3 id="安装开发环境">安装开发环境</h3><p>根据官网的<a href="https://www.rust-lang.org/tools/install">推荐</a>，可以使用一个叫rustup的工具安装Rust相关的一整套工具链。命令如下：</p><pre class=" language-language-bash"><code class="language-language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></pre><p>我们可以使用rustup工具管理工具链：</p><pre class=" language-language-bash"><code class="language-language-bash">// 更新rustup本身rustup self update// 更新工具链rustup update</code></pre><p>也可以用它在<code>stable/beta/nightly</code>三种版本中轻松切换：</p><pre class=" language-language-bash"><code class="language-language-bash">// 安装nightly版本的工具链rustup install nightly// 设置默认工具链是nightly版本rustup default nightly</code></pre><p>若执行下列命令能够正确输出版本号则说明Rust安装成功：</p><pre class=" language-language-bash"><code class="language-language-bash">rustc --version</code></pre><p>若安装不成功，请尝试将<code>~/.cargo/bin</code>加入PATH环境变量中去。</p><p>在<code>~/.cargo/bin</code>目录下可以找到Rust的一些常用工具，如下图所示：</p><p><img src="../images/2.png" alt=""></p><ul><li>cargo：Rust的包管理器，类似于Python的pip、Node.js的npm。但cargo不仅局限于包管理，它还为Rust生态系统提供了标准的工作流，能够管理整个工作流程，从创建项目、运行单元测试和基准测试，到构建发布链接库，再到运行可执行文件，等等。</li><li>rustc：Rust的编译器，负责将Rust源代码编译为可执行文件或其他库文件。rustc使用Rust语言开发，其输出的错误信息非常友好和详尽，远超你见过的任何一款编译器。</li><li>rustdoc：文档生成器。</li><li>rls和racer：为编辑器准备的代码提示工具。</li><li>cargo-fmt和rustfmt：源代码格式化工具，有了这个，再也不用争论大括号是写在行尾还是另起一行了。</li><li>rust-gdb和rust-lldb：调试器。</li></ul><p>对于IDE，Rust尚没有专属的IDE，我推荐Clion+Rust插件，已经非常好用了。</p><h3 id="Hello-World">Hello World</h3><p>配置好了开发环境，如何能不写一个充满仪式感的Hello World程序呢？来，新建一个文件，命名为<code>hello_world.rs</code>，内容如下：</p><pre class=" language-language-rust"><code class="language-language-rust">// hello_world.rsfn main() {let s = "hello world!";println!("{}", s);}</code></pre><p>然后使用rustc编译它，可看到当前文件夹下生成了一个名为<code>hello_world</code>的可执行程序：</p><p><img src="../images/3.png" alt=""></p><h3 id="Rust的设计哲学">Rust的设计哲学</h3><p>Rust是具有混合范式的“面向过程”式的编程语言，它包含了面向对象、函数式和泛型三种编程范式，其设计哲学如下：</p><ul><li>内存安全为第一准则</li><li>注重并发安全，避免数据竞争</li><li>持续提升性能</li><li>保持语言的高度一致性</li><li>语言必须有可见的实用性</li><li>注重开发体验和学习体验</li><li>现代化语言特性</li><li>拥抱开源社区</li></ul><h3 id="学习Rust的建议">学习Rust的建议</h3><p>这些建议来自于张汉东老师，我认为还是十分中肯的，所以列在此处和大家分享。</p><ul><li>从整体出发，不要让自己陷入到细节中去。先有高屋建瓴的结构性的认知，再深入语法细节，有利于建立知识网络，可以事半功倍。</li><li>抛弃一次性学会的念头，分层次递进式学习。</li><li>和你已知的知识建立联系。新语言新特性出现的本质原因是为了解决某个问题，因此，当我们学习Rust的新特性时，可以和其他语言的旧特性进行对比，了解其改进的动机和方式，这有助于增强对语法的记忆和理解。</li><li>学会阅读源码，从源码中学习。建议在学习语法时，顺带阅读源码。</li><li>通过主题式阅读来填补知识空白。可以从其他语言的相同特性中了解语法的概念，观察不同语言对同一概念的不同实现方式，</li><li>时刻把握Rust设计哲学。我们要从Rust的设计哲学去思考某种特性这样设计的原因。</li><li>有意识地构建Rust的心智模型，有意识地训练以Rust的方法思考代码编写的方式。</li></ul><h3 id="参考文献">参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
