<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《为什么是中国》：中国共产党的百年逐梦路</title>
      <link href="posts/9d4da967.html"/>
      <url>posts/9d4da967.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de5669b5a09b87aeaa5806252487c491b857877ee26600ee728e6425e604b8fc">dce56676e958d221bbfadb0680d37e027e19b3856e6e663e50ac14976917be20427c3a056794f3bcb7d906b2faf746fe4408f7d1aece96611a4b87df63d90e63484912c25bd7050581de5d55fd4374039e06ada15fad89569e4d6955a1dcc46e2bfe72a257f52593b293b9758d9a9ff5272e262f16c334f60c7ee5f5611b5f2f5da0543a2d93793d81e35718c15e33ec25108e3bc5b3af382b6f13b03d6fc92b79dd97751d4496153adf2f80a5dac156a9683929563e2ca1e9e53ca7987f5e6a0a67867c71d55204b3935408d515e6e627f662e6cc5d225497402b61b67dabbbdfe36a72250b403ae68681f76ebfcfc17ee5da7b17cc2ef5ad99560c9cb5bf601293340dffeea0b20be5cb7e4af036088f1591b69b223eb1b946082d2fb5f4bb925626fc145a5a56ee146884dea0ba94a03c32898b6ac5c8bae65363c7f80d71b1856f9e070fa870895d0e54be4ecd40c0fc22f4f4135a46d6fbd71a273b6aa871bd7c9b39dcf994784a58cda82e01964d17680cb4bea1e43288384f4221036fb741389176c6b4bb863ebd8b9f0d5c286d2b87b0c7b6e0a68878f0675d5f42dd4d6fed9b1c8147421b83dbe5336b15a0d659ac840dc88836dd3e05896d88a80deed72073ae4c241629c969a2e43a7229f54bd311803bac0e49bd1023862eb877c7b913620b90ef72545f85b2cbcdf66bab36fef3afcd68afd2b8807ab1ea67641ee5fb4905f6503011395055ec8def84a7efa306d9e81d1812ad0ec98bbf9e57a9caebf1cbb8273c4a3d545c43045113323070704a578c3ece6ee9f40c965c5bfb73ce309010b05b77faeac4ad09911b430511abbdd9c6f375ccf122a04ef49166cc8aaa7d400682b5f6aae782d34b6232aa3d7b993f4acea24b704c6a7c463a38868752252de0ce1698adb43bf8c939102184e5e2ace38b71c080310f0db6d2333ceac4fcd65ebe3d5b8512ab9c22e66b594a1f3705e49bec83f05c2b57c271a9b54fcf04e42257abb88ba9627274c1be827a25230cf5470dec8a5bb6b6cb4c23dc1ace0aa334923c0a79f7ff1d360715ed78d250b8e2543ca35b4299817d4e347cf1cc06203adc0bcce9f8518f31cfc525f53c94ee10b9c91732f5b8b83a4a0a3cd9c96683ed27ada1cbe0ff058220b7cadeb80fdec80262fca12bffe25b6e580edbd258e0dc65605d432ba7deb740ee1fc00177daab205fc928ed78af55796bd002ad432094fae5f89a26f954da65c0e1f20a5fc57db76812d458854eec6cd4bc1d9f3f67c19c1e54c04087908ddb0c33c815aaa4f5f648cdead2033961ed8bb0f6a494dc0470753f28e78bce292bdb0d925d9305cae2969c07dde2a6bc82970ccaf97f8d94848165e2a6603b3835116b980161c0035af657872ec1bea038354496131a103c000d27cb52ff252b2a32ec5e773766ffb9463b845f73c0a2ad444081ccd04ba2831f7325828d73e85d9da310551bcc632a39d195af56409b9a95bebabff3a108c3c6205c77408e8f2f70ae88933179b9adf9f9c87d7fd0cdb376ce803108d427ff1b3da4f09f0054aecc2f594e70a8572742f1fc4f2d8f67e1d2efef94deda8a4407ef33c6451323bd26fe8594edc548c9207d03cda97493ba19fb52c9f56426e9765f71ae05e5a4a00c95bf660c8329942f512b9adc0b925e1f94e4b91b2212f9236b1d72b1d75c449bc061e8804f187656a7f9a292f2df6ebac2f5991a621536a65e199a0582fe5ebb4b6eaa6006ee1902a97970e0baef49742f0c6c8e6a8b56c43a76c5a4350057e446ba2d0f681e2aceff6394fab7388a10d8edc497e2c33916edfa2a96d8eee265c67d049a19ffbad5fceb001a2df1e6ec3bdd7861be686fe6e3a2c222ef79a677cc46e9156e36ef755189d1cdb18e16b02bd6707afbca751c1e805f3bc23ef844a1e46cb6f0b68e8ab9d8142c1a6a826d02be356220521d8c8566860f4fea9cd6cff72f911f809df75cec6d47134d8dd76c667c2aae0b636e35bf798570dee3af4e8b0c3868f4e90bff4ec5ae65e08ff4fb7830823bb5be170728df95ba1ea1d8fb9b16faddef19170f4ea9a326a382396bfa88f702bbec27a481dd7750ce07002abae863d66204213a848b113d51046b4b6aeb4307be7d07b8b858c698a596cf36d6d504f0a0b9397a35540b5929c262fe4909e191fe8008f775c7af60bb99efa8d843162b98a2f8cef2164d09ac037a64d07ae0c2d299acf32b90aad2dc0d535f688f3bfccd908718a0ec8e95b77e34c39c8f69da06d035004ed4aeb86fa48c98edcd95adea6a936229d63964ec1e8632310c95a31f2c7ddd837e7148712650566f7fe1c83b0bff98a6082b590bc05d958a85b597d18a12b8f5464c2a0ec92e8d279b90030fc35a256812f51218b02d19b24c0bb0853d65e12ec4a67d777c74de4f3303aeebf20afef81d9d3c888614dc1a5bd45a516ea9d7e3addfd4369f65d2984220383a56100493ef57204b4dcdc70587274cb2ad2d880e74e02e1115962f78117b89fb3ef7f999d32f2b0c6b7dd8813f5f33bf95f466200f73f34864a1001b9f8b5b63c8682237892098ec04ff00444fe8d309a233c6a6dccd3a71c330e8c0f6b661d580b3abe26c0d1d19238d53609f4fb66d265abe7d59b84ef2be2bea4cfb952d8a2d6b49c4e9563a5a8d47216489428220e3c0f76c6ae8fd85d6aabc03ca823ebb4a08be539e1a27dc664382b74cc0c673038912f22313673e00c801a040bb6bc3d3ba305de89804dbfe9cf47f36adb5e84a5b81046481cab784503826fce2e69a5ef571b94107fece25b6a7b6c7e9f5d09a52fe75a03d2374df9e858dbf51e466077e7cf3f6d65ac3629696f488f4db8f8fa20f6c19da685647adb3622b838801e9ad125d49044a3aa165058e58a89a758e8426d59c4c49c4f5a58ca7d3841f7fba6c21ae7c9c7deb6fabd7a6d33e52e23b1409506e308cbb24a8ea0d531c6bbd54ff4632402e47e38c3f4ee66560b84ae6e9be83ee927f2054f64fa82f24cb8f446e962856a9fe977212716549d0dccf14663dae09152d0fa978d366384b7cbd0b2d93ec92b0bc572ec7931604b4e129166040ae6a6acc95f2d354a8a4da1e9fa8b6bde60fbf17232d1389316afd49a938a6fdd5ecb2116537cfa9e2159820abf7b2156f741058c0f7045c753e17a46332585baaa006447f58a91c039e6da936a8278dce416a76ad8cc8eb0c5daf7d26928963709f5f2f07c69e416b6f1e3252ae9449e750571309a728fdc9e9837f990fd40a5a2a294de525c10937226dee8bb3190f6cc59c6370ba2e25069674e0e35dc20a5d5be1a14bcf162950e997ab97fb6b8496c28be478fbf467e85dcce6138a9b78ec31ef4439dcaedb570df2b528144a74aa9196d6f03d000132449d9a3a1a09a67efefa74de5a10edc179605b94ee0717b6ce93f56cff6bca030878039785fc7314d93dda8fc7764a49b4f31ac74901588a05690d4a0d8f3233fb419e8764318b51c8022ae6a788e9c0d9ae197dcc8d9776c2fc081d89af58b57d91ac85aae835674a2d6628d4e90bb3a00d358c7e066639006ebd05a37e63577fc3b6d16b06db81dd77f69336492c1c5d692aea8a0bf93419442300db72a903f51ab8c86f754d97a4c02480055d3fe13f48890f942ccf8eed8c2b7e3c8590e576bbb453dc3fcaae5fc04ebbe260e3f27a88b42f4e92051a033afae7dd7542d4732056cee7a1ae91b092ef3d8b28421477451972ed3107128ffc457daae5044dbc313e7dfdb3e53a94322a0c70ae3aabcbb11bc33d2c59d1ee0c20e48a3451270cadce0be4bd35a2524e342df3b02446ee5d5d4964d6ccfdd9d908f22a60d9617325abb225f5679dc289bd211d0041ef505e60bf535c0461e1c536161f237f54117c97538acc75a93077dabe6c1706a56d68af1cef92e210b5bb2238f03d1912f472db455638194c9ce9c42d75bec807f93017dcb969aa92d40014e929f43888703bae9ac73e2fdca255a6652604dfabe4e55afc622f316bf6cf9619ca683d039a5c25ae9a555c8f158f052987917f8d29ee177de8ffc1c042f375fa4f97bf02368457a2a87ff4372851677b62748330b5246512831caf1ce1606b7078944f9353ed89c57140ac736063b4bd88236e8c0a96afb26695a3e8f114c1dc940015452a4812e38116413e9addd1211065ae30ffc5e039ae6005c42efa2a0a94fac992e69f6f48099b38e46b1325e0488bcc2712b40031d7298810c7c27c673acce1511cdf3089c317c2d4013edc2cfa8d26fa4916bd6440af31f52a68cd5c515a5b697266d50a1e017149d7118035e69153127ddc79ad83d6ee5ba8d4776db0dd4adb6bf827f61515635133a8fe76a30d0a0dd0907888a2b57e9c4e54c44cda968c82516acd1374dd1887389f029351143fb06f21034ae0ab49ab81c157300e30634ece00c34335ac8ef0455da20cda66289e99557e0272e2c3a2f22be66ea5a08b72fdf2e476c30bb09c667164e122e427fddb6dc90fff1050b6c29c921a0c0d7aa72b000facf0aa3884782fb5be1498fbbca6f53e33b58443a67e384bebcd7d9691980f8ed43536f17ee5b5cf160d03cbb0abb29a0173accaedf9dbcb797e442ccf67264fbb3c194fc600ff68da76a0bcefa9e29f23fdfd17cbde5546341954fbe97b8972c371fe98beca357cc934c38336c677df3513cdc107760552829ec04688dcb8b87acaf7d80fd5bb2bba73bb28cc99f5097f184820df8ca9f56cfc73a090a964782d48e95bb1f652883dabb05b3642f852d486277453fa3b3d30df22c7c7869409ff7bd023655d1eb1c24602170122e2a0cb3978222888ad4a523d3758d629442ec7917ada4b16816e1eea864d544af2f9283d692917496d42e9336b3e40054455e9f18ba6ee3015c0cd7426f1bacb25a5129a926cae03576c588c128d960be6f60baa5ef4531ff23a94e26ca569e4257b1a2fc6f3b1ea68f7ad18869d071a68c373444d5eecc2797ed6ed85fb19279aef9eda30aa3e655330b72071faaa2c48c68664442fdfce9bdbdc7f350abf97a2219328806ca07b9cf285a8731e80d68a5e99b82747f56621d20ebe6580dc6eff44599271f39e81f2f21e2c22fd0530522c0e150a7660811df7cebef5a0498bb0e7dd8d8965a58b91cfc90ca239a25f6845b3f03b711c3a8eb165f1f6f95bed62a31a8a68eda8c42630aa544074ea700f79f977ed16a1932f11f1536771e010c0d025e6666bbcfd0634a6ae8ebf7170f3f34ec36b23133a1641f34edc46c0cf16d6365b6532e601cbe2f978a97cee02fd88c57b7ddc9a98ed10df431e6fd0ec5a817c5da660e21a162f475f53e891a517b60c21030e9cca5f3701916bea86349ed4042b663d604a73c623ca432808b0b37c1373171472e882f7d6560c810e85078e92ade38fa510e6736b11ebc34787796567492a1d84865db89c0846a68be8be0133eff62af31c583dccac9edda7842370ecf46b8ccda17477554c26a5023ed2f9403ae6710c6727ffa723c5baaf4c35d45b8d201a1dc366af801fd34b5136ab2a3e328ae454f1021b14f78a31071209b26e7f57474df4f4f63ec06cd10054dc4b31b1f19bc20f4c519fb19b9ac7542f037e8f1c05218465869f6d71f49d2c26022fc9c58c0b513d1b9f7577dc272c10cbe3badcee20f4ac3d159186cd5d2cefafe3ff3164fb8bdfcb7ca13b564fbbc07b67f47c3ee30a94d2461b32a526445c699828c004bc021f161f93863ee812fdf1a0bc52040a0a6e2e47e28de9595b359cc27cfe2eed32da353ed8913c5163d30f22397d17fcf02156be5ef4c9c456c2931252356056f3d13d8076929be0ef7ccbca6e1381c7614951ee7447a2d68c79f1de1afd887fd3de63bb85208101400f04a15e2910ebbf783dea7a251403287f2f394d6e5b4736bd3d0c517d7a5fbc36a66a0fe2038f2f3c8c024371db212872c0c3b4d5196b4cd0904f63e7cf4c583150ceafe70e0c0c5366c6cb5784452bbdf7ee9a65268afad2c756ee722a99b21387f0971b09ac346c5ddee1cb8438f010b7113f17523fbae51b8f46b68b7e9f18f57338782ef729b8eb745dcc80fb5979f6c94744fefded9a00d858b9b76d0b64378e6b68dac9b7015da20a0508cfea3a1d812b074420582b847e5b04cc7f3954b6e7cab1687e24b2ea0894098e85c7aefd79f5d8d699957d1e370e34ba785b575baab980012ea3315e02b866f2db52ef8297ea2dcdd994c190eefb32fcee3293d45817da0ea06c050e426181e1bc53234198110a1b158ddca072ae39d4adee8dffa77819b4141f0d1afbb5988988deae7af997009130883daa5fb8c189d7ed575e8e86ff3ac01b72320f85b676e89af838b2ec4748a09a65ec48871cb9187df0ac3750ea3c6dc480cd0e2da584ad3a0f4bfb0483523303d8e0aec099edd7ed1c2b91398fdd9d25883cfa84b87b6dafcc7fe058b109a4033a3ba4cf7a3c2883ec31fb2892f9e69f2ce024c0d265639448e86461efa000d0a0bb4919fdf380aefd95b6196b41fa740d48de5e3c125ef6bc96d60393c25a1834ee35161b011991906354044604561e0abdfa6bb3168fa62369d5f00d45e32cc53cb52e5c49a104573648e42dfb34430282ebab44bb7a62581a95d09aca0660c178d1ae8622a85122fb8b47877070a95d37e56d483c75074ce5f8de2dd30033d025fa444b284000e0c0f24b30c43f7bdef80bb35fc518288f9a9b0c4e9c2c66b473bc18a90c6ce6c4b294c09a82d7710ed4c64713eb9cec68e5e28311be08923896d85ce350922720e8f5d6e51921992400b57a7a8011c2c07e95b91b616e7783532f508206f6a554a97128289e57a423a4af6efd8c8bfe37f699d938b76bf169d61e099d73c2fb87486a1261bf48d0066b12809aa6a8ebee9114be97345f86225f9ad71ccc75814d43a2071ddd349459c484856d28a7b87e1223cf254738822442e3a3a2f2801949cb1407dd1eb221bd050cbf415525d3fade5c7afd0878c73511634619e3566fb7b6fda8c7de5368722f357c5ae89f5e79e85a0ab40109368db086446f9ac3e0894c3051ee56332b7bca478b6f85047141796c71e573d8c7aa9a35d36bddcf02b1082718d2336649a5a5890fbbd4699a3e61f01b4a06136845b85fa4997411299cbf7100deec7fb8d28dae338c87413272f97a6ab256d1675df01dbf8f800b35cde29b42fed853f4ea5f3cf40ae316fff685e514065a85fca57755ddff20a921c31c16ee211dce3d1a2ca1fa04bec6a80306033b1ede42815c45d1e9e73bcefc9632c2bb4f22c9f3acab5b2c9c3bc1609c5eb2bc8573fe8e50f747bd91313a547b566cac3804d4c3f72b83b98a4a851553811fb681227efe406c66d290e328ecd66669c4b82a6743d23c3659abd8d79ee2bcdff0b380f2e4991e90bffd69fbb6af39470c550a36b0fbad22765539d41a0e88a3c31d6af73da5119636e9181752c16522bdcadcf6214701a06a3384d80cd5eb8405bee51cd3c5fb5f48ca1c8d4b61e1ca15d2a042735a71bb157e66e4430b79d2163ebf624f112c421d5bdeb7c442d15e79eefa51cdf0fa32f3b194d06b718cd8cbc1ecfdf3067657d8015c60b755c003b84f30740d0dbc821ee3af539814e61b594d30d9ca5a202ea23d9f8267a67414df5a22a6c51425550f6fdd77630d85eff9efc0b83a4362aca94ca54e76f51537dc12931db6edda8eaa25b880451332098205f3de38df416084fe846d075b2273ceecc155ad518d8660d8c99a7752d025f1d4cf6e1888ec0e4eb88b1901b7e821f4901ed22592de5a15a489156750422a690d505170f710a4f6603339bcc450a5147af37d41a81cbe3f56f44c4874275e6e6cee9f026f7d0384236ea230787dac90c07413aae29295781be301bf7a24574d43bcb95db13c1de9f9ecba8832aa5c837f1922b7b2339923724fa041e3b546dee40fe3254f45ad1f6d16253ba12e5f784e0f522fc6d89a7e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件工程：理论与实践》学习笔记</title>
      <link href="posts/5218a5b6.html"/>
      <url>posts/5218a5b6.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>按照功能的不同，软件可以分为<strong>系统软件</strong>、<strong>支撑软件</strong>和<strong>应用软件</strong>3类。系统软件是计算机系统中最靠近硬件的一层，为其他程序提供最底层的系统服务，它与具体的应用领域无关，如编译程序和操作系统等。支撑软件以系统软件为基础，以提高系统性能为主要目标，支撑应用软件的开发与运行，支撑软件主要包括环境数据库、各种接口软件和工具组。应用软件是提供特定应用服务的软件，如字处理程序等。</p></li><li><p>IEEE（Institute of Electrical and Electronics Engineers，电气和电子工程师协会）对<strong>软件工程的定义</strong>为：（1）将系统化、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件。（2）对（1）中所述方法的研究。</p></li><li><p>在传统的软件工程中，软件开发的<strong>生命周期</strong>可以划分为可行性研究、需求分析、软件设计、软件实现、软件测试、软件维护等阶段。</p></li></ul><h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><ul><li><p>瀑布模型：</p><ul><li>具有不可回溯性，前一阶段的输出是后一阶段的输入。</li><li>文档驱动。</li><li>优点是过程模型简单，容易执行；缺点是无法适应变更（代价高）。</li><li><img src="../images/31.png"></li></ul></li><li><p>快速原型模型</p><ul><li><p>快速原型的基本思想是快速建立一个能反映用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解目标系统的概貌。</p></li><li><p>快速原型的本质是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。</p></li><li><p><img src="../images/32.png"></p></li></ul></li><li><p>增量模型</p><ul><li>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。</li><li>增量模型的缺点是要求待开发的软件系统可以被模块化。如果待开发的软件系统很难被模块化，那么将会给增量开发带来很多麻烦。</li><li><img src="../images/33.png"></li></ul></li><li><p>螺旋模型</p><ul><li>螺旋模型是一种用于开发风险较大的大型软件项目的开发模型。该模型将瀑布模型与快速原型模型结合起来，并且加入了这两种模型忽略了的风险分析。</li><li><img src="../images/34.png"></li></ul></li><li><p>喷泉模型</p><ul><li>“喷泉”一词体现了面向对象方法的迭代和无间隙性。迭代是指各阶段需要多次重复。例如，分析和设计阶段常常需要多次、重复进行，以更好地实现需求。无间隙性是指各个阶段之间没有明显的界限，并常常在时间上互相交叉，并行进行。</li><li><img src="../images/35.png"></li></ul></li></ul><h3 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h3><ul><li><strong>技术可行性</strong>主要研究待开发系统的功能、性能和限制条件，确定现有技术能否实现有关的解决方案，在现有的资源条件下实现新系统的技术风险有多大。</li><li><strong>操作可行性</strong>研究决定在当前的政治意识形态、法律法规、社会道德、民族意识以及系统运行的组织机构或人员等环境下，系统的操作是否可行。</li><li><strong>经济可行性</strong>用于评估基于项目的经济合理性，给出项目开发的成本论证，并将估算的成本与预期的利润进行对比。</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li><p>确定系统的<strong>运行环境需求</strong>：包括硬件环境要求和软件环境要求</p></li><li><p>确定系统的<strong>功能性需求和非功能性需求</strong>：需求可以分为功能性需求和非功能性需求两大类，功能性需求定义了系统做什么，非功能性需求定义了系统工作时的特性。</p><ul><li>功能需求是软件系统最基本的需求表述，包括对系统应该提供的服务，如何对输入做出反应以及系统在特定条件下的行为描述。</li><li>非功能性需求包括对系统提出的性能需求、可靠性和可用性需求、系统安全以及系统对开发过程、时间、资源等方面的约束和标准等。</li></ul></li><li><p><strong>软件需求规格说明书</strong>是需求分析阶段的输出，它全面、清晰地描述了用户需求，因此是开发人员进行后续软件设计的重要依据。</p></li><li><p><img src="../images/36.png"></p></li><li><p>一种考虑数据和处理的<strong>需求分析方法</strong>被称为<strong>结构化分析</strong>（Structured Analysis，SA）方法，它是20世纪70年代由Yourdon Constaintine及DeMarco等人提出和发展，并得到广泛应用的。它基于“分解”和“抽象”的基本思想，逐步建立目标系统的逻辑模型，进而描绘出满足用户要求的软件系统。</p></li></ul><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><ul><li><strong>软件设计的目标</strong>就是要回答“怎么做”才能实现软件系统的问题，也可以把设计阶段的任务理解为把软件系统能“做什么”的逻辑模型转换为“怎么做”的物理模型。</li><li>从活动任务来看，软件设计是对软件需求进行数据设计、体系结构设计、接口设计、构件设计和部署设计。</li><li>从工程管理角度来看，软件设计分为概要设计（总体设计）和详细设计。<ul><li>概要设计：概要设计确定软件的结构以及各组成部分之间的相互关系。它以需求规格说明书为基础，概要地说明软件系统的实现方案。</li><li>详细设计：详细设计确定模块内部的算法和数据结构，产生描述各模块程序过程的详细文档。</li></ul></li></ul><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><ul><li><img src="../images/37.png"></li></ul><ul><li>黑盒测试：不需要关心盒子的内部结构和内部特性，只关注软件产品的输入数据和输出结果，从而检查软件产品是否符合它的功能说明。</li><li>白盒测试：关注软件产品的内部细节和逻辑结构，即把被测的程序看成是一个透明的盒子。</li><li>黑盒测试和白盒测试都是<strong>基于用例的测试方法</strong>，因为它们都通过运行测试用例来发现问题。根据设计用例方法的不同，黑盒测试包括等价类划分法、边界值分析法、错误推测法、因果图法等，白盒测试包括逻辑覆盖测试方法和基本路径测试等方法。</li><li>等价类划分法：等价类划分是把程序的输入域划分为若干子集，然后从每个子集中选取少数具有代表性的数据用作测试用例，选取的输入数据对于揭露程序中的错误都是等效的。<ul><li>等价类分为有效等价类和无效等价类。</li><li>有效等价类是指对程序的规格说明是有意义的、由合理的输入数据构成的集合。无效等价类反之。</li><li>设计测试用例的步骤：（1）对每个输入和外部条件进行等价类划分，画出等价类表，并为每个等价类编号。（2）设计一个测试用例，使其尽可能多地覆盖有效等价类，重复这一步，直到覆盖所有的有效等价类。（3）为每一个无效等价类设计一个测试用例。</li></ul></li><li>边界值分析法：边界值分析法是补充等价类划分法的一种黑盒测试方法，它不是选择等价类中的任意元素，而是选择等价类边界的测试用例。</li><li>错误推测法：错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</li><li>逻辑覆盖法：逻辑覆盖法以程序内在的逻辑结构为基础，根据程序的流程图设计测试用例。根据覆盖的目标不同，又可分为语句覆盖、分支覆盖、条件覆盖、分支-条件覆盖、条件组合覆盖和路径覆盖。<ul><li>语句覆盖的基本思想是，设计若干测试用例，运行被测试的程序，使程序中的每个可执行语句至少执行一次。</li><li>分支覆盖的思想是使每个判断的取真分支和取假分支至少执行一次。</li><li>条件覆盖的思想是使每个判断的所有逻辑条件的每种可能取值至少执行一次。</li><li>分支-条件覆盖就是要同时满足分支覆盖和条件覆盖的要求。</li><li>条件组合覆盖的思想是使每个判断语句的所有逻辑条件的可能取值组合至少执行一次。</li><li>路径覆盖的思想是覆盖被测试程序中的所有可能路径。</li></ul></li><li>软件测试的一般步骤：<ul><li>最开始，着重测试每个单独的模块，以确保它作为一个单元来说功能是正确的，这种测试称为<strong>单元测试</strong>。单元测试大量使用白盒测试技术，检查模块控制结构中的特定路径，以确保完全覆盖并发现最大数量的错误。</li><li>接下来，必须把模块装配（即集成）在一起形成完整的软件包，在装配的同时进行测试，因此称为<strong>集成测试</strong>。集成测试同时解决程序验证和程序构造这两个问题。在集成过程中最常用的是黑盒测试用例设计技术。</li><li>软件一旦确认之后，就必须和其他系统元素（如硬件、人员、数据库）结合在一起。<strong>系统测试</strong>的任务是，验证所有系统元素都能正常配合，从而可以完成整个系统的功能，并能达到预期的性能。</li><li><strong>验收测试</strong>以用户测试为主，分为α测试和β测试。α测试是指由用户、测试人员、开发人员等共同参与的内部测试，β测试是指完全交给最终用户的测试。</li></ul></li><li>单元测试：单元测试是开发者编写代码检验被测代码的某单元功能是否正确而进行的测试。</li><li>集成测试：主要是测试软件单元的组合能否正常工作以及与其他组的模块能否集成起来工作。</li><li>系统测试：随着测试概念的发展，当前系统测试已逐渐侧重于验证系统是否符合需求规定的非功能指标。</li><li>验收测试：验收测试是在软件开发结束后，用户实际使用软件产品之前，进行的最后一次质量检验活动，主要回答开发的软件是否符合预期的各项要求以及用户能否接受的问题。验收测试主要验证软件功能的正确性和需求符合性。单元测试、集成测试和系统测试的目的是发现软件错误，将软件缺陷排除在交付客户之前，<strong>验收测试则需要客户共同参与</strong>，目的是确认软件符合需求规格。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于VMware的ArchLinux安装指南</title>
      <link href="posts/7db1dc3d.html"/>
      <url>posts/7db1dc3d.html</url>
      
        <content type="html"><![CDATA[<h3 id="下载ArchLinux镜像"><a href="#下载ArchLinux镜像" class="headerlink" title="下载ArchLinux镜像"></a>下载ArchLinux镜像</h3><p>推荐去清华大学开源软件镜像站下载最新版的ArchLinux镜像，点击<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/">这里</a>，下载<strong>archlinux-xxxx-x86_64.iso</strong>。</p><p><img src="../images/11.png"></p><h3 id="使用VMware创建虚拟机"><a href="#使用VMware创建虚拟机" class="headerlink" title="使用VMware创建虚拟机"></a>使用VMware创建虚拟机</h3><p>接下来打开VMware，使用刚刚下载好的镜像来创建一个虚拟机：</p><ul><li>第一步：选择典型即可，自定义的高级部分对于新手来说目前还用不到。</li></ul><p><img src="../images/12.png"></p><ul><li>第二步：选中之前下载好的ArchLinux镜像文件</li></ul><p><img src="../images/13.png"></p><ul><li>第三步：如图所示进行选择。VMware支持对一些常见的Linux系统例如Ubuntu进行快速安装，但目前尚未支持ArchLinux，所以在“版本”选项里只能选择“其他Linux 5.x 或更高版本内核 64位”</li></ul><p><img src="../images/14.png"></p><ul><li><p>第四步：这一步给虚拟机命名和指定存储位置，按照个人喜好进行选择即可。</p><p><img src="../images/15.png"></p></li><li><p>第五步：注意，最好将磁盘容量设置的大一些，因为使用后期如果磁盘容量不足需要扩容的话会比较麻烦。而且，我们是以“将虚拟磁盘拆分成多个文件”的方式来分配磁盘容量，因此并不会一次性从主机硬盘中切分出所有的磁盘容量，而是使用多少分配多少，所以即使这里设置的最大磁盘大小超过你主机硬盘的真实容量也没有问题。</p></li></ul><p><img src="../images/16.png"></p><ul><li>第六步：自定义硬件部分的内容在以后可以随时更改，这里可以先选择默认，然后点击“完成”即可。</li></ul><p><img src="../images/17.png"></p><h3 id="安装ArchLinux系统"><a href="#安装ArchLinux系统" class="headerlink" title="安装ArchLinux系统"></a>安装ArchLinux系统</h3><p>启动虚拟机，进入Live环境，选择第一个：</p><p><img src="../images/18.png"></p><p>下图是Live环境的操作页面，Live是一个可运行的系统，不用安装到硬盘，直接从介质就能启动。我们需要借助这个Live环境来完成一些硬盘分区等基本操作。</p><p><img src="../images/19.png"></p><h4 id="验证启动方式"><a href="#验证启动方式" class="headerlink" title="验证启动方式"></a>验证启动方式</h4><p>启动成功后就会进入命令行模式，可以在此处使用以下列出efivars目录以验证启动模式来判断主板是以何种方式引导系统的。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /sys/firmware/efi/efivars</code></pre><p>如果目录不存在，系统可能以 BIOS 模式启动，则需要使用<code>poweroff</code>命令退出Live环境，并进行如下设置：</p><p><img src="../images/29.png"></p><h4 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h4><p>首先需要连接网络，因为安装过程中需要联网下载一些包，但我们是基于虚拟机启动，所以不需要进行特殊的联网设置，直接就可以ping通百度：</p><p><img src="../images/20.png"></p><p>如果你无法联网，可以使用<code>poweroff</code>命令退出Live环境，然后按照下图对虚拟机进行设置：</p><p><img src="../images/21.png"></p><h4 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h4><p>因一些安全机制的要求，整个网络需要保持准确一致的时间。NTP是网络时间协议（Network Time Protocol）的简称，它可以提供高精准度的时间校正，其时间来源是国际标准时间UTC。直接输入以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># timedatectl set-ntp true</span><span class="token comment" spellcheck="true"># timedatectl status</span></code></pre><h4 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h4><h5 id="查看磁盘情况"><a href="#查看磁盘情况" class="headerlink" title="查看磁盘情况"></a>查看磁盘情况</h5><p>输入命令<code>fdisk -l</code>，找到你的要安装的硬盘，如下图中的 <code>/dev/sda</code>，可以看到其大小为1T，这就是当初在创建虚拟机时创建的虚拟硬盘，下面对这个虚拟硬盘进行分区。</p><p><img src="../images/22.png"></p><h5 id="硬盘分区设计"><a href="#硬盘分区设计" class="headerlink" title="硬盘分区设计"></a>硬盘分区设计</h5><table><thead><tr><th>分区</th><th>挂载点</th><th>分区大小</th><th>分区类型</th></tr></thead><tbody><tr><td>/dev/sda1</td><td>/mnt/efi</td><td>512MB</td><td>EFI 系统分区</td></tr><tr><td>/dev/sda2</td><td>[SWAP]</td><td>8GB</td><td>Linux swap (交换空间)</td></tr><tr><td>/dev/sda3</td><td>/mnt</td><td>剩余空间</td><td>Linux x86-64 根目录 (/)</td></tr></tbody></table><h5 id="执行分区"><a href="#执行分区" class="headerlink" title="执行分区"></a>执行分区</h5><p>使用命令<code>cfdisk /dev/sda</code>进行硬盘分区，选择gpt分区格式：</p><p><img src="../images/23.png"></p><p>接下来对Free space进行分区，下面以对EFI的分区为例，SWAP分区和根目录分区的方式和EFI分区相同，具体数据参照上一小节中的分区设计表即可。选择下方的<code>[New]</code>：</p><p><img src="../images/24.png"></p><p>输入分区大小，512M：</p><p><img src="../images/25.png"></p><p>选择<code>[Type]</code>修改分区类型，类型选择<code>EFI System</code>：</p><p><img src="../images/26.png"></p><p>SWAP分区和根目录分区的方法如法炮制，最终分区结果如下，选择<code>[Write]</code>将分区表写入硬盘中，然后选择<code>[Quit]</code>退出即可。</p><p><img src="../images/27.png"></p><p>退出后，可再次使用<code>fisk -l</code>查看分区情况。</p><h5 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h5><p>分区后需要进行格式化才能正常使用：</p><ul><li>EFI分区：由于这里使用了EFI分区，因为EFI分区需要FAT32文件格式，所以需要将其格式化为FAT32格式。</li><li>Swap分区：使用 mkswap 将其初始化,使用swapon激活交换空间。</li><li>根目录分区：格式化为ext4格式。</li></ul><pre class=" language-bash"><code class="language-bash">mkfs.fat -F32 /dev/sda1mkfs.ext4 /dev/sda3mkswap /dev/sda2swapon /dev/sda2</code></pre><h5 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">mount</span> /dev/sda3 /mnt<span class="token function">mkdir</span> -p /mnt/efi<span class="token function">mount</span> /dev/sda1 /mnt/efi</code></pre><h4 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h4><p>为了提升下载速度，这里镜像源只保留清华源：</p><pre class=" language-bash"><code class="language-bash">vim /etc/pacman.d/mirrorlist</code></pre><p><img src="../images/28.png"></p><h4 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h4><pre class=" language-bash"><code class="language-bash">pacstrap /mnt base base-devel linux linux-firmware vim <span class="token function">wget</span> man-db man-pages</code></pre><h4 id="生成fstab文件"><a href="#生成fstab文件" class="headerlink" title="生成fstab文件"></a>生成fstab文件</h4><p>fstab文件用于自动挂载分区：</p><pre class=" language-bash"><code class="language-bash">genfstab -U /mnt <span class="token operator">>></span> /mnt/etc/fstab</code></pre><p>至此，ArchLinux的基本系统已经安装完毕。下面，我们进入安装好的系统里进行一些配置。</p><h3 id="配置ArchLinux系统"><a href="#配置ArchLinux系统" class="headerlink" title="配置ArchLinux系统"></a>配置ArchLinux系统</h3><h4 id="切换根目录到新系统"><a href="#切换根目录到新系统" class="headerlink" title="切换根目录到新系统"></a>切换根目录到新系统</h4><pre class=" language-bash"><code class="language-bash">arch-chroot /mnt</code></pre><h4 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h4><p>更改时区为亚洲、上海，并同步到硬件时间：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc</code></pre><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>使用vim解除<code>/etc/locale.gen</code>中的<code>en_US.UTF-8 UTF-8</code>和<code>zh_CN.UTF-8 UTF-8</code>中的注释，运行下面的命令：</p><pre class=" language-bash"><code class="language-bash">locale-genecho LANG<span class="token operator">=</span>en_US.UTF-8 <span class="token operator">></span> /etc/locale.conf</code></pre><h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><ul><li><code>echo arch &gt; /etc/hostname</code></li><li>编辑<code>/etc/hosts</code>：</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1       localhost::1             localhost127.0.1.1       arch.localdomain arch</code></pre><ul><li>安装<code>NetworkManager</code>：</li></ul><pre class=" language-bash"><code class="language-bash">pacman -S networkmanager network-manager-appletsystemctl <span class="token function">enable</span> NetworkManager.service</code></pre><h4 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">passwd</span></code></pre><h4 id="安装启动盘引导器"><a href="#安装启动盘引导器" class="headerlink" title="安装启动盘引导器"></a>安装启动盘引导器</h4><pre class=" language-bash"><code class="language-bash">mkinitcpio -Ppacman -S grub efibootmgr intel-ucode amd-ucodegrub-install --target<span class="token operator">=</span>x86_64-efi --efi-directory<span class="token operator">=</span>/efi --bootloader-id<span class="token operator">=</span>ArchLinuxgrub-mkconfig -o /boot/grub/grub.cfg</code></pre><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>添加用户xxx作为日常使用的账户：</p><pre class=" language-bash"><code class="language-bash">pacman -S <span class="token function">sudo</span><span class="token function">useradd</span> -m -G wheel -s /bin/bash xxx<span class="token function">passwd</span> xxx<span class="token function">passwd</span> -l root</code></pre><h4 id="配置pacman"><a href="#配置pacman" class="headerlink" title="配置pacman"></a>配置pacman</h4><p>在 <code>/etc/pacman.conf </code>文件末尾添加以下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>archlinuxcn<span class="token punctuation">]</span>Server <span class="token operator">=</span> https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="token variable">$arch</span><span class="token punctuation">[</span>arch4edu<span class="token punctuation">]</span>Server <span class="token operator">=</span> https://mirrors.tuna.tsinghua.edu.cn/arch4edu/<span class="token variable">$arch</span></code></pre><p>执行命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman-key --recv-keys 7931B6D628C8D3BA<span class="token function">sudo</span> pacman-key --finger 7931B6D628C8D3BA<span class="token function">sudo</span> pacman-key --lsign-key 7931B6D628C8D3BA<span class="token function">sudo</span> pacman -Sy archlinuxcn-keyring</code></pre><p>注意，如果在<code>sudo pacman-key --lsign-key 7931B6D628C8D3BA</code>处报和时间有关的错误，可使用<code>date</code>命令修改相应的时间偏移量即可。</p><p>除此之外，还可以解除<code>/etc/pacman.conf</code>中的<code>Color</code>和<code>TotalDownload</code>注释。</p><h4 id="安装Aur助手"><a href="#安装Aur助手" class="headerlink" title="安装Aur助手"></a>安装Aur助手</h4><pre class=" language-shell"><code class="language-shell">sudo pacman -S yay</code></pre><h4 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h4><p>这里选择安装KDE，有其他桌面环境安装需求可参考<a href="">这里</a>。</p><ul><li>安装xorg服务：</li></ul><pre class=" language-shell"><code class="language-shell">sudo pacman -S xorg xorg-server</code></pre><ul><li>安装显卡：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S xf86-video-intel  <span class="token comment" spellcheck="true">#intel#</span><span class="token function">sudo</span> pacman -S xf86-video-ati  <span class="token comment" spellcheck="true">#amd#</span></code></pre><ul><li>安装显示管理器：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S sddm sddm-kcmsystemctl <span class="token function">enable</span> sddm</code></pre><ul><li>安装KDE：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S plasma kde-applications</code></pre><ul><li>安装open-vm-tools：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman -Sy gtkmm<span class="token function">sudo</span> pacman -Sy open-vm-tools<span class="token function">sudo</span> pacman -Sy xf86-video-vmware<span class="token function">sudo</span> pacman -Sy xf86-input-vmmouse<span class="token function">sudo</span> systemctl <span class="token function">enable</span> vmtoolsd.service <span class="token function">sudo</span> systemctl <span class="token function">enable</span> vmware-vmblock-fuse.service</code></pre><p>至此，<code>reboot</code>后就可以看到KDE桌面环境啦！</p><h4 id="配置xdg用户目录"><a href="#配置xdg用户目录" class="headerlink" title="配置xdg用户目录"></a>配置xdg用户目录</h4><p>一般情况下，<code>~</code>目录下会有<code>Downloads</code>等具有特殊含义的目录，可以使用以下命令自动生成：</p><pre class=" language-bash"><code class="language-bash">yay -S xdg-user-dirsxdg-user-dirs-update</code></pre><h4 id="文件系统和gvfs"><a href="#文件系统和gvfs" class="headerlink" title="文件系统和gvfs"></a>文件系统和gvfs</h4><pre class=" language-shell"><code class="language-shell">yay -S gvfs gvfs-mtp gvfs-smb gvfs-afc ntfs-3g dosfstools udisks2</code></pre><h4 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h4><p>将Windows中的中文字体（<code>C:\Windows\Fonts</code>）打个压缩包发送到arch中，存放到<code>/usr/local/share/fonts</code>目录下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/share<span class="token function">sudo</span> <span class="token function">mkdir</span> fonts<span class="token function">sudo</span> <span class="token function">mv</span> /path/to/Fonts.rar /usr/local/share/fonts<span class="token function">sudo</span> fc-cache -fv</code></pre><p>推荐<code>monoco</code>作为终端字体<code>yay ttf-monaco</code>，编辑<code>~/.config/fontconfig/fonts.conf</code>：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fontconfig</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>serif<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prefer</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>Times New Roman<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>SimSun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prefer</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>alias</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>sans-serif<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prefer</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>Arial<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>SimHei<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prefer</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>alias</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>monospace<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prefer</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>Monaco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>family</span><span class="token punctuation">></span></span>SimSun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>family</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prefer</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>alias</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fontconfig</span><span class="token punctuation">></span></span></code></pre><h4 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h4><pre class=" language-shell"><code class="language-shell">yay -S fcitx5 fcitx5-im fcitx5-chinese-addons fcitx5-configtool fcitx5-pinyin-zhwiki fcitx5-gtk fcitx5-qt</code></pre><p>新建文件<code>vim ~/.pam_environment</code>并添加以下内容后<code>reboot</code>即可：</p><pre class=" language-bash"><code class="language-bash">GTK_IM_MODULE DEFAULT<span class="token operator">=</span>fcitxQT_IM_MODULE  DEFAULT<span class="token operator">=</span>fcitxXMODIFIERS    DEFAULT<span class="token operator">=</span>\@im<span class="token operator">=</span>fcitxSDL_IM_MODULE DEFAULT<span class="token operator">=</span>fcitx</code></pre><p>重启后，在桌面右下角会出现小键盘的图标，右键configure添加Pinyin这个Input Method即可。默认的输入法切换快捷键是<code>ctrl+space</code>，可以在配置里自行修改为<code>Left Shift</code>。</p><h4 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S v2ray<span class="token function">sudo</span> systemctl <span class="token function">enable</span> v2ray@xxx <span class="token comment" spellcheck="true"># 假如配置文件为xxx.json</span></code></pre><p>使用<code>chromium --proxy-server=&quot;socks5://127.0.0.1:1080&quot;</code>可以使chromium临时接受代理。</p><p>我们这里使用的是socks5代理，但有些应用可能不支持使用socks5代理，这时候对于命令行的大多数程序，<code>proxychains</code>就可以提供帮助。</p><pre class=" language-shell"><code class="language-shell">yay -S proxychains-ng</code></pre><p>编辑<code>/etc/proxychains.conf</code>。解除<code>quiet_mode</code>的注释，最后一行由<code>socks4 127.0.0.1 9050</code>改为<code>socks5 127.0.0.1 1080</code>。此时，在需要运行的命令前加上proxychains就可以方便地使用。如：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一些proxychains的例子</span>proxychains <span class="token function">wget</span> https://google.comproxychains <span class="token function">git</span> clone <span class="token punctuation">..</span>.proxychains pip <span class="token function">install</span> -r requirements.txtproxychains <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>对于<code>proxychains</code>也失效的情况，可以使用全局透明代理来解决，借助iptables可以实现全系统的透明代理。首先允许IP包转发：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> sh -c <span class="token string">"echo net.ipv4.ip_forward=1 > /etc/sysctl.d/10-ip_forward.conf"</span><span class="token function">sudo</span> sysctl --system</code></pre><p>接下来下载<a href="https://szp15.com/">szp大神</a>写好的透明代理脚本：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/bin<span class="token function">sudo</span> proxychains <span class="token function">wget</span> https://raw.githubusercontent.com/sunziping2016/tproxyctl/master/tproxyctl<span class="token function">sudo</span> <span class="token function">chmod</span> +x tproxyctl</code></pre><p>最后就可以使用以下命令开启/关闭全局透明代理：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> tproxyctl start<span class="token function">sudo</span> tproxyctl stop</code></pre><h4 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h4><pre class=" language-bash"><code class="language-bash">yay -S zshchsh -s /bin/zshyay -S oh-my-zsh-git<span class="token function">cp</span> /usr/share/oh-my-zsh/zshrc ~/.zshrcyay -S zsh-theme-powerlevel10kZSH_THEME<span class="token operator">=</span><span class="token string">"powerlevel10k/powerlevel10k"</span> <span class="token comment" spellcheck="true"># 修改~/.zshrc文件</span><span class="token function">source</span> ~/.zshrc</code></pre><p>另外，推荐<code>Hack Nerd Mono</code>作为终端字体：</p><pre class=" language-bash"><code class="language-bash">yay -S nerd-fonts-hackfc-cache</code></pre><h4 id="安装常用的软件"><a href="#安装常用的软件" class="headerlink" title="安装常用的软件"></a>安装常用的软件</h4><pre class=" language-bash"><code class="language-bash">yay -S <span class="token function">bzip2</span> <span class="token function">zip</span> p7zip unzip-iconv <span class="token function">unrar</span> <span class="token comment" spellcheck="true">#安装常用的压缩软件</span>yay -S nutstore <span class="token comment" spellcheck="true"># 安装坚果云</span>yay -S <span class="token function">git</span> yay -S openssh yay -S typora yay -S vscode yay -S google-chromeyay -S tree</code></pre><h4 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h4><pre class=" language-bash"><code class="language-bash">curl --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> sh<span class="token keyword">echo</span> <span class="token string">'source "\<span class="token variable">$HOME</span>/.cargo/env"'</span> <span class="token operator">>></span> ~/.zshrc</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七步洗手法</title>
      <link href="posts/10d4fadd.html"/>
      <url>posts/10d4fadd.html</url>
      
        <content type="html"><![CDATA[<p>美国疾控中心（CDC）建议: 每次洗手至少20秒，以最大限度地减少细菌接触，避免免疫系统崩溃。每次洗手的时候，唱两遍“祝你生日快乐”这首歌，基本能够确保你达到了20秒的目标，洗手方法则可以参照“七步洗手法”。</p><p>记住口诀“内外夹攻大力丸”，全过程每一步都要认真揉搓双手15秒以上。</p><p><img src="../images/30.jpg"></p><ul><li>第一步（内）：洗手掌 ，流水湿润双手，涂抹洗手液（或肥皂），掌心相对，手指并拢相互揉搓；</li><li>第二步（外）：洗背侧指缝， 手心对手背沿指缝相互揉搓，双手交换进行；</li><li>第三步（夹）：洗掌侧指缝， 掌心相对，双手交叉沿指缝相互揉搓；</li><li>第四步（弓）：洗指背， 弯曲各手指关节，半握拳把指背放在另一手掌心旋转揉搓，双手交换进行；</li><li>第五步（大）：洗拇指 ，一手握另一手大拇指旋转揉搓，双手交换进行；</li><li>第六步（立）：洗指尖 ，弯曲各手指关节，把指尖合拢在另一手掌心旋转揉搓，双手交换进行；</li><li>第七步（腕）：洗手腕、手臂， 揉搓手腕、手臂，双手交换进行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人生的智慧》：论一个平凡的人如何幸福度过一生</title>
      <link href="posts/c8d89310.html"/>
      <url>posts/c8d89310.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0da2c14621b23b478bc92abaa0476b8353793b1ace938f12c257c42aaaad3630">c0ba7b6cb111dae6cc0727b71927902733b35ca4c9ecb985b69a0a9bcb8ba05b639cdae62db08662534cff88ac339c62401d3d898e3f446d5a791354f219a379940a83e13f39396a6dfb1755b63e0a80dee8f3a2ca056751c1d21b50400f4a8b6719de42c03267a6f2559fb1923cfd8bfdbea5eba110ec7816c9dd99a72b1877ce35aea0fd9892867bcb6f7de9440d894f8a82ee40e89c29c8805ed3694cc77ceae70dd2f59cb7f88611c8bf7333ead3a35c730ff0d46ea27211cb9b81f40205c28b2ab3d825cc499baacfe059618a87b99a95f53ea25254be0b16c0e65992e637682d7c1a4a776a7c5332a8cf6c8a8ae11e7eef9921e31f43255d0cf148ec6f83d22c733e691485ac57145f230a62ccf0ec673afd6af93119e697991ccc20fa4d715b2e5838a9c6be6414b15681312712973afe20f21b99b8bad7a07c3ad8c5a15700cbd57fa554a498fdf5b02c06225f75162df376de4735edfba9388befec11c9ae2a7ee28ec3c1e091d6551018c20eb2f5e7debf914bf1a92a64bff3ba76661801933e884181957e468521ba6f8de9a3515cf67efbf44e9a52a3054e76dfcc0ef1d07db276c84833c07c908c50e3a95694a17af09211f4c2d226ce37ac8c313af38c07517ee5bb82ef2bbd6bc6d1c0da93e7a075b6850442fb106eb768b5f655e218e2a6079e08e4abcb9bc053b3a07c5a1f56d9cdedc1ee6702b409a1c064f9fe977bf046b50ac8f3211c5ca8364916f8109aba4ca46323382922552d99add854fcc9a6d4bc7e1dae20befe17b9ffc2f2d9bfd9e7014687dd7fbbbf88204283d6f4242a90adfb7d41546a24fd44a1ff1c193a7524f64bde99cad15502e85d6aaba03982fe81b49e600ed246325dd35c2bf691f5f6eb676ce3b0732811d63efe5d0c2f0939f0ccf55afaa8d29ce1e674a090da9c6d62f536863a93efdbf2f0240e8fab6406f64123e759037c53b6a87a7d40fac4e1aa94817cbfd5fab42ec563edf2933b46ce5fc2fb687bfaa4dbe96fb2778fb8e2b6ce20caf50137b2bfb8573cbcdc36468e3cdc22647244e1b6587f114fc85fca6287ff75c480fb1c19f64d91ce934cfd007fb753d90e7593f359315f9a8df104476575db45e600b9538e9bca82e5137b733f4019bb9c4a627616842f1e54c761327415185f78f3ad08b36a337a1c4721f7083fbd808a5a04603eef3ed2177078cbb5cdac8f0aa7f71a3b4ad7ae052250ba82f59222fa0b37c6797b3d0dafff63ea057c425094a4b9257f35715d4e599101241508fac107b0b8dcf27efacbc145447d872e21ca3ba7c6ee89765ffedb5800e0983ccf6cad8c559e4a15a0f344839ca57243bb13a49d7b221c4e2745f42d0eb38cf8ccd323cea409aaedbe9fd36c77db97aeec3dc3ccfc89e8e2097aff59ebdd9985a2599a8429e5dea523ff9fa7c7fff5c895e0d673069b62cad880941f3adae9e53f5adda457c053f5d78fa84a131bd4065c8974b567d940ec2eccf4ea191966b56435dbb63a5c86df425c1ecc5c8d4529ae683b23af016477926dcbf1d1c30fddbc575bb813c66f9e7eab2d87dd094cf48d05210dafd4c56c76be3fe3b6c8dafa44c5c756c5507766f85b0803bf8070a3d18cf598eba1adef85ef90fde2d40e088457ffea1b9f6bee8c12602a91712e96513b44f067c00c658f8fcb80c6e1ca2c6d3861ba778f6318b6e1e76f2ece76199c44ca847b79faa7ad3379e1cd24407639cdffdf9da368f043f4a1824c3238177a5984927f3dfd2f625fe0b8fb23ae8a14e030792989ac4c23df496623a9407802879b357bf5dc045d1c836cac6acbc2839fad210922fb9e4451617c32c37e9aeb47d9bbacc512b6b826ac15c9379acb9cb9ea891f5270bf550c18c609dccf117927403744b8850911813bbcca17dc9e3964c62756ed1a8444417f1800616c8632ebd99c4aac11b86ac5789de388781cce9cae89f507fed947571575587fd1136e09f4e530ea524c9567199c660831a30a75da7b094c483ff1ce94143683253812de40e9d107e9bae141ef4076784d3dbb7f4b7dc2ae2f7f1b4059713588aef263aad6ec1b3024b6b03565acc9de1236c2ccdeb9c7e239939712dfd6314e84c831ce7179ea8c703877e9142af818d60cb914edacdd57b732fec7249b3edeee6d95f72cd436a1b402882797aa2673b55dd1482012c825402df9a5034730339d9fc49ee6d6033d84b9814838cf196bad9390d76c939ef65bfa1d547a4bf24da60f349674e2c683ad86568de164cf31d6f9e2692eee98d701ef412a90893a18ec8f01ef5f8fed3ed4060e490405363372e8c59a3523b73fbace1bf5642f6e8279687eedd9e63486c644d9680eeafe651eb5bf91c66bcb5f16948c85c3c8dac82429e27bf63bff8752ed9124af8d667e347f6a8b9157ddbfe561adf57f630975ea5f5d90f56fdc073155de91df4b3f86c1c12f0e57bcaf5e3b20ea97650bb40667285774c374d516936bc0bc85dec7d9809a210e36b8b66a45a25e9eea40874abceed3543367e1bfec0a6253502abe79a04a174419349b0f370b24a61e019cd480e90f0524d380d32147232fb73e1db80f2d638cf74c18b0b608aaeb1ba6a19772a87b086baa881196f8e7dbeaf2093fe5cbc311787296de8fca51a6f894c51257fec3bf1e8c9312389455153a9935d173b9ef05df92255c88621e9f755f1677b4c23105b480b868e8fc3a4edb808064b7f5fd12ee8ede8cf137f9c12b5b0a542a9d7b9e16e6e8a1bb0fd014630edc39d0abda7c2dea96760a59081cf68d6cb8c78153200608c486006f84e10224d3d315d9d60da938fc8f397ec21cd1ad1c9dd57328573e461775d543102d48eccb3f8d496be0f0c2b277ac3cf0f80792894c23d1d584d1308027b6aeb01b2578e171b821b77498c8f2b554171b96864daed2f4964da535710a48a82172ae147597d4ae80a69b40967722e47692c20048e085e7372efc323eedd2fa9c30db017fdb3a2daf47c30f77d9c49fb19657394a2609c55433b2b48653c8a2c37df9db68a7fa976c8f3ff204d73ba60343813fdc2ca7757f1402f19d6f4e1b45687275ae4a97711b43eaa16047ce6aecfe2d2de926879b12e0e02959dac5c9437452c62c8af38ab321d82edceadd6d6dd24030a212b63727c2399bd88dcc60049048dde6d235a193296be973002aa189c96bffb522987fc007ef5d681638e29f016cb393571724f0e85cd15cf9c17e82d43a14daf862912a60ce87f5bfcbd76d9fe2320c7fccf3697207ccb5ead133c49c057fcf9a5169b8820dbc794281f2444b8057f5b2898a0677f44c3cd2e558934194f3fcc3f5d2e6ab67d51980f5c779708500e6041a0a54cfc9eebb4b48b8598a52f701c894b575c44efbfc4efa10838db391f8a3e1bfed9efd9029939477a5328a3698504be677e782a0a64ac8c9a6f21a05b7303103db75f874bca59d5fc38e69960edd7a688a8ca2bff72a1f0c8463b4d5fc41ef58e433bbe5655d975bac828e0ac4ee6b2ad96956763351a17c3fbb7320a052f1be11d3787715b9e911bf14b057b17c3738f46a0fe96266e04096b75c1101278c31645a19bbd7f6194d3854752a911f1cef2b3f4caceb5b992167247f4f48e634427d8a082101a162880c0b777bc599e2d11415fc11f8c8a7a7c6deeb150ba2ccb93073b37246cff823e2adeb3c49cababce3bbfa17a17034eba106a42ef481adefd1ef67d8506bce1bb6cec0aaf19c14c003d6adfed162d538fce72dfce30d2857a8d5c605645e2809193856297705e8491835f163868e586d422c68d4e8320a8e58f4ef646ea1dd9f1ec79290cc5d9e8124d2c446981a046e836187088f8cfe7097b345ac3a0b7d94e5f2da197e9f04945f95f12c3ef17de157c3e48b02e93c5aa1f2478f6844fdc2b1d098bb464603e1ef810aac323a31367f4888f4f15d49a1244d38705c9d6c172b4d750ca69ebc93aef215a9d42b33c280b32879c4bee8bc3e796747f3ff6892ff01d89529332dcaf8a9f8b1efc04908bf635941cfd55b64981be66de29805d02d87b6769546dc720cd57718243d515407c162fda91fb2cd76b262eaa968aefa04a935b63a1b9fd1fdd9640405d84c9d2a001a4bba29385deecac6203606cbdaeb9cb89252d2e13dd94c094d3224d2ffa88636eca9b8eba9780dd64c902571db293aee35f99f97e520161f339b4983299fad682a0e1113cbec7a47431a307b6eda4372b07c30fff7054822c19b0489c898a55985f67725cb7fe3d5e124618391bd17aa266dd6109c153dbe91b41d84e56db0f854db3d7a032a279008f3fc3796ebfd579f3a26017c4afa2b1489aee097cbb60031855ee121cbe8d669331b85a576e4765dd364dec0bcd4be015fd03b08284b1a5e8c55d0ec7c3acee359f433467ccaaa9f44e60f782bb61cab8337ed7f07a379e0b1fea926e84953a99084968a3940eb642cab958c392e8eec904a0ae4d77beb1fbebd9a91842adbec141d381179321482f007c402c31e734b6a54f796e8b5b674b09186784f52cbf33591e933c25682496ed66217027d6e9ab5c111106613fdd0ac4ca639c3a0d1c0b3894dc3a0edbda95c65c0eeda2cfcede7e5cad2280574f4b34bc158d978cd2088bb1d1e71aa4a6023d225e39cb1d461164cd85bb38d89e7a4387115c01738e507a6c62765c944e4c2da70783a5e8ad3c08d864cf7138a094488e89a7f50c77ac33a43869ac96cfde9deceb9bbad543bd50906cc83a3c7d09fb36cecdd80baefd5d2f8e5016115869cfcb96161d640bdf30f9f348f6e047b861554468a5102d2f771a5edfcca8fd2769f50ebb839101d1b13b0eb9cdfad5ff9a1569d122b6c76380e13b665aa2510ecdc93f58ffc5f43f26ba7c345ab5b0788fe8c474cb1f19e5c017bd2c0830375b184deb9f08ce25ae37d6241b7a0c9f56e3163ee9e337d99a8b5e9debb6812975bd356e79e45d5f523140d22540304182e84b8167ee38d74130649262399ab317a458bff934edaf27ac81b2996b45bc75638766aac273affb6543777bd7a1c86c1f793bc44dd97b8eddfa3b5417328c11bc320c03f91b27e5de25fbfb7cf27722c71b181c90b26b09d1be2e788db41272eb84b8bc17f63e0eed8687b2250a8086bb4d540134c677237949257014e1df24c2798826b2b956952a0e3672d17550c6005da0736decbbbf35bc460364e3b389aefb3b0170602198f7a2550698b79995ea257f1acee8975ba1877e824b04492002d834851c14eaead8f4c2e6609ee8171ce238ce450fa58bd5146e713e3494f1842d66b41ea46524c50d0545cc2de9a98b3a72cd1adb0d8b2531147b14247939daa0682787967d2d04f33b58480444c91e3d32292d50055dba261079d241d1278cf8f6c93004490e0b0185eb88d56eca03f2b41d1a9297aaf238019bd3df7e925caf2905cc78ed4182255314a391076796c575a5de9a3acdf4b5bee15e62b596f95e8f0b84433718660c241c73b85359106f20f9a111469a0a09901ce5ed5a36ccef92ea14a2440c5e813b5e5ec1f65e74bd5f82ac31bba14c29e3a4ebac0e650c0a981c9f9757c6b877812cefc35b95c38d7330dc49c17ab47f1964d77a929181374ce5bdffcb5dad965f339b1a9b01aa468006b0e45d826e41af575b50eb7b8c6f45cbd6c3120349333d722bb7f3e45160c579605c4f96f67a58961470c7aca9722c6c1cb15ceea1a38eba12d8df788d65ccf8ca5928cb6da890193475e7c0c83046ca390c5f127fbc0bd0e2c8f3bc6eb6d4bebab7ba9eaf97cd9a4a226fdebf96a97c84cdaa794d340e11ee2b545ce407d68328870414deda5b4d22d833560f26b4e9ba567a2222e4d04808816acc6d3cec8b31af5322ddd9eae707756f6d9690ce13d51519b8f3735d65bda70c6aa9adc576cfad57d6464c0db2b8f52f9661bd63257cfec6a69e6910ee2ea0d05c32fef40c04aadd6d45d6b886a9dd4a5491a98f6b385f6f9099a6329581db1eddd34cd103cc3bf13d24fed7e3e470adf7ad057cc254eb5aea0e5a3a9a2dc816b1143e4eb11f95980950da926ec2b12d80957b4bef13b36d2f72eb9ff2a8a4caad970644dc2afe3486ef3b2e80dbe1d6268db6f8f3c2f2152ba545490b3b89e14dbcc6daf18350861b4e05a56ab8ac7afc4bfbe5fafceb5c075a4807ba641f3cbbcbccd6a1105edb331481f2a3139418ce1e6cc0ceee4fc700499d02811c9656e8c313a64db0ce15cd4f34f22f3b8308209a4d6f7bd7eac87979842d09db3921f1c552796dfc0af388a4ba29382143f14c6f025237d8ef3155e6f78f3979c6bafa54384b3ccfb67a16b5a7fb72d3b4887aadc884d59d2083c011cc99b20fd7c1d9fbf4c649939a697489686ae754de040c0fd53faaac277b38b1941406033225d5a667f8b747c6877b8e7606061f821ed0501b5869ded503a067d4326c04ef98dcc767083a4b883106a5bd4ed740361936142ca8ce4fc5395bb11c6cbe8fe213a49199b5e027ac5dc7118a2ae04522a0d6af3046e6d62b9ae2f049ada179770b6c0d75675aa3b6c9e9eb3197eb2457d4cc47f0e890f88c127ed19bffbb1b05cce773c72d94d7b9639c4067f03857da5b2df3da80aa9ae6b6097e01919a50bab3c801c21fdb26e9e4507354cb46d1026376e0f756ea82151a0c90c6d60834a4155fa778babb85fe58885083751caae7b3146cd0006b12f185a1751d89d0ff87ed460954de6de3926cad61f97bdfabb8b6b4d8d231938eb4a22eecac6a4f89ec47ef6a10ed61beb880dce8bd9b456547286ec9389fefbfe807def128fe74bd5b55f8d23cb5b0d6ff97e722fb7886561d3d036d5233f9c07a65a36b943d138e7744d2cdac4ae891a9c0f9d691fe588a948770dac2f87a548463ba6c4c34d0780ffc417cf27a9010ecd5e41e16ae783e8e062efb0095608b02c6ae32c64514afc57d054a0561806e88457edbf821f6d5f2d8b1143dbdf03de65b17db1b321b0c2d5be99cdc35a8bd6ef7392dd8ac0bfbf8690159419e158731daec2dcc4c668d6c7d6e9aeece9cb48952663220698d90b6f1dbf34eb0c0ce1b885d3766f8561aa549cba435b139266f9c85e4c5ab706225be10041c6e31c1dc9e75fd8eff3142b0e2c4b1af662dd8c57791bfeaa925aa6f29eee0aa512991275ff0f84d1fdccaa263ffa3f2797b52e3ee74ef703ae5cc2415e0a8cd4bba87f940e5118a4a7673ebbb916ceb9e1f52308ffb0729bc4a391d717f0e491af34a7ac0d5211a15243ea09fa8f4e6c84fe8d8762b984d8c7b87c056178899c19db0f0ad9fba597dcc2700c37c8bb01b1552df833d5dca7e46f5939ec32755c8cd2fc2d9f4d73ad76c8454b01b5f4146f118b559db7c8c76b96a0732c37882c1a344c8d830da4e170d3277a32143b6eac058039e7ab4cd78da8e9be618daa9eab7c6cde940c6332c53a3d756c0588ce591fbdbf2d13b4eb7486ab09b3e3dbff6358e850a745a4c6db993f1000ef7d7c4b58c3f973cb5a80cab7c9e5e0f79dd857f8721ed142fc83c8280cda97b09c3948e20bc715f4df522c1518223131fd7aa89e20c59fca2ce519dd939b8502c60cb8b9e2444f459d2ec1c6fe58d24f6d50147b024a1782a117594c076884c9d7c0476efe5f9c18c1e4691ac074885870c9191f7cccca040e102e32534e60fdcc90c49c7880807b7a5ff2f9106e68f7b818a0b3021cccc9b274821edcff757fe78d6312903e154752a06a2145693101b1be7a4d74dd2981f54a0fdaafc49e3d622e237c950b1126cb3a18f5f8ffff1359a770632535edc54d3485defedb797759cef272aade1fb3fc1188f626d1576abd10b2567ad990cbc36bbe1bb76a79e5291a509d1aaff0e3998cc2e698abf2344efbc667775e0a1159439de4786d50552fc0195cd7886ac682924ee0ff71bd542d28dc9646b383a3df964d706f1d9361943d601d1bb85c2d057e5969d166b8c00aaba168a862af630ce65fe32424c0f8439acf51707cd3aca39c35370d29aeda4b7284db37dce7ef6f43b7b0b8f1c9cf90a2c85a43f9e16d628b3e2256f91448f15e325a4634c8d901dad52ee17c34e8ae3fbf405e5e11a915a75bd2484475326e7c14bf45317f04b243075a4da8f33c2a6ae594941c44ac408bdcd29c5cdf369c9fd0bb779ff5b4468a90d2c1f8d93177d0f57ee6452aab43725f38e3644a8d1708884340ee6f49162466b847a9b98d2fedeff226159bdbfe8f789f2a0cd713def945d4f48119adf6f117726fff43fdc514eaf951f797bad403fac544926386aed8d9af8a3d89ba3d17a1042c3008d7d0538065fc92b5465ca7f9f28f02e073da31cf1d87efdaed2bab37cddf7d54e1a03c9fafe76be19946512fa301df58de57a39d7f0b83d307c59ba00129e88f08fe5de47118f8b731c909a5f9fad8a9bd930cc63eb1a420e8642a2603877bebb6816e431c930e0aa88d3bd660667e2016f1ac3254e64563d014d34a72598ec5cf5f583ae18eee5ba335b17dd4afc1eb0950267e9bb762c5998f09b8a72499b3475471f264038290fe0fdda62ab7bbe695752ef79cfb0df1fefa3ba12fd079885c880ec1fccdd6f80e00208c5b2e45085f797cfa7b89e67d3348ed028ce8857e47152d9e6d6b8bbc26ad834108cad3a409f48e5bfdee4dcbe1d8145b3bbdfaa581699e090eb9e03f908f0779b25527221b8882bf570974e72556cfa4a49a3d07a4a0ef86d2f3ff8b37ae5242c07640baad1eafcd82738b16cee8ce995de090f2cec04968871fd0b1243154466cca7e5ff281ecd820e6fb8fe7b98bfd2e88ec9304f1fccaf6cfaa3e45a69f134a2de01a7798bd6bccfeda749b2fdb7c9fe587179295810b68a3afeab1302f93cbe2d69c6d560a11db59ea0bc13802fd86160a168558ed01214505579fb5273629392d8f96212564b09134e7296640550caa6cf704928140114389572c91a4e795bda1da2881c26f1b7cec52bd0b4d16b48e8867cd527b3bfe25eac8d068d5af8d57f2eb92cc579268ce42f86fb46860a32ec4aafadf59a3a70e62b0f79fd8d0b43164f09f1ddf93e9bbbece24a029d0faafdc3148d654279aa0d6b7c0b6e830ecd210bf61d323743bad9e937d52a05feb5a43dd803cf07b3797c45cc986311dd1c3688df44b4a738667d79c7c7bcd6daf16508d6ab2eacda84c38ef4724e95365b73c3958555ac612bd3141bd8627e2845bf13a2e1ac1bed88cb3d12db6597d64d50b48f0c7af0a676cb159a2b51557cecdfef89a9f79445baefe1c79072e057c9c04628546f7267a11afb6aad8bd22d27b9bae0166c9941a4a2852d59bfe22e3dda6b25822e6d407dd214110979253dc748d2d3357ade04fae225752969dd754ee53b1f30d6727c4c9dc5085ffa2df0044c49dbe5ba6404177178a03d82cce38dc98527face788dae072508071342a1d32d602adb6d2baa45c0247b8e33bfe76cb7e740411da04e3327e7dc5d6e74ff670570c862ad091d2b5c5fc026c9da60b34902c667f7ebdd422df967a5fff6ddaa4befa8fe58b2f8f1a919c9c4b50ff2ba303bd3e789fdebfe18c39eefafa4483255d6513ef355adc138b7ae5cc9a1a86efa024668107dc0b3932f0e7c4a0cd5068c0f9edde2a5829b38fd48716da8bc6566b5d10f0f179cc54c302051342dd779d3ef8c7fe308e586bbc70bdcbf98e83cd0836aaacec6e53315fffd10c9064bce9789352fa4e8173f55d8258e50c6e4da96b2f7daefbf3ccabcdf43da98e4d74e3a792926ac2eacc6ad746420719153103d195d571500db41ab355c9b248133b15a898274c61e0007a703e60465509d18054fde7bf75e469d604dd32e35475c4acfcaba52eb784e873b7fdc25933e8e6e60116fff117089213c13dbcfdae446019561a11d5e2edb7cbac21bb2fe7ffcf15129b9a10e530197bfbed0e535dc9931f9ae286c2ac722cc4f54e4e6735f91e4b51949776a4492207b14d772640c04cb0af71ea4de9990505312a3344ea31ac2bbe6403aa30e6a86f38b81c6e52eb3fafb825c4da039a3a8ae5317d17a313b5958b1455ac17d394a72cc92190d5d35ef9461441d462f5a4b626fb7969293284f778958bb0664d11256071c66ef1bae1c1862e7b58064c4f4e8d8384d851435f53e74359f81300b209457c677abeaef7f97d7e58efcfa0f8a2f06562380e2b7376915ebd49541713eee7cf976380aec9bb2614938d77c230867bf98117e92530d8fca24f4f7a3fccef815a1857d8e218c9330a4b6113b89c026d3f22dad1980b2d213c912c5719f01df3e670214cb3bfb8e09c0d35e2abd02f5fd212bdd35bbf845f7793ebd5aab958a114ce7a39579a0acbf278e25f918431ba70435f942e49207405698c683fa77bf771e996f69fd70e06fcc25b085d1924839f5102ec486841460dcf410ff25f00ae4c53e69fb694d632ef85becb77cd935df359730d7a30ef121c718652ba09777ed5ea67016727a0667f8dd869ba3b8ec1fc5453d3d5715208772087f35b780321a6d32047e641a469c3ffd3969c2ae2ebcc8035645b688ea9cd83aa5401ab85a2563ae3ab91447fbccbd6e0f75270346679b96d371f2787042286ec3658ee1addb533c5e7c1e1d2b3f2cbbfaf623c65e2c23c06fafd5f7625f788e6d00b22f395be28c2ec051b64ff0a2dbb962a3c6fbccbdc56bddac53e3c424b0d5485c60c85ac078ecb82c5ecd6c5505b34f1f006f9e050b0f7b6126e4fbe82000796563f95fee05ada5d1c7add6b7ddafebcfaa176e9290592b6dc15b593433b9507f08678f4e4e8d936bb9da3073e3b2dd0bce875de809cd3354c0edb44508203269df1ce30ff692b3f9169485d0dd28bee1594b4f568886a953345151b684ce5f6e49eebbd3be97d6472c3fd2ee79ee4b75d1c47e10aac69754780b4e36671e059b1ca0754557e455ab9a7ca92ec4c1193d4fe58903c29a6c8fe97c15e5b7db81da483f60f8af41e410b78f474fcc60accb2a2f5187cf9f1628825c97de7181306ca6db045f4e8f5086937086bba05b5b29b1212a05def21460320c020b71fe8e914cce98e19aab35e0365d1a47592ca193ea5ce43a2f35a0e40c2606e0df1edffa8643d75096a60bac8e93d2546bc343b121ffa5959e52f8946c444967dc72fc89acd3892006f96d2ce782b99cbd074c46a80b1274bf3b74019087e03dfb3b59a7fa414428465132db7b0a74f42def1e3a04d362941c7cd963df888c219a89b7b84cedb0aba0ee9d148e45fa2fde8c54ca885a6d12d6fa7c5d3e6e477f7b5cbd41d6a8cb5f354237f2d6c8eb28967dc6781e80b164ffadda9abdeede2efebe0832d34a3e4f26ec967f971f0bc157d3c291414c67590ebb10cd624a00677f94c4bc35742c7b9c5dd7ac38182a7d848552b35d2a001359a9f3c95937832dd075999008182af3a6c2dff5ff123d718611c424b7fc9ec609538dee23cd2c96a4c2dac6e7a104b52f614a02dcd3f47e9596fa9ab784509f406fd58c506afd47e14f4fd8351300ba04304d6c358a36ad6cd6dcf15556a467d9c11fa71f1ffe2492c46c1aa22673207fe82c3e10c3c1f6b983f9af43670a1f4bd7844dbfb807b03f2b11908a0e9b259a75652e52e94ac94ab7608c5d753e6fb24a69a40e51486f7e91d29dc42b1ffc4e504b52f6f61203eddf19f3333c253dafbc313e99293a3525255e39ade1c66613e037fdfc66a07ebf267975b325446241a5b2bf44ff85eda0dac54d15a9738a92e08a9fc677b9a3e370b7ebb4c1e4c071201ff6ada4fe9852675f58d5d3ac7d630e62c4e8e1769d00fb9b3c68a979745d41fbaf948ba7274c569f6206c2097e4792a96ea6e983ee9b1694e2d46341385e5ba3424392b89b6a53fac19a75f706a5026c09e4e991296ee14681ad8856eea2426d15a6761d94837f104d92cc77caf51a94c7aea8cd8ecf00ac0b2335d1ac759dcd6f4f2b4db87129f1af7a2cb28f7d512cda30cb30dee1846a071d6d76f967851dce5e633b6a71328a09c16fdb770ff0712cbe6d92f7b14e32e5c39c464c5c2f292eed819c546a67eae3493f69bc4196a685b2f4bb12b4b8b6cda5ec2414d1275d5ef998b6a1eb4874fb4ebf7bc8f01944bb88e8e1dfbf17ccb419bb94ee79d42185bf2991fb0afa216f7a85fbdd0a03668698cc160d81fdcd4edaf2448ce144d0e3f6e6649ba3f1f82067f3d9bbd4cd6c30b0ed5a0cb46d3df3d4b716ca2c3be47bcaa9fb68fc9e7a535869d1bd31f4b7f1710bb56054444f468ccad1211e11401135a77346a2b8ebaa4fd4e38fd0862259d452a472d5c3d202d67a4bc76e673d6975b73f93a127fb6009c8d5950fdb26f4637b08b6331f3a339fd6ce48c1d64732b51fcb1a0793fbea521087dabce70b8dfd578bd0d0a55e1beab522bfab9a810ad27c897085efa1142753ba1b786efcb0fc27e53841c9f88ca6f4c5e516be6846004cd05a017d5513823dd983e7b33443b2709e8b837919237fc9e0ce4091d7c7fa7186d41c010c46fad5f5072e5b2517250f546ed59d813edd2b2f4b02f3fec72222e3715b55b4a0acb9be683c971e9248d0a76410c81154b99bdb4d11cd9ba3a57e056bd02d025c43e965e0407239a4ab6a0697e0b8a2632d5524802176300f8bf208ac0e8d5f99172f3e6ba12</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#11：错误处理</title>
      <link href="posts/38ae15c7.html"/>
      <url>posts/38ae15c7.html</url>
      
        <content type="html"><![CDATA[<p>错误处理是编程语言中很重要的一个方面。目前，错误处理的方式分为两类，第一类是以C语言为首的基于返回值的错误处理方案，第二类是以Java语言为首的基于异常的错误处理方案。也可以从发生了错误是否可恢复来进行分类，例如，C语言中对可恢复的错误会使用错误码返回值，对不可恢复的错误会直接调用<code>exit</code>来退出程序；Java的异常体系分为<code>Exception</code>和<code>Error</code>，分别对应可恢复错误和不可恢复错误。在Rust中，错误处理的方案和C语言类似，但更加完善好用：对于不可恢复错误，使用<code>panic</code>来处理，使得程序直接退出并可输出相关信息；对于可恢复错误，使用<code>Option</code>和<code>Result</code>来对返回值进行封装，表达能力更强。</p><h3 id="不可恢复错误"><a href="#不可恢复错误" class="headerlink" title="不可恢复错误"></a>不可恢复错误</h3><h4 id="panic简介"><a href="#panic简介" class="headerlink" title="panic简介"></a>panic简介</h4><p>对于不可恢复错误，Rust提供了panic机制来使得程序迅速崩溃，并报告相应的出错信息。panic出现的场景一般是：如果继续执行下去就会有极其严重的内存安全问题，这种时候让程序继续执行导致的危害比崩溃更严重。举个例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于上面的程序，数组<code>v</code>有三个元素，但索引值是6，所以运行后程序会崩溃并报以下错误：</p><pre class=" language-bash"><code class="language-bash">thread <span class="token string">'main'</span> panicked at <span class="token string">'index out of bounds: the len is 3 but the index is 6'</span>, src/main.rs:176:22stack backtrace:   下面是函数调用栈<span class="token punctuation">..</span>.</code></pre><h4 id="panic实现机制"><a href="#panic实现机制" class="headerlink" title="panic实现机制"></a>panic实现机制</h4><p>在Rust中，panic的实现机制有两种方式：</p><ul><li>unwind方式：发生panic时，会一层一层地退出函数调用栈，栈内的局部变量还可以正常析构。</li><li>abort方式：发生panic时，直接退出整个程序。</li></ul><p>默认情况下编译器使用unwind方式，函数调用栈信息可以帮助我们快速定位发生panic的第一现场；但某些嵌入式系统因资源不足而只能选择abort方式，可以通过<code>rustc -C panic=abort test.rs</code>方式指定。</p><p>在Rust中，通过unwind方式实现的panic，其内部实现方式基本与C++的异常是一样的。Rust提供了一些工具函数，可以像<code>try-catch</code>机制那样让用户在代码中终止栈展开，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>panic<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">catch_unwind</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"interrupted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有输出</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"continue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常输出</span><span class="token punctuation">}</span></code></pre><p>运行程序可以发现，<code>println!(&quot;interrupted&quot;);</code>语句没有执行，因此在上一条语句出发了panic，这个函数调用栈开始销毁，但<code>std::panic::catch_unwind</code>阻止了调用栈的继续展开，因此<code>println!(&quot;continue&quot;);</code>得以正常执行。</p><p>需要注意的是，不要像<code>try-catch</code>那样使用<code>catch_unwind</code>来进行流程控制，<strong>Rust更推荐基于返回值的错误处理机制</strong>，因为既然发生panic了，就让程序越早崩溃越好，这有利于调试bug，而使用<code>catch_unwind</code>会让错误暂时被压制，从而让错误传递到其他位置，导致不容易找到程序崩溃的第一现场。<code>catch_unwind</code>主要用于以下两种情况：</p><ul><li>在FFI的场景下，若C语言调用了Rust的函数，在Rust内部出现了panic，如果这个panic在Rust内部没处理好，直接扔到C代码中去，会导致产生“未定义行为”。</li><li>某些高级抽象机制需要阻止栈展开，例如线程池。如果一个线程中出现了panic，我们只希望把这个线程关闭，而不是将整个线程池拖下水。</li></ul><h3 id="可恢复错误"><a href="#可恢复错误" class="headerlink" title="可恢复错误"></a>可恢复错误</h3><h4 id="基本错误处理"><a href="#基本错误处理" class="headerlink" title="基本错误处理"></a>基本错误处理</h4><p>对于可恢复的错误，Rust中提供了基于返回值的方案，主要基于<code>Option&lt;T&gt;</code>和<code>Result&lt;T, E&gt;</code>类型。<code>Option&lt;T&gt;</code>代表返回值要么是空要么是非空，<code>Result&lt;T, E&gt;</code>代表返回值要么是正常值的要么错误值。它们的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// No value</span>    None<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/// Some value `T`</span>    <span class="token function">Some</span><span class="token punctuation">(</span>#<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">enum</span> Result<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// Contains the success value</span>    <span class="token function">Ok</span><span class="token punctuation">(</span>#<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/// Contains the error value</span>    <span class="token function">Err</span><span class="token punctuation">(</span>#<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> E<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>我们来看一个标准库中对<code>Result&lt;T, E&gt;</code>的典型用法，<code>FromStr</code>中的<code>from_str</code>方法可以通过字符串构造出当前类型的实例，但可能会构造失败。标准库中针对<code>bool</code>类型实现了这个trait，正常情况返回<code>bool</code>类型的值，异常情况返回<code>ParseBoolError</code>类型的值：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> FromStr<span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// The associated error which can be returned from parsing.</span>    <span class="token keyword">type</span> Err<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">from_str</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>Self<span class="token punctuation">,</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Err<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">impl</span> FromStr <span class="token keyword">for</span> bool <span class="token punctuation">{</span>    <span class="token keyword">type</span> Err <span class="token operator">=</span> ParseBoolError<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">from_str</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>bool<span class="token punctuation">,</span> ParseBoolError<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">match</span> s <span class="token punctuation">{</span>            <span class="token string">"true"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">"false"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Err</span><span class="token punctuation">(</span>ParseBoolError <span class="token punctuation">{</span> _priv<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们再来看一个标准库中对<code>Option&lt;T&gt;</code>的典型用法，<code>Iterator</code>的<code>next</code>方法要么返回下一个元素，要么无元素可返回，因此使用<code>Option&lt;T&gt;</code>非常合适。</p><pre class=" language-rust"><code class="language-rust">#<span class="token punctuation">[</span>must_use <span class="token operator">=</span> <span class="token string">"iterators are lazy and do nothing unless consumed"</span><span class="token punctuation">]</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">...</span><span class="token punctuation">}</span></code></pre><p><code>Option&lt;T&gt;</code>类型解决了许多编程语言中存在的空指针问题。空指针这个设计在加入编程语言时没有经过深思熟虑，而只是因为易于实现而已。空指针最大的问题在于，它违背了类型系统的规定。类型规定了数据可能的取值范围，规定了在这些值上可能的操作，也规定了这些数据代表的含义，还规定了这些数据的存储方式。但是，一个普通的指针和一个空指针，哪怕它们是同样的类型，做同样的操作，所得到的结果是不同的。因此，并不能说空指针和普通指针是同一个类型，空指针在类型系统上打开了一个缺口，引入了一个必须在运行期特殊处理的值，它让编译器的类型检查在此失去了意义。对此，Rust的解决方案是把空指针null从一个值上升为一个类型，用enum类型的<code>Option&lt;T&gt;</code>的<code>None</code>来代表空指针，而Rust中的enum要求在使用时必须对enum的每一种可能性都进行处理，因此强迫程序员必须考虑到<code>Option&lt;T&gt;</code>为<code>None</code>的情形。C/C++中也增添了类似的设计，但由于前向兼容的问题，无法强制使用，因此其作用也就弱化了很多。</p><h4 id="问号运算符"><a href="#问号运算符" class="headerlink" title="问号运算符"></a>问号运算符</h4><p>Rust中提供了问号运算符<code>?</code>语法糖来简化<code>Result&lt;T, E&gt;</code>和<code>Option&lt;T&gt;</code>的使用，问号运算符的意思是，如果结果是<code>Err</code>，则提前返回，否则继续执行。<code>?</code>对应着<code>std::ops::Try</code>这个trait，编译器会把<code>expr?</code>这个表达式自动转换为以下语义：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">match</span> Try<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">into_result</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Ok</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> v<span class="token punctuation">,</span>    <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">return</span> Try<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_error</span><span class="token punctuation">(</span>From<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>标准库中已经为<code>Result&lt;T, E&gt;</code>和<code>Option&lt;T&gt;</code>两个类型实现了<code>Try</code>：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Try <span class="token keyword">for</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Ok <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">type</span> Error <span class="token operator">=</span> NoneError<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">into_result</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> NoneError<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">ok_or</span><span class="token punctuation">(</span>NoneError<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">from_ok</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>        <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">from_error</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> NoneError<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>        None    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Try <span class="token keyword">for</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Ok <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">type</span> Error <span class="token operator">=</span> NoneError<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">into_result</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> NoneError<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">ok_or</span><span class="token punctuation">(</span>NoneError<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">from_ok</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>        <span class="token function">Some</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">from_error</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> NoneError<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self <span class="token punctuation">{</span>        None    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，对于<code>Result</code>类型，执行问号运算符时，如果碰到<code>Err</code>，则调用<code>From</code>trait做类型转换，然后中断当前逻辑提前返回。</p><p>需要注意的是，问号运算符的引入给main函数带来了挑战，因为问号运算符要求函数返回值是<code>Result</code>类型，而main函数是<code>fn() -&gt; ()</code>类型，解决这个问题的办法就是修改main函数的签名类型，但这样又会破坏旧代码。Rust最终的解决方案是引入了一个trait：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Termination <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// Is called to get the representation of the value as status code.</span>    <span class="token comment" spellcheck="true">/// This status code is returned to the operating system.</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">;</span><span class="token punctuation">}</span>#<span class="token punctuation">[</span><span class="token function">unstable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"termination_trait_lib"</span><span class="token punctuation">,</span> issue <span class="token operator">=</span> <span class="token string">"43301"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">impl</span> Termination <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token attribute attr-name">#[inline]</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        ExitCode<span class="token punctuation">:</span><span class="token punctuation">:</span>SUCCESS<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>#<span class="token punctuation">[</span><span class="token function">unstable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"termination_trait_lib"</span><span class="token punctuation">,</span> issue <span class="token operator">=</span> <span class="token string">"43301"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>E<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token operator">></span> Termination <span class="token keyword">for</span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>            <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token function">Err</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Err<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">,</span> _<span class="token operator">></span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>#<span class="token punctuation">[</span><span class="token function">unstable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"termination_trait_lib"</span><span class="token punctuation">,</span> issue <span class="token operator">=</span> <span class="token string">"43301"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">impl</span> Termination <span class="token keyword">for</span> <span class="token operator">!</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">self</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>#<span class="token punctuation">[</span><span class="token function">unstable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"termination_trait_lib"</span><span class="token punctuation">,</span> issue <span class="token operator">=</span> <span class="token string">"43301"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>E<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Debug<span class="token operator">></span> Termination <span class="token keyword">for</span> Result<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token function">Err</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">;</span>        <span class="token function">eprintln!</span><span class="token punctuation">(</span><span class="token string">"Error: {:?}"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExitCode<span class="token punctuation">:</span><span class="token punctuation">:</span>FAILURE<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>#<span class="token punctuation">[</span><span class="token function">unstable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"termination_trait_lib"</span><span class="token punctuation">,</span> issue <span class="token operator">=</span> <span class="token string">"43301"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">impl</span> Termination <span class="token keyword">for</span> ExitCode <span class="token punctuation">{</span>    <span class="token attribute attr-name">#[inline]</span>    <span class="token keyword">fn</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token function">as_i32</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>main函数的签名就对应地改成了<code>fn&lt;T: Termination&gt;() -&gt; T</code>，标准库为Result类型、<code>()</code>类型等都实现了这个trait，从而这些类型都可以作为main函数的返回类型了。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#10：常用的标准库工具</title>
      <link href="posts/57a03adb.html"/>
      <url>posts/57a03adb.html</url>
      
        <content type="html"><![CDATA[<h3 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h3><p>我们一般使用<code>use</code>语句把其他模块的内容引入当前模块中，但对于标准库中一些非常常用的工具，每次都写<code>use</code>语句就过于冗余，因此标准库提供了一个<code>std::prelude</code>模块，在这个模块中导出一些最常见的工具，然后编译器为用户编写的每一个crate都自动插入一句话：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>prelude<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">;</span></code></pre><p>如此，一些最常见的工具就可以直接使用，而无需<code>use</code>了。对这个<code>std::prelude</code>模块所包含内容的权衡是需要细致考量的，因为如果包含的内容过多则会引入很多不被使用的工具，这反倒不美了。当下的<code>std::prelude</code>模块中包含的内容在<code>std::prelude::v1</code>中。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>除了<code>as</code>关键字可以用来进行基本类型之间的转换，Rust还提供了很多trait来实现自定义类型之间的转换。</p><h4 id="AsRef-AsMut"><a href="#AsRef-AsMut" class="headerlink" title="AsRef / AsMut"></a>AsRef / AsMut</h4><p><code>AsRef</code>的含义是该类型可以通过调用<code>as_ref</code>方法得到另外一个类型的共享引用，同理，<code>AsMut</code>得到的是另外一个类型的可读写引用，它们的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> AsRef<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>T<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> AsMut<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>AsRef</code>很适合用于泛型代码中，例如，下面的泛型函数接受各种类型，只要可以被转换为<code>&amp;[u8]</code>即可：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> iter_bytes<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> AsRef<span class="token operator">&lt;</span><span class="token punctuation">[</span>u8<span class="token punctuation">]</span><span class="token operator">>></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> arg<span class="token punctuation">.</span><span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"this is a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token function">iter_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iter_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iter_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Borrow-BorrowMut"><a href="#Borrow-BorrowMut" class="headerlink" title="Borrow / BorrowMut"></a>Borrow / BorrowMut</h4><p><code>Borrow</code>、<code>BorrowMut</code>这两个trait的设计和<code>AsRef</code>、<code>AsMut</code>很类似：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Borrow<span class="token operator">&lt;</span>Borrowed<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>Borrowed<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> BorrowMut<span class="token operator">&lt;</span>Borrowed<span class="token punctuation">:</span> ?Sized<span class="token operator">></span><span class="token punctuation">:</span> Borrow<span class="token operator">&lt;</span>Borrowed<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Borrowed<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但区别在于两点：</p><ul><li>标准库为所有的<code>T</code>、<code>&amp;T</code>和<code>&amp;mut T</code>默认实现了<code>Borrow</code>、<code>BorrowMut</code>，以<code>Borrow</code>为例：</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> Borrow<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">for</span> T <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>        <span class="token keyword">self</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> Borrow<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">for</span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>        <span class="token operator">&amp;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">self</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> Borrow<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">for</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> T <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>        <span class="token operator">&amp;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">self</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><code>Borrow</code>要求返回的类型，必须和原来的类型具备同样的hash值。这是一个约定，如果违反了这个约定，那么把这个类型放到<code>HashMap</code>里时可能会出现问题。</li></ul><h4 id="From-Into"><a href="#From-Into" class="headerlink" title="From / Into"></a>From / Into</h4><p><code>AsRef</code>和<code>Borrow</code>都是从<code>&amp;T</code>到<code>&amp;U</code>的转换，而<code>From/Into</code>是从<code>T</code>到<code>U</code>的转换：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> From<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">from</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> Into<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">into</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> T<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于<code>From</code>和<code>Into</code>是互逆的一组转换，因此标准库提供了这样一个实现：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> Into<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">for</span> T<span class="token keyword">where</span>    U<span class="token punctuation">:</span> From<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">into</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> U <span class="token punctuation">{</span>        U<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码的含义是：如果存在<code>U: From&lt;T&gt;</code>，则为类型<code>T</code>实现<code>Into&lt;U&gt;</code>。也就是说，我们只需为类型实现<code>From</code>即可，<code>Into</code>会自动实现。标准库中还有一组对应的<code>TryFrom</code>和<code>TryInto</code>，他们是为了处理类型转换过程中可能发生转换错误的情况，因此返回值是<code>Result</code>类型。</p><h4 id="ToOwned"><a href="#ToOwned" class="headerlink" title="ToOwned"></a>ToOwned</h4><p><code>ToOwned</code>提供一种更泛化的<code>Clone</code>的功能，<code>Clone</code>是从<code>&amp;T</code>类型变量创造一个新的<code>T</code>类型变量，而<code>ToOwned</code>是从一个<code>&amp;T</code>类型变量创造一个新的<code>U</code>类型变量，标准库中也提供了<code>ToOwned</code>调用<code>clone</code>方法的默认实现：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> ToOwned <span class="token punctuation">{</span>    <span class="token keyword">type</span> Owned<span class="token punctuation">:</span> Borrow<span class="token operator">&lt;</span>Self<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Owned<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">clone_into</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Owned<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>target <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> ToOwned <span class="token keyword">for</span> T<span class="token keyword">where</span>    T<span class="token punctuation">:</span> Clone<span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token keyword">type</span> Owned <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">clone_into</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        target<span class="token punctuation">.</span><span class="token function">clone_from</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="ToString-FromStr"><a href="#ToString-FromStr" class="headerlink" title="ToString / FromStr"></a>ToString / FromStr</h4><p><code>ToString</code>提供了其他类型转换为<code>String</code>类型的能力：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> ToString <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> String<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>标准库中为所有实现了<code>Display</code>trait的类型默认实现了<code>ToString</code>，而<code>Display</code>可以通过derive实现：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Display <span class="token operator">+</span> ?Sized<span class="token operator">></span> ToString <span class="token keyword">for</span> T <span class="token punctuation">{</span>        default <span class="token keyword">fn</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> String <span class="token punctuation">{</span>                <span class="token keyword">use</span> fmt<span class="token punctuation">:</span><span class="token punctuation">:</span>Write<span class="token punctuation">;</span>                <span class="token keyword">let</span> <span class="token keyword">mut</span> buf <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                buf<span class="token punctuation">.</span><span class="token function">write_fmt</span><span class="token punctuation">(</span><span class="token function">format_args!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                       <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"a Display implementation returned an error unexpectedly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                buf        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>FromStr</code>提供了从字符串切片向其他类型转换的能力：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> FromStr<span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>        <span class="token keyword">type</span> Err<span class="token punctuation">;</span>        <span class="token keyword">fn</span> <span class="token function">from_str</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span>Self<span class="token punctuation">,</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Err<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>这里的IO指的是标准输入输出和文件输入输出。</p><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>我们之前介绍过的<code>println!</code>宏可以方便地随手输出一些信息，但如果要对标准输入输出作更精细的控制，则需要调用<code>std::io::stdin()</code>函数和<code>std::io::stdout()</code>函数来获取<code>Stdin</code>和<code>Stdout</code>结构体的实例。这两个实例的简单用法如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> Read<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> io<span class="token punctuation">:</span><span class="token punctuation">:</span>Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> stdin <span class="token operator">=</span> io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stdin<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span>?<span class="token punctuation">;</span>        <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>为了线程安全考虑，每次读取操作都需要上锁，这降低了效率。解决的方法是手动调用<code>lock()</code>方法，但这又增添了使用标准输入输出的复杂度。</p><p>事实上，我们受学生时代做各种C语言大作业的影响，导致我们认为标准输入输出是非常重要的功能，可我们细想一下，正儿八经的命令行程序谁会用标准输入来和用户交互呢？一般都是通过两种方式，一则是调用程序的时候指定参数，另一则是通过文件读取用户配置。</p><h4 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h4><p>文件输入输出首先要解决路径问题。Rust中的字符串类型是<code>String</code>和<code>str</code>，它们都是用<code>utf-8</code>进行编码的。但是，在具体的操作系统上并不是统一使用<code>utf-8</code>编码，为了应付这种情况，Rust中设计了<code>OsString</code>和<code>OsStr</code>，这两种类型使用方法和<code>String</code>和<code>str</code>类似，并且它们之间也可以互相转换。</p><p>Rust标准库提供了<code>std::path::PathBuf</code>和<code>std::path::Path</code>来处理路径，<code>PathBuf</code>对内部数据拥有所有权，而<code>Path</code>只是借用，事实上，<code>PathBuf</code>内部存储了一个<code>OsString</code>，而<code>Path</code>则是存储了<code>OsStr</code>。</p><p>Rust的文件操作主要通过<code>std::fs::File</code>来完成，可以实现打开、创建、复制等文件操作。对于文件的读写，就要用到<code>std::io</code>模块中的一些trait了，例如<code>Read</code>和<code>Write</code>。<code>File</code>实现了这 两个trait，因此拥有<code>read</code>等读取文件的方法。</p><p>下面看一个例子来演示说明文件输入输出的方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>fs<span class="token punctuation">:</span><span class="token punctuation">:</span>File<span class="token punctuation">;</span><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>BufRead<span class="token punctuation">,</span> BufReader<span class="token punctuation">,</span> Read<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">test_read_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span>Error<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> path <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>env<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">current_dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Cargo.toml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> file <span class="token operator">=</span> File<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">)</span>?<span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> buffer <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    file<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> buffer<span class="token punctuation">)</span>?<span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Ok</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> <span class="token function">test_read_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>和C++的STL类似，Rust的标准库也给我们提供了一些比较常用的容器以及相关的迭代器，目前实现了的容器有：</p><table><thead><tr><th>容器</th><th>描述</th></tr></thead><tbody><tr><td>Vec</td><td>可变长数组，连续存储</td></tr><tr><td>VecDeque</td><td>双向队列，适用于从头部和尾部插入删除数据</td></tr><tr><td>LinkedList</td><td>双向链表，非连续存储</td></tr><tr><td>HashMap</td><td>基于Hash算法存储一系列键值对</td></tr><tr><td>BTreeMap</td><td>基于B树存储一系列键值对</td></tr><tr><td>HashSet</td><td>相当于没有值的HashMap</td></tr><tr><td>BTreeSet</td><td>相当于没有值的BTreeMap</td></tr><tr><td>BinaryHeap</td><td>基于二叉堆实现的优先级队列</td></tr></tbody></table><p>这里不详细展开讲，以后会对各个容器的用法和实现原理进行深入探究。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Rust中的迭代器是指实现了<code>std::iter::Iterator</code>这个trait的类型，其定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>        <span class="token keyword">type</span> Item<span class="token punctuation">;</span>        <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Item<span class="token operator">></span><span class="token punctuation">;</span>       <span class="token punctuation">...</span><span class="token punctuation">}</span></code></pre><p>它最主要的方法是<code>next()</code>，返回一个<code>Option&lt;Item&gt;</code>，迭代完成则返回None。实现了<code>Iterator</code>的类型可直接用于for循环。</p><p>迭代器拥有一个很重要的特性，就是它是可组合的，这有点类似于Java中的流式编程。<code>Iterator</code>中有很多方法，它们返回的类型也实现了<code>Iterator</code>，这意味着，我们调用这些方法可以从一个迭代器创造出一个新的迭代器，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> iter <span class="token operator">=</span> v        <span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>x<span class="token operator">|</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&amp;</span>x<span class="token operator">|</span> x <span class="token operator">*</span> x<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}: {}"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码的含义是：从<code>v</code>这个<code>Vec</code>的前五个元素中筛选元素，要求它必须是2的倍数，并把该元素进行平方，因此，最终的输出结果是<code>0: 4</code>和<code>1: 16</code>。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Rust支持自定义类型重载部分运算符，只需该类型实现<code>std::ops</code>模块下相应的trait即可。以<code>Add</code>为例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Add<span class="token operator">&lt;</span>Rhs <span class="token operator">=</span> Self<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">type</span> Output<span class="token punctuation">;</span>        <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> Rhs<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>它具备一个泛型参数<code>RHS</code>和一个关联类型<code>Output</code>。标准库中早已为基本的数字类型实现了这个trait：</p><pre class=" language-rust"><code class="language-rust"><span class="token macro-rules function">macro_rules!</span> add_impl <span class="token punctuation">{</span>    <span class="token punctuation">(</span>$<span class="token punctuation">(</span>$t<span class="token punctuation">:</span>ty<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>$<span class="token punctuation">(</span>        #<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">impl</span> Add <span class="token keyword">for</span> $t <span class="token punctuation">{</span>            <span class="token keyword">type</span> Output <span class="token operator">=</span> $t<span class="token punctuation">;</span>            <span class="token attribute attr-name">#[inline]</span>            <span class="token attribute attr-name">#[rustc_inherit_overflow_checks]</span>            <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> $t<span class="token punctuation">)</span> <span class="token punctuation">-></span> $t <span class="token punctuation">{</span> <span class="token keyword">self</span> <span class="token operator">+</span> other <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token macro-rules function">forward_ref_binop!</span> <span class="token punctuation">{</span> <span class="token keyword">impl</span> Add<span class="token punctuation">,</span> add <span class="token keyword">for</span> $t<span class="token punctuation">,</span> $t <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token macro-rules function">add_impl!</span> <span class="token punctuation">{</span> usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 <span class="token punctuation">}</span></code></pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#9：闭包</title>
      <link href="posts/e0a6b56.html"/>
      <url>posts/e0a6b56.html</url>
      
        <content type="html"><![CDATA[<h3 id="闭包的基本语法"><a href="#闭包的基本语法" class="headerlink" title="闭包的基本语法"></a>闭包的基本语法</h3><p>闭包，又称为lambda表达式，可以像函数一样被调用，但具有使用外部环境中的变量的能力，其中外部环境是指闭包定义时所在的作用域。一个典型的闭包如下所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">|</span></span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span></code></pre><p>可以看到，<code>add</code>是一个闭包，它有一个参数，用两个<code>|</code>包围，执行语句包含在<code>&#123;&#125;</code>中，闭包的参数和返回值类型的指定与普通函数的语法相同，但可以省略。若<code>&#123;&#125;</code>中只包含一条语句，<code>&#123;&#125;</code>也可以省略。也就是说，<code>add</code>可以简写为如下形式：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token operator">|</span>a<span class="token operator">|</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span></code></pre><p>在闭包<code>add</code>中，它可以使用外部环境中的变量<code>x</code>，这是和普通函数最大的不同。需要注意的是，对于普通函数<code>fn</code>来说，其无需前向声明，但闭包需要先定义后使用，从这个角度讲闭包更像是一个变量，而且它具有和变量同样的“生命周期”。</p><p>下面我们来看一下闭包是如何使用外部环境中的变量的。</p><h3 id="闭包的实现原理"><a href="#闭包的实现原理" class="headerlink" title="闭包的实现原理"></a>闭包的实现原理</h3><p>对每一个闭包，编译器会自动生成一个匿名struct类型，并通过分析闭包的内部逻辑来决定该结构体包括哪些数据以及数据该如何初始化，<strong>如果闭包中使用了外部环境变量，则结构体中会包括该变量</strong>。从这个层面讲，闭包其实是一种语法糖。对于上面提到的闭包<code>add</code>，编译器会将其自动转化为如下形式（只是举个例子，并非真正的编译器处理闭包的方式）：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Closure <span class="token punctuation">{</span>    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> Closure <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">+</span> a    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> add <span class="token operator">=</span> Closure <span class="token punctuation">{</span> x<span class="token punctuation">:</span> x <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> add<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span><span class="token punctuation">}</span></code></pre><p>可以看到，若想在闭包中使用一个外部环境中的变量，需要分两步：第一步是构造相应的结构体并<strong>捕获</strong>外部环境变量，就如<code>let add = Closure &#123; x: x &#125;;</code>所示；第二步是构造结构体的成员函数并<strong>使用</strong>外部环境变量，就如<code>fn call(&amp;self, a: i32) -&gt; i32</code>所示。在这两个步骤中，还需要考虑两个问题：</p><ul><li>第一个问题关心的是闭包如何<strong>捕获</strong>外部变量：结构体内部的成员应当使用什么类型呢，是<code>T</code>、<code>&amp;T</code>还是<code>&amp;mut T</code>呢？</li><li>第二个问题关心的是闭包如何<strong>使用</strong>外部变量：函数调用的<code>self</code>应当使用什么类型呢，是<code>self</code>、<code>&amp;self</code>还是<code>&amp;mut self</code>呢？</li></ul><h4 id="如何捕获外部变量"><a href="#如何捕获外部变量" class="headerlink" title="如何捕获外部变量"></a>如何捕获外部变量</h4><p>对于闭包如何捕获外部变量，编译器的原则是“按需捕获”：在保证能编译通过的情况下，结构体内部的成员优先选择<code>&amp;T</code>，其次是<code>&amp;mut T</code>，最后选择<code>T</code>。这个原则的核心就是“选择对结构体外部影响最小的存储类型”，具体来说就是：</p><ul><li>如果一个外部变量在闭包中只通过借用指针<code>&amp;</code>使用，那么这个变量就可使用<code>&amp;</code>捕获；</li><li>如果一个外部变量在闭包中通过可变借用指针<code>&amp;mut</code>使用，那么这个变量就需要使用<code>&amp;mut</code>捕获；</li><li>如果一个外部变量在闭包中通过所有权转移方式使用过，那么这个变量就需要使用<code>T</code>捕获；</li></ul><p>看下面这个例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token function">T</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">by_move</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">by_ref</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">by_mut</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> z <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> closure <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span>        <span class="token function">by_move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">by_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">by_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上闭包分别以<code>T</code>、<code>&amp;T</code>还是<code>&amp;mut T</code>的方式捕获了外部的变量<code>x</code>，<code>y </code>，<code>z</code>，所以编译器会自动生成类似于下面这样的结构体：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Closure <span class="token punctuation">{</span>    x<span class="token punctuation">:</span> T<span class="token punctuation">,</span>    y<span class="token punctuation">:</span> <span class="token operator">&amp;</span>T<span class="token punctuation">,</span>    z<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> T<span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>需要注意的是，如果承载闭包的变量不再是局部变量，而是被传递出了当前作用域，则该闭包必须选择传递所有权的方式才能保证编译通过，这时可以使用<code>move</code>关键字修饰闭包，强制将闭包中变量的捕获全部使用所有权转移的方式。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">make_adder</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> Box<span class="token operator">&lt;</span><span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token operator">></span> <span class="token punctuation">{</span>    Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token operator">|</span>y<span class="token operator">|</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>可以看到，局部变量<code>x</code>被传递出了函数外，如果不加<code>move</code>关键字，编译器会提示：</p><pre class=" language-rust"><code class="language-rust">error<span class="token punctuation">[</span>E0373<span class="token punctuation">]</span><span class="token punctuation">:</span> closure may outlive the current function<span class="token punctuation">,</span> but it borrows `x`<span class="token punctuation">,</span> which is owned by the current function</code></pre><h4 id="如何使用外部变量"><a href="#如何使用外部变量" class="headerlink" title="如何使用外部变量"></a>如何使用外部变量</h4><p>闭包使用外部变量的方式将影响相应的结构体成员函数的第一个参数<code>self</code>的类型，对于<code>self</code>、<code>&amp;self</code>和<code>&amp;mut self</code>三种类型，Rust提供了三个trait对其进行抽象。这三个trait是<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>，它们的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> FnOnce<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Output<span class="token punctuation">;</span>    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_once</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> FnMut<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">:</span> FnOnce<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> Fn<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">:</span> FnMut<span class="token operator">&lt;</span>Args<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token string">"rust-call"</span> <span class="token keyword">fn</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> args<span class="token punctuation">:</span> Args<span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Output<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，这三个trait的区别就在于<code>self</code>的类型不同：</p><ul><li><code>FnOnce</code>的调用参数为<code>self</code>，表示闭包通过转移所有权的方式来使用外部环境中的变量，所以该闭包只能调用一次；</li><li><code>FnMut</code>的调用参数是<code>&amp;mut self</code>，表示闭包通过可变借用的方式来使用外部环境中的变量；</li><li><code>Fn</code>的调用参数是<code>&amp;self</code>，表示闭包通过不可变借用的方式来使用外部环境中的变量；</li></ul><p>需要注意的是，<code>Fn</code>继承自<code>FnMut</code>，<code>FnMut</code>继承自<code>FnOnce</code>，这意味着，如果要实现<code>Fn</code>，就必须实现<code>FnMut</code>和<code>FnOnce</code>；如果要实现<code>FnMut</code>，就必须实现<code>FnOnce</code>。这里面蕴含的逻辑是，如果该闭包能够以<code>Fn</code>方式调用，那么它也一定能以<code>FnMut</code>和<code>FnOnce</code>方式调用。</p><p>看下面这个例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> use_by_ref <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">use_by_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Fn</span>    <span class="token function">use_by_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> use_by_mut <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">" world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">use_by_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// FnMut</span>    <span class="token function">use_by_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> use_by_move <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span><span class="token punctuation">|</span></span> <span class="token punctuation">{</span>        <span class="token function">drop</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">use_by_move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FnOnce</span>    <span class="token comment" spellcheck="true">// use_by_move(); // error[E0382]: use of moved value: `use_by_move`</span><span class="token punctuation">}</span></code></pre><p>可以看到，闭包<code>use_by_ref</code>是只读方式使用了外部变量<code>s</code>，如果不使用<code>move</code>关键字，它的捕获方式是<code>&amp;T</code>，使用方式是<code>Fn</code>，这里为了演示，强制使用<code>move</code>关键字将捕获方式改为<code>T</code>，但由于闭包中对变量<code>s</code>的使用仍然是只读，所以使用方式仍然是<code>Fn</code>，而不是<code>FnOnce</code>；闭包<code>use_by_mut</code>是可变方式使用了外部变量<code>s</code>，它的捕获方式是<code>&amp;mut T</code>，使用方式是<code>FnMut</code>；闭包<code>use_bu_move</code>是所有权转移方式使用了外部变量<code>s</code>，它的捕获方式是<code>T</code>，使用方式是<code>FnOnce</code>，所以在第二次调用<code>use_by_move</code>时会报错。</p><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><p>闭包一定会实现<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>三种trait之一，所以可以将闭包作为函数参数和返回类型，但需要注意的是，不要忘记trait是一种DST类型，它的大小在编译阶段是不固定的，从而不能直接作为参数类型或者返回值类型，这也是Rust中的trait和其他语言中的接口的重大区别之一。请看下面的例子，在函数<code>tset</code>中不可以直接使用<code>Bird</code>作为类型，编译器会报错。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Bird <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> Duck<span class="token punctuation">;</span><span class="token keyword">struct</span> Swan<span class="token punctuation">;</span><span class="token keyword">impl</span> Bird <span class="token keyword">for</span> Duck <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"duck duck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> Bird <span class="token keyword">for</span> Swan <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"swan swan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// error[E0277]: the size for values of type `(dyn Bird + 'static)` cannot // be known at compilation time</span><span class="token keyword">fn</span> <span class="token function">test</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Bird<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> </code></pre><p>难道我们在Rust中就不能拥有多态了吗？那是不可能的，我们有两种选择：</p><ul><li>静态分派：通过泛型的方式，为不同的泛型类型参数生成不同版本的函数，实现编译期静态分派。</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> test<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> Bird<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arg<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>动态分派，通过trait objetc的方式，将闭包装箱进入堆内存中，函数传递的是一个胖指针，从实现运行期动态分派。</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">test</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>dyn Bird<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arg<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面我们来具体介绍一下静态分派和动态分派。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>对于闭包，其泛型参数的写法有一些特殊之处，如下面代码所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> call_with_closure<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> F<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token keyword">where</span>    F<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token function">closure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>其中泛型参数<code>F</code>的约束条件是<code>F: Fn(i32) -&gt; i32</code>，这使得看起来和普通函数类型更相似从而更易阅读。</p><p>使用泛型的方式在函数参数中可以正常使用，但却无法将一个闭包作为函数值返回，因为Rust中只支持函数返回具体类型，而闭包是一个匿名类型，这使得编译器无法自动推断且程序员也无法手动指定。这时，可以使用<code>impl trait</code>语法糖，看下面的例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">multiply</span><span class="token punctuation">(</span>m<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">impl</span> <span class="token function">Fn</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token keyword">move</span> <span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">*</span> m<span class="token punctuation">}</span></code></pre><p>这里的<code>impl Fn(i32) -&gt; i32</code>表示，这个返回类型，虽然我们不知道它的具体名字，但是知道它满足<code>Fn(i32) -&gt; i32</code>这个trait的约束。这个功能目前还不是特别稳定，建议不要激进使用，推荐使用下面介绍的动态分派的方式来解决返回值的问题。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>动态分派是通过指针的方式来实现多态，虽然trait是的DST，但指向trait的指针不是DST。如果我们把trait隐藏到指针的后面，那么就称它是一个trait object，而trait object是可以作为参数和返回类型的。</p><p>指向trait的指针就是trait object。假如<code>Bird</code>是一个trait的名称，那么<code>dyn Bird</code>就是一个DST动态大小类型，则<code>&amp;dyn Bird</code>、<code>Box&lt;dyn Bird&gt;</code>以及<code>Rc&lt;dyn Bird&gt;</code>等都是trait object。当指针指向trait的时候，它就变成一个胖指针了，比如<code>Box&lt;dyn Bird&gt;</code>可以理解为：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> TraitObject <span class="token punctuation">{</span>        <span class="token keyword">pub</span> data<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">pub</span> vtable<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token keyword">mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>它里面包含了两个指针，第一个表示地址，第二个指向“虚函数表”，里面有我们需要调用的具体函数的地址。这和C++中的虚函数表内存布局有所不同。在C++中，如果一个类型里面有虚函数，则每一个这种类型的变量内部都包含一个指向虚函数表的地址。而在Rust中，对象本身不包含指向虚函数表的指针，这个指针是存在于trait object指针里面的，如果一个类型实现了多个trait，那么不同的trait object指向的虚函数表也不一样。</p><p>需要注意的是，并不是所有的trait都可以构造trait object，trait objetc的构造是受到许多约束的。满足以下条件的trait不能构造trait object：</p><ul><li>当trait有<code>Self: Sized</code>约束时</li><li>当函数除了第一个参数外，有<code>Self</code>类型作为参数或返回类型时</li><li>当函数的第一个参数不是<code>Self</code>时</li><li>当函数有泛型参数时</li></ul><p>对于后三种情况，如果想把不满足条件的函数剔除在外，可以为该函数加上<code>Self: Sized</code>约束，例如<code>fn foo(&amp;self) where Self: Sized</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#8：智能指针与所有权</title>
      <link href="posts/c6a197fe.html"/>
      <url>posts/c6a197fe.html</url>
      
        <content type="html"><![CDATA[<p>对于借用指针，取引用是<code>&amp;</code>，解引用是<code>*</code>，取引用的语义是获得地址，其行为由编译器控制，而解引用却确定了一个指针的行为，用户可以自定义解引用操作符的具体操作，下面具体讲一讲解引用相关的知识。</p><h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><h4 id="自定义解引用"><a href="#自定义解引用" class="headerlink" title="自定义解引用"></a>自定义解引用</h4><p>我们可以通过实现标准库中的<code>std::ops::Deref</code>或者<code>std::ops::DerefMut</code>这两个trait来自定义解引用操作，其中<code>DerefMut</code>和<code>Deref</code>的区别是前者返回的是<code>&amp;mut</code>型引用，它们的源码如下。关联类型Target代表解引用之后的目标类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Deref <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// The resulting type after dereferencing.</span>    <span class="token keyword">type</span> Target<span class="token punctuation">:</span> ?Sized<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// Dereferences the value.</span>    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Target<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> DerefMut<span class="token punctuation">:</span> Deref <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// Mutably dereferences the value.</span>    <span class="token keyword">fn</span> <span class="token function">deref_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Target<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>智能指针泛指除借用指针外实现了<code>Deref</code>的类型，如<code>String</code>、<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>等。例如，标准库中实现了<code>String</code>向<code>str</code>的解引用转换：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span> ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref <span class="token keyword">for</span> String <span class="token punctuation">{</span>    <span class="token keyword">type</span> Target <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token attribute attr-name">#[inline]</span>    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>str <span class="token punctuation">{</span>        <span class="token keyword">unsafe</span> <span class="token punctuation">{</span> str<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_utf8_unchecked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>vec<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>需要注意的是，<code>deref()</code>方法返回的类型是<code>&amp;Target</code>，而非<code>Target</code>。如果说变量<code>s</code>的类型为<code>String</code>，则<code>*s</code>的类型并不等于<code>s.deref()</code>的类型。<code>*s</code>的类型实际上是<code>Target</code>，即<code>str</code>；而<code>s.deref()</code>的类型为<code>&amp;Target</code>，即<code>&amp;str</code>。</p><h4 id="自动解引用"><a href="#自动解引用" class="headerlink" title="自动解引用"></a>自动解引用</h4><p>Rust编译器会进行隐式的deref调用，具体说，当找不到某个变量对应的成员方法时，编译器会自动对该变量执行deref后再继续寻找，一直循环下去。自动deref的规则是，如果类型<code>T</code>可以解引用为<code>U</code>，则<code>&amp;T</code>可以转为<code>U</code>。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&amp;&amp;</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如上面的代码所示，<code>str</code>类型有一个<code>fn len(&amp;self) -&gt; usize</code>方法，其参数类型是<code>&amp;str</code>。编译器在<code>&amp;&amp;&amp;&amp;str</code>类型里找不到对应的len方法，就会将其解引用为<code>&amp;&amp;&amp;str</code>类型继续寻找，以此类推直到解引用为<code>&amp;str</code>，方可成功匹配。</p><p>自动解引用所带来的好处是使得智能指针透明化，能够在使用时感觉不到智能指针的存在。例如下面的代码中，变量<code>s</code>是<code>Box&lt;String&gt;</code>类型的智能指针，但<code>Box&lt;String&gt;</code>并没有<code>byte()</code>方法，所以编译器自动解引用，尝试<code>s.deref().bytes()</code>，但<code>String</code>类型也没有<code>byte()</code>方法，编译器继续将<code>String</code>解引用为<code>Str</code>，尝试<code>s.deref().deref().bytes()</code>，最终编译成功。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="Box指针"><a href="#Box指针" class="headerlink" title="Box指针"></a>Box指针</h4><p><code>Box&lt;T&gt;</code>是Rust中的一种指针类型，它指向堆上的一个地址，并拥有该地址中变量的所有权。我们知道，借用<code>&amp;</code>本质上就是一个指针，也是Rust中最常见最普通的指针，借用指针不拥有变量的所有权。Box指针和借用指针的区别主要有两点：</p><ul><li>Box指针会取得变量的所有权，而借用指针不会。</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> val <span class="token operator">=</span> Data <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> borrow <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> val<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常输出</span><span class="token keyword">let</span> boxed<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>Data<span class="token operator">></span> <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> val<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0382]: borrow of moved value: `val`</span></code></pre><ul><li>Box指针指向的变量一定在堆上，例如下面的代码中把一个变量从栈上移到堆上。</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> borrowed <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> borrowed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：0x7ffc163864fc</span><span class="token keyword">let</span> boxed <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p}"</span><span class="token punctuation">,</span> boxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：0x55d6a3cabc10</span></code></pre><h4 id="Rc指针"><a href="#Rc指针" class="headerlink" title="Rc指针"></a>Rc指针</h4><p>很多语言的内存管理采用的是引用计数法，例如Python，当引用某个内存的变量的个数变为0时，该内存才会被释放。Rust中也提供了类似机制的指针<code>Rc&lt;T&gt;</code>：一块不可变内存可以有多个所有者，当所有的所有者消亡后，这块内存才会被释放。下面看一个<code>Rc</code>指针的例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> SharedValue <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> i32<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> shared_value <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>SharedValue <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> owner1 <span class="token operator">=</span> shared_value<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> owner2 <span class="token operator">=</span> shared_value<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:p} {:p}"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>owner1<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>owner2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看到，<code>owner1</code>和<code>owner2</code>中的值的地址是相同的，这也是<code>Rc</code>指针的意义所在。在使用<code>Rc</code>指针时，有几点需要注意：</p><ul><li><code>Rc</code>指针没有实现Copy Trait，要创造新的<code>Rc</code>指针，必须调用<code>clone</code>函数，此时引用计数值才会加1。如果使用直接赋值的方式，会执行move语义。</li><li>每个<code>Rc</code>指针对它指向的数据只有读功能，与共享引用<code>&amp;</code>一致，因此它是内存安全的。<code>Rc</code>指针和共享引用的区别在于，共享引用对数据完全没有所有权，不负责内存的释放，<code>Rc</code>指针会在引用计数减到0的时候释放内存。</li><li><code>Rc</code>指针实现了Deref Trait，可以直接使用小数点语法，编译器会自动进行解引用</li></ul><h4 id="Cow指针"><a href="#Cow指针" class="headerlink" title="Cow指针"></a>Cow指针</h4><p>COW代表的是Copy-On-Write技术，也就是“写时复制技术”，如果有一份资源的复制的代价很昂贵，而复制之后的值没有被修改，这时就可以执行浅复制，等到真正被修改的时候再执行深复制。COW的优点是把克隆操作推迟到真正需要“复制并写操作”的时候发生。在Rust中，因为Clone和Copy有明确的不同，因此COW可以理解为Clone-On-Write。</p><p><code>Cow</code>类型的实现是一个<code>enum</code>，它对指向的数据有两种状态，一种是“拥有所有权”，另一种是“不拥有所有权”。当它只需对所指向的数据进行只读访问的时候，它就只是一个借用指针；当它需要写数据时，它会先分配内存执行复制操作，再对自己拥有所有权的内存进行写入操作。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> Cow<span class="token operator">&lt;</span><span class="token string">'a, B: ?Sized + '</span>a<span class="token operator">></span><span class="token keyword">where</span>    B<span class="token punctuation">:</span> ToOwned<span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// Borrowed data.</span>    <span class="token function">Borrowed</span><span class="token punctuation">(</span>#<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span>'a B<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/// Owned data.</span>    <span class="token function">Owned</span><span class="token punctuation">(</span>#<span class="token punctuation">[</span><span class="token function">stable</span><span class="token punctuation">(</span>feature <span class="token operator">=</span> <span class="token string">"rust1"</span><span class="token punctuation">,</span> since <span class="token operator">=</span> <span class="token string">"1.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>B <span class="token keyword">as</span> ToOwned<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>Owned<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h3 id="Clone和Copy"><a href="#Clone和Copy" class="headerlink" title="Clone和Copy"></a>Clone和Copy</h3><p>之前我们讲过，移动语义和复制语义是Rust所有权系统中的两个核心概念。在Rust标准库里，Clone和Copy这两个trait在字面上都提供了“复制”的意思，但它们实际上有很大的区别。</p><p>Copy trait的全名是<code>std::marker::Copy</code>，注意，在<code>std::marker</code>里的trait都是特殊trait，它们没有方法，只是用于给类型做一个标记，impl这些trait对编译器的行为有重要影响。目前<code>std::marker</code>里稳定的trait有四个，它们是<code>Copy</code>、<code>Send</code>、<code>Sized</code>、<code>Sync</code>。如果一个类型impl了Copy这个trait，那么它在变量绑定、函数参数传递和函数返回值传递等场景下，都是Copy语义，而不再是默认的Move语义。</p><p>需要注意的是，并不是所有的类型都可以实现Copy trait，Rust规定，对于自定义类型，只有所有成员都实现了Copy trait，这个类型才有资格实现Copy trait。可以认为，Rust中只有POD（Plain Old Data）才有资格实现Copy trait，常见的POD类型有整数、浮点数等，而<code>String</code>等都不属于POD。</p><p>Clone trait的全名是<code>std::clone::Clone</code>，它的完整声明如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Clone<span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">;</span>        <span class="token keyword">fn</span> <span class="token function">clone_from</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> source<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Self<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，其最关键的是需要手动实现的<code>clone</code>方法。<code>clone</code>方法一般用于“基于语义的复制”的操作，所以，其具体实现和具体类型息息相关。例如，对于<code>Box</code>类型，<code>Clone</code>执行的是“深复制”；对于<code>Rc</code>类型，<code>Clone</code>做的事情是把引用计数值加1。</p><h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p>我们在C++中接触过构造函数和析构函数的概念，Rust中没有构造函数的说法，而是一般将对象的创建封装到普通静态函数中，而对于析构函数，Rust提供了Drop trait。Drop trait的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Drop <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Drop trait允许在对象即将消亡之时，自行调用指定代码，从而达到自动化管理资源的作用，这类似于C++的RAII编程手法，在变量生命周期开始时申请资源，在变量生命周期结束时利用析构函数释放资源。这里的资源，不仅可以包括内存，还可以包括其他向操作系统申请的资源，例如文件句柄。</p><p>需要注意的是，用户主动调用<code>drop</code>方法是非法的，编译器不允许手动调用析构函数。那么，该如何做到让局部变量在语句块结束前提前终止生命周期呢？办法是调用<code>std::mem::drop</code>函数，该函数的实现非常简单：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> drop<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>_x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>将对象的所有权移入函数中，什么都不用做，编译器就会自动释放掉这个对象了。不过，对于实现了Copy trait的类型来说，对它调用该函数是没有意义的。</p><p>另外，Rust规定，Drop和Copy不能同时存在于一个类型上，具体原因先不表。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#7：泛型</title>
      <link href="posts/9fd89a5d.html"/>
      <url>posts/9fd89a5d.html</url>
      
        <content type="html"><![CDATA[<p>和其他语言一样，Rust也具有泛型（Generics）能力。泛型是指把类型抽象成一种“参数”，数据和算法都针对这种抽象的类型参数来实现，而不针对具体类型。当我们需要真正使用的时候，再具体化、实例化类型参数。使用不同类型参数将泛型类型具体化后，获得的是完全不同的具体类型。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>泛型使用<code>&lt;&gt;</code>声明，且必须先声明后使用，泛型可以被用于数据结构、函数和方法中。</p><h4 id="泛型在数据结构中的用法"><a href="#泛型在数据结构中的用法" class="headerlink" title="泛型在数据结构中的用法"></a>泛型在数据结构中的用法</h4><p>对于复合数据类型，我们可以使用泛型来提高复合数据类型的通用性。之前学过的复合数据类型有<code>tuple</code>、<code>struct</code>、<code>tuple struct</code>和<code>enum</code>四种，因为<code>tuple</code>类型没有类型名，故其无法使用泛型，剩余三种都可以。我们熟悉的<code>Option</code>就是一个泛型<code>enum</code>类型，泛型声明放在类型名之后大括号之前，如下面代码所示。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// No value</span>    None<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/// Some value `T`</span>    <span class="token function">Some</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>在这个<code>Option</code>内部，<code>Some(T)</code>是一个<code>tuple struct</code>，包含一个类型为<code>T</code>的元素，<code>T</code>在使用时指定具体类型。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> y<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>f64<span class="token operator">></span> <span class="token operator">=</span> None<span class="token punctuation">;</span></code></pre><p>在这里，<code>x</code>是<code>Option&lt;i32&gt;</code>类型的值，<code>y</code>是<code>Option&lt;f64&gt;</code>类型的值，它们是完全不同的类型。</p><h4 id="泛型在函数中的用法"><a href="#泛型在函数中的用法" class="headerlink" title="泛型在函数中的用法"></a>泛型在函数中的用法</h4><p>泛型声明放在函数名之后括号之前，如下面代码所示。<code>compare_option</code>函数的两个参数均为<code>Option</code>，但可以具有不同的类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> compare_option<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token punctuation">(</span>fir<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> sec<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>    <span class="token keyword">match</span> <span class="token punctuation">(</span>fir<span class="token punctuation">,</span> sec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span>None<span class="token punctuation">,</span> None<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>        _ <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">false</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token operator">=</span> None<span class="token punctuation">;</span>    <span class="token keyword">let</span> option <span class="token operator">=</span> <span class="token function">compare_option</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> option<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如<code>main</code>函数中所示，一般情况下，调用泛型函数可以不指定泛型参数类型，编译器可以通过类型推导自动判断。如果需要手动指定泛型参数类型，需要使用<code>compare_option::&lt;i32, i32&gt;(x, y)</code>形式的语法。</p><h4 id="泛型在方法中的用法"><a href="#泛型在方法中的用法" class="headerlink" title="泛型在方法中的用法"></a>泛型在方法中的用法</h4><p>在结构体上下文中被定义的函数称为方法，对方法也可以使用泛型，泛型声明放在<code>impl</code>之后类型名之前，如下面代码所示。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Data<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> compare_option<span class="token operator">&lt;</span>P<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Data<span class="token operator">&lt;</span>P<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> bool <span class="token punctuation">{</span>        <span class="token keyword">let</span> fir<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>        <span class="token keyword">let</span> sec<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Option<span class="token operator">&lt;</span>P<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">.</span>data<span class="token punctuation">;</span>        <span class="token keyword">match</span> <span class="token punctuation">(</span>fir<span class="token punctuation">,</span> sec<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token function">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span>None<span class="token punctuation">,</span> None<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">true</span><span class="token punctuation">,</span>            _ <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">false</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> data1 <span class="token operator">=</span> Data <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> data2 <span class="token operator">=</span> Data <span class="token punctuation">{</span> data<span class="token punctuation">:</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> data1<span class="token punctuation">.</span><span class="token function">compare_option</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当为结构体实现trait的时候也可以使用泛型，在<code>impl &lt;Trait&gt; for &lt;Type&gt;</code>这个语法中，泛型参数既可以出现在<code>&lt;Trait&gt;</code>位置也可以出现在<code>&lt;Type&gt;</code>位置。下面是标准库中的<code>Into</code>trait。<code>From</code>和<code>Into</code>是一对功能互逆的trait，如果<code>A:Into&lt;B&gt;</code>，则意味着<code>B:From&lt;A</code>。下面代码的意思是，针对所有类型<code>T</code>，只要满足<code>U: From&lt;T&gt;</code>，那么就为该类型<code>impl Into&lt;U&gt;</code>。有了这样一个impl块之后，我们如果想为自己的两个类型提供互相转换的功能，那么只需<code>impl From</code>这一个trait就可以了。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> Into<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">for</span> T<span class="token keyword">where</span>    U<span class="token punctuation">:</span> From<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">into</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> U <span class="token punctuation">{</span>        U<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>impl</code>后面的泛型参数声明需要满足三个条件之一：</p><ul><li>出现在被实现的类型中，例如，<code>impl&lt;T&gt; Foo&lt;T&gt;</code></li><li>出现在被实现的trait中，例如，<code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code></li><li>出现在关联类型的绑定中，例如，<code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code></li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>我们在使用泛型参数的时候，一般不是对所有类型都进行操作，而是只对满足某种类型条件的类型进行操作，这称为泛型的约束，约束一般以trait的形式表达，有两种语法：</p><ul><li>在泛型参数声明的时候使用冒号<code>:</code>指定</li><li>使用<code>where</code>子句指定</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cmp<span class="token punctuation">:</span><span class="token punctuation">:</span>PartialOrd<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 第一种写法，在泛型参数声明的时候使用冒号:指定</span><span class="token keyword">fn</span> max<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> PartialOrd<span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> T<span class="token punctuation">,</span> b<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 第二种写法，使用 where 子句指定</span><span class="token keyword">fn</span> max<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> T<span class="token punctuation">,</span> b<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-></span> T <span class="token keyword">where</span> T<span class="token punctuation">:</span> PartialOrd<span class="token punctuation">;</span></code></pre><p>在上面的示例中，两种写法的效果相同，都是要求<code>T</code>类型必须实现了<code>PartialOrd</code>这个trait。对于复杂的约束条件，使用<code>where</code>子句的可读性会更好。泛型约束会在编译期执行检查，检查被实例化的泛型类型是否满足了泛型声明时的约束。</p><h3 id="trait的关联类型"><a href="#trait的关联类型" class="headerlink" title="trait的关联类型"></a>trait的关联类型</h3><p>trait中不仅可以包含方法、常量，还可以包含“类型”，例如常用的迭代器<code>Iterator</code>这个trait，它里面就有一个<code>Item</code>类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>    <span class="token punctuation">...</span><span class="token punctuation">}</span></code></pre><p>这样在trait中声明的类型被称为关联类型（associated type），关联类型也同样是这个trait的“泛型参数”。只有指定了所有的泛型参数和关联类型，这个trait才能真正的具体化。可以看到，我们希望参数是一个泛型迭代器，可以在约束条件中写<code>ITER: Iterator&lt;Item = ITEM&gt;</code>，且其关联类型<code>Item</code>必须实现了<code>Debug</code>这个trait。跟普通泛型参数比起来，关联类型参数必须使用名字赋值的方式。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> use_iter<span class="token operator">&lt;</span>ITEM<span class="token punctuation">,</span> ITER<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">mut</span> iter<span class="token punctuation">:</span> ITER<span class="token punctuation">)</span><span class="token keyword">where</span>    ITER<span class="token punctuation">:</span> Iterator<span class="token operator">&lt;</span>Item <span class="token operator">=</span> ITEM<span class="token operator">></span><span class="token punctuation">,</span>    ITEM<span class="token punctuation">:</span> Debug<span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>目前来看，关联类型和普通泛型参数的功能一致，那它存在的意义是什么呢？其实，关联类型更加强调了“关联性”，即强调了所声明的泛型参数和该trait的相关性，从而能够达到封装的效果。例如，下面这个例子中，假如我们想设计一个泛型的“图”类型，它包含“顶点”和“边”两个泛型参数，如果使用普通泛型参数，如下所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Graph<span class="token operator">&lt;</span>N<span class="token punctuation">,</span> E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function">has_edge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> n1<span class="token punctuation">:</span> <span class="token operator">&amp;</span>N<span class="token punctuation">,</span> n2<span class="token punctuation">:</span> <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token keyword">fn</span> distance<span class="token operator">&lt;</span>N<span class="token punctuation">,</span> E<span class="token punctuation">,</span> G<span class="token punctuation">:</span> Graph<span class="token operator">&lt;</span>N<span class="token punctuation">,</span> E<span class="token operator">>></span><span class="token punctuation">(</span>graph<span class="token punctuation">:</span> <span class="token operator">&amp;</span>G<span class="token punctuation">,</span> start<span class="token punctuation">:</span> <span class="token operator">&amp;</span>N<span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token operator">&amp;</span>N<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p><code>distance</code>函数用来计算一个图中两个顶点之间的距离，它的函数签名里会有很多的泛型参数。但实际上，对于确定的<code>Graph</code>类型，它的顶点和边的类型应该是固定的，所以在函数签名中再写一遍没有什么意义，关联类型就解决了这个问题，如下面代码所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Graph <span class="token punctuation">{</span>    <span class="token keyword">type</span> N<span class="token punctuation">;</span>    <span class="token keyword">type</span> E<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">has_edge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> n1<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>N<span class="token punctuation">,</span> n2<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token keyword">fn</span> distance<span class="token operator">&lt;</span>G<span class="token operator">></span><span class="token punctuation">(</span>graph<span class="token punctuation">:</span> <span class="token operator">&amp;</span>G<span class="token punctuation">,</span> start<span class="token punctuation">:</span> <span class="token operator">&amp;</span>G<span class="token punctuation">:</span><span class="token punctuation">:</span>N<span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token operator">&amp;</span>G<span class="token punctuation">:</span><span class="token punctuation">:</span>N<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token keyword">where</span>    G<span class="token punctuation">:</span> Graph<span class="token punctuation">,</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>除了关注关联类型的优点，我们也得关注其缺点。如果某个trait使用了关联类型，则不能为某个类型实现多个该trait，如下面的代码所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> ConvertTo <span class="token punctuation">{</span>    <span class="token keyword">type</span> DEST<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">:</span><span class="token punctuation">:</span>DEST<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">impl</span> ConvertTo <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>    <span class="token keyword">type</span> DEST <span class="token operator">=</span> i32<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token operator">*</span><span class="token keyword">self</span> <span class="token keyword">as</span> i32    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// error[E0119]: conflicting implementations of trait `ConvertTo` for type `i32`:</span><span class="token keyword">impl</span> ConvertTo <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>    <span class="token keyword">type</span> DEST <span class="token operator">=</span> f64<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span>        <span class="token operator">*</span><span class="token keyword">self</span> <span class="token keyword">as</span> f64    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但如果改用普通泛型参数，则无此问题，可以正常编译通过：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> ConvertTo<span class="token operator">&lt;</span>DEST<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> DEST<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">impl</span> ConvertTo<span class="token operator">&lt;</span>i32<span class="token operator">></span> <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token operator">*</span><span class="token keyword">self</span> <span class="token keyword">as</span> i32    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> ConvertTo<span class="token operator">&lt;</span>f64<span class="token operator">></span> <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> f64 <span class="token punctuation">{</span>        <span class="token operator">*</span><span class="token keyword">self</span> <span class="token keyword">as</span> f64    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由此可见，在编译器眼里，如果trait有类型参数，那么给定不同的类型参数，它们就已经是不同的trait，可以针对同一个类型<code>impl</code>。如果trait没有类型参数，只有关联类型，给关联类型指定不同的类型参数是不能用它们针对同一个类型<code>impl</code>的。</p><p>对于普通泛型参数和关联类型，它们各有利弊，我们该如何选择呢？一句话，对于需要在impl阶段就确定下来的，选择关联类型；对于在函数调用阶段才确定下来的，选择普通泛型参数。在标准库中，何时使用普通泛型参数、何时使用关联类型，实际上有非常好的示例。</p><ul><li><p>普通泛型参数：对于标准库中的<code>AsRef</code>，实现这个trait的类型可能会想转化为很多类型的引用，具体的类型由用户在函数调用阶段选择，所以必须使用普通泛型函数。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> AsRef<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> ?Sized<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// Performs the conversion.    </span>    <span class="token keyword">fn</span> <span class="token function">as_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>T<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>关联类型：对于标准库中的<code>Deref</code>，实现这个trait的类型解引用的目标类型是唯一固定的，需要在impl阶段就确定下来，所以必须使用关联类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Deref <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// The resulting type after dereferencing.    </span>    <span class="token keyword">type</span> Target<span class="token punctuation">:</span> ?Sized<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// Dereferences the value.    </span>    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Target<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#6：所有权系统</title>
      <link href="posts/60ac49c8.html"/>
      <url>posts/60ac49c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="引子：段错误与内存安全"><a href="#引子：段错误与内存安全" class="headerlink" title="引子：段错误与内存安全"></a>引子：段错误与内存安全</h3><p>在刚开始接触Rust的时候，我们就提过Rust语言的定位：</p><blockquote><p>Rust is a system’s programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>其中有一条是<code>prevents segfaults</code>，它的意思是避免段错误，<code>segfault</code>是<code>segment fault</code>的缩写。</p><p>那何为段呢？一个进程在执行的时候，它所占用的内存的虚拟地址空间一般被分割成好几个区域，我们称为“段”（segment），常见的段有代码段、数据段、函数调用栈、堆等。这些段通过硬件映射到真正的物理空间，不同的段具有不同的访问权限，例如代码段只能读不能写，如果违反了这些访问权限，就会产生段错误（segfault）。</p><p>在传统的C/C++语言中，指针能力强大，但也同时意味着非常容易制造段错误，例如空指针解引用就会访问到本无权限访问的内存导致段错误，所以C/C++也是非常难精通的语言，你必须要掌握很多的最佳实践来尽可能地避免段错误。其他语言例如Java采取了自动垃圾回收机制来规避段错误，但也付出了性能的代价。Rust的设计目标之一就是在不使用自动垃圾回收机制的前提下避免产生段错误，也就是Rust所宣称的内存安全（Memory Safety）。</p><p>但注意，Rust所宣称的内存安全并不是说避免了所有的内存错误，以下这些情况，是Rust想要避免的问题。</p><ul><li>空指针解引用</li><li>野指针（未初始化的指针）</li><li>悬空指针（指针所指向的内存空间被释放之后该指针被继续使用）</li><li>使用未初始化内存</li><li>非法释放（对同一个指针释放多次）</li><li>缓冲区溢出（指针访问越界）</li><li>数据竞争（并发场景下无保护地对同一块内存的读写）</li></ul><p>以上这些问题都是极度危险的，会造成危害性大且修复难度高的bug。但在Rust语境中，例如内存泄漏和内存耗尽这样的内存错误是不算在内存安全的范畴的，因为它们的危害性较低。</p><p>那Rust是如何保证内存安全的呢，这就是下面要介绍的内容。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>保证内存安全，就是保证一个变量从它创建到销毁的整个过程都是安全的。一个变量从它创建到销毁的整个过程 ，又称为这个变量的生命周期 （lifetime）。当变量所在的作用域结束时，该变量的生命周期就结束了。在Rust中，从<code>let</code>绑定（变量创建）开始到距离该变量最近的<code>&#123;</code>对应的<code>&#125;</code>为止（变量销毁），是<code>let</code>所声明变量的作用域（生命周期）。在C/C++中，变量的生命周期需要手动管理，申请了内存要手动释放，否则就会造成内存泄漏；在Java中，变量的生命周期交由GC处理，但需要付出额外的性能代价。但是：</p><blockquote><p>在Rust中，当变量的生命周期结束时，它和它所拥有的内存将会被自动释放。</p></blockquote><p>上面这句话凝聚了Rust内存管理的精髓，我们将围绕这句话来对Rust内存管理机制进行学习。我们将着重解决以下问题：</p><ul><li>如何判断变量的生命周期结束？这部分内容已在<strong>生命周期</strong>小节讲述。</li><li>什么是变量拥有的内存？这部分将在<strong>所有权</strong>小节讲述。</li><li>变量不拥有内存就不能使用内存吗？这部分将在<strong>借用</strong>小节讲述。</li></ul><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>Rust中采用所有权（ownership）的概念管理内存，以保证内存安全。所有权的含义是Rust中分配的每一块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每个值都只能有唯一的所有者。如果你有一些编程经验，你就会知道，“共享+可变”是万恶之源，它导致了无穷多bug的发生。如果能做到“共享的变量不可变，可变的变量不共享”，那么将能够避免非常多的问题，而Rust的所有权系统就致力于此。</p><p>我们在之前提过，所有权代表着以下意义：</p><ul><li>每个值在Rust中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者。</li><li>每个值在一个时间点上只有一个管理者。</li><li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li></ul><p>关于所有权，大家掌握两个概念即可，那就是复制语义和移动语义。复制语义和移动语义是对内存管理的两种截然不同的思想，复制语义是指变量在赋值的时候采用复制操作，移动语义是指变量在赋值的时候采用移动操作，也就是说，对于<code>a = b</code>，复制语义会把<code>b</code>的值复制一份给<code>a</code>，赋值操作结束后变量<code>a</code>和<code>b</code>都拥有值，而移动语义会把<code>b</code>的值转移给<code>a</code>，赋值操作结束后变量<code>b</code>不再拥有值而只有变量<code>a</code>拥有值。</p><p>移动语义描述的其实是对值的所有权的转移，赋值语句、函数调用和函数返回等，都可能导致所有权转移。需要注意的是，对于常见的变量绑定（其他编程语言称为赋值操作），Rust默认是移动语义，例如下面的示例。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> String <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 所有权转移，从函数内部移动到外部</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">consume</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 所有权转移，从函数外部移动到内部</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">consume</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0382]: use of moved value: `s`</span><span class="token punctuation">}</span></code></pre><ul><li><code>main</code>函数调用<code>create</code>函数，<code>create</code>函数创建字符串<code>hello</code>，栈上的局部变量<code>s</code>拥有堆上的<code>hello</code>。</li><li>在<code>create</code>函数返回的时候，发生所有权转移，堆上的<code>hello</code>的所有权被转移到<code>main</code>函数中的栈上变量<code>s</code>，<code>create</code>中旧的<code>s</code>变量被销毁时由于其已经不再拥有<code>hello</code>，所以<code>hello</code>没有被释放。</li><li><code>main</code>函数调用<code>consume</code>函数，发生所有权转移，堆上的<code>hello</code>的所有权被转移到<code>consume</code>函数中的栈上变量<code>s</code>，当<code>consume</code>函数结束时，变量<code>s</code>和它拥有的内存<code>hello</code>一起被销毁。</li><li>在<code>main</code>函数的最后一行，如果在调用完<code>consume</code>后再使用变量<code>s</code>，就会产生编译错误。</li></ul><h3 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h3><p>对于某块内存，如果永远都只有一个变量作为入口进行访问的话，那就太难使用了。如果每次函数传参都要传递所有权，若函数调用完毕后还想继续使用该变量，那就要再从函数返回值里将所有权传递出来，而这显然是不合理的。因此，变量的所有权不仅可以被转移（move），还可以被借用（borrow）。借用的含义是在不拥有变量所有权的情况下获得对变量读写的权利，也就是说，借用指针不负责管理变量的生命周期。借用也被称为引用，在Rust中，它们具有相同的含义。</p><p>借用使用<code>&amp;</code>符号或者<code>&amp;mut</code>表示，分别表示只读借用和读写借用。<code>&amp;</code>在C语言中是取地址的意思，在Rust中也一样，借用实际上就是一个指针，其内部数据和C语言中的普通指针一样，都是由一个地址构成，但借用指针的语义不同，它告诉编译器，它对指向的内存区域没有所有权。</p><p>关于借用指针，有以下几个规则：</p><ul><li>借用指针的生命周期不能长于出借方的生命周期</li><li><code>&amp;mut</code>型借用只能指向本身具有<code>mut</code>修饰的变量</li><li><code>&amp;mut</code>型借用指针存在的时候，被借用的变量本身会处于“冻结”状态，即被变量只可读，不可写也不可转移所有权，这保证了在某一个时刻只有一个入口修改对变量的值。</li><li><code>&amp;</code>型借用指针可以存在多个，<code>&amp;mut</code>型借用指针只能存在一个</li></ul><p>下面给出一个简单的借用的示例。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> String <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">consume</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：hello</span>    <span class="token function">consume</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0505]: cannot move out of `s` because it is borrowed</span>    <span class="token function">borrow</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：hello</span><span class="token punctuation">}</span></code></pre><p>对于借用，Rust编译器要确保该借用在使用时原变量仍然是存活的，即借用指针的生命周期不能长于出借方的生命周期，否则会造成悬垂指针。Rust中存在借用检查器（borrow checker）来确保借用的合法性，例如在下面的代码中，<code>r</code>借用了<code>x</code>，但<code>r</code>的生命周期比<code>x</code>要长，因此在<code>x</code>被销毁后<code>r</code>就变成了悬垂指针。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> r<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        r <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0597]: `x` does not live long enough</span>    <span class="token punctuation">}</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"r: {}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的例子只是函数内的借用检查，借用检查器可以获得所有变量的生命周期，因此很容易能推导出<code>r</code>的生命周期比<code>x</code>要长，但对于跨函数的借用检查，借用检查器就无法正确推断所有变量的生命周期了，例如在下面的代码中，<code>borrow</code>函数参数是两个引用，并随机将其中一个返回，在<code>main</code>函数对<code>borrow</code>进行调用的时候，借用检查器并不能够知道<code>borrow</code>返回的是变量<code>a</code>的引用还是变量<code>b</code>的引用，如果是变量<code>a</code>的引用，则<code>r</code>的生命周期合法，若是变量<code>b</code>的引用，则不合法。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">borrow</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token operator">&amp;</span>i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token operator">&amp;</span>i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>i32 <span class="token punctuation">{</span>    <span class="token keyword">let</span> number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> number <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        a    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        b    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> r<span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        r <span class="token operator">=</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"r: {}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实际上，如果编译上面的代码，编译器会在<code>borrow</code>函数处提示一个错误，<code>error[E0106]: missing lifetime specifier</code>，意思是<code>borrow</code>函数缺少生命周期标记。</p><p>生命周期标记，顾名思义，用于对变量的生命周期的长度进行标记，它本身并不改变变量的生命周期，只用于借用检查器来防止悬垂指针。生命周期以单引号<code>&#39;</code>开头，后面跟一个合法的名字，例如<code>&#39;a</code>。生命周期之间可以进行比较，如果生命周期<code>&#39;a</code>比生命周期<code>&#39;b</code>更长或相等，则记为<code>&#39;a : &#39;b</code>。另外，<code>&#39;static</code>是一个特殊的生命周期，其代表从程序开始到结束的整个阶段，所以，对任何一个生命周期<code>&#39;a</code>，都有<code>&#39;static : &#39;a</code>。生命周期标记位于引用符号<code>&amp;</code>的后面，并使用空格来分隔生命周期参数和类型，例如<code>&amp;&#39;a mut i32</code>。</p><p>在函数签名中的生命周期标记写法如下所示，<code>&lt;&#39;a, &#39;b&gt;</code>是生命周期标记的声明，它们在后面的参数和返回值中被使用。此时，Rust借用检查器能够知道<code>borrow</code>返回值的生命周期和其第一个参数<code>a</code>的生命周期相同，因此，便能够对变量<code>r</code>的生命周期进行检查。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> borrow<span class="token operator">&lt;</span><span class="token string">'a, '</span>b<span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token string">'a i32, b: &amp;'</span>b i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>'a i32 <span class="token punctuation">{</span>    a<span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> r<span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        r <span class="token operator">=</span> <span class="token function">borrow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"r: {}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实际上，对于函数来说，如果其参数里没有任何引用，那么它将不能够返回任何的引用（<code>&#39;static</code>标记的引用除外）。因为如果函数参数里没有引用而返回值是引用，则说明该引用必定来自于函数内部的某个变量，这个变量在该函数结束后就会销毁，因此此时再返回其引用就会违反了生命周期规则。</p><p>实际上，每一个借用指针都有一个生命周期标记，只不过在不必要的情况下是可以省略的。Rust有一套自动补全生命周期的机制：</p><ul><li>每个输入位置上省略的生命周期都将成为一个不同的生命周期标记</li><li>如果只有一个带生命周期标记的输入参数，则返回值的生命周期标记和其相同</li><li>如果有多个带生命周期标记的输入参数，但其中有<code>&amp;self</code>或者<code>&amp;mut self</code>，则返回值的生命周期标记和<code>self</code>相同</li><li>以上都不满足，就不能自动补全返回值的生命周期标记，就会产生编译错误</li></ul><p>以上就是所有权系统的基本概念，所有权系统的诞生是为了内存安全服务的，所以其各种设计的理念也源于内存安全，我们以内存安全为线索，便能够将所有权系统深刻理解并彻底掌握。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#5：函数和trait</title>
      <link href="posts/74ae38f8.html"/>
      <url>posts/74ae38f8.html</url>
      
        <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>Rust的函数使用<code>fn</code>关键字开头，函数可以有一系列的输入参数，还有一个返回类型。函数返回可以使用<code>return</code>语句，可以使用表达式。下面是一个标准函数的示例，<code>add</code>函数接受两个<code>i32</code>的参数，然后计算它们的和并返回：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> b<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>    a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span></code></pre><p>函数返回值如果不显示标明，默认是<code>()</code>。函数返回值类型也可以是never类型<code>!</code>，这一类函数叫做发散函数，代表这个函数不能够正常返回，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">diverges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">!</span> <span class="token punctuation">{</span>    <span class="token function">panic!</span><span class="token punctuation">(</span><span class="token string">"This function never return!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>Rust编写的可执行程序的入口是<code>fn main() -&gt; ()</code>函数。一般情况下，一个进程开始执行的时候可以接受一系列的参数，退出的时候也可以返回一个错误码，所以很多编程语言会为<code>main</code>函数设计参数和返回值类型，例如C语言中的<code>int main(int argc, char **argv)</code>。但是，Rust的<code>main</code>函数无参数也无返回值，其传递参数和返回状态码都通过单独的API来完成，示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> arg <span class="token keyword">in</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>env<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Arg: {}"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以通过<code>std::env::args()</code>函数获取参数，通过<code>exit()</code>函数的参数传递错误码，通过<code>std::env::var()</code>读取环境变量。</p><h4 id="函数递归与TCO"><a href="#函数递归与TCO" class="headerlink" title="函数递归与TCO"></a>函数递归与TCO</h4><p>函数递归是我们常用的一种思维方式，Rust也支持函数递归调用。下面用经典的<code>Fibonacci</code>数列来举例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">fib</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> u64 <span class="token punctuation">{</span>    <span class="token keyword">match</span> index <span class="token punctuation">{</span>        <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">,</span>        _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fib</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：75025</span></code></pre><p>谈起递归，我们都会想到尾递归优化的概念（TCO，Tail Call Optimization）。TCO可以把尾递归在编译阶段转换为迭代循环从而降低时间和空间开销，需要注意的是，Rust并不支持TCO，某个RFC的作者给出了以下理由：</p><ul><li>可移植性问题，LLVM当时在某些指定架构上特别是MIPS和WebAssembly，不支持正确尾调用。</li><li>LLVM中正确尾调用实际上可能会由于它们当时的实现方式而造成性能损失。</li><li>TCO让调试变得更加困难，因为它重写了栈上的值。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在一些编程语言中，函数和方法往往是对同一种东西的两种称呼，但在Rust中，它们是有明确区分的。方法和函数的语法完全相同：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该函数时会执行的代码。但是，只有在结构体上下文中被定义的函数才能称为方法。</p><p>方法分为成员方法和静态方法，它们的区别在于第一个参数是否为<code>self</code>，若是则为成员方法，反之为静态方法。Rust中的<code>Self</code>和<code>self</code>都是关键字，其中<code>Self</code>是类型名，<code>self</code>是变量名，<code>self</code>代表调用该方法的结构体实例，静态方法属于结构体类型所有，所以不需要<code>self</code>。常见的<code>Self</code>和<code>self</code>的组合有： <code>self: Self</code>（获得所有权）、<code>self: &amp;Self</code>（仅仅读取）、<code>self: &amp;mut Self</code>（做出修改），因为它们的使用频率很高，Rust也提供了相应的语法糖来简写：<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>。</p><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>可以使用<code>impl</code>为结构体实现成员方法，如下面的代码所示。将函数移到<code>impl</code>块中，并将第一个参数改成<code>self</code>，就把函数变成了成员方法。和其他编程语言类似，调用成员方法只需在结构体示例后加<code>.</code>即可。每个结构体可以拥有多个<code>impl</code>块。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Rectangle <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>    height<span class="token punctuation">:</span> u32<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> Rectangle <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> rect <span class="token operator">=</span> Rectangle <span class="token punctuation">{</span> width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span>        <span class="token string">"The area of the rectangle is {} square pixels."</span><span class="token punctuation">,</span>        rect<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在<code>impl</code>块中定义的不以<code>self</code>作为第一个参数的方法就是静态方法，见下面的代码。可以使用结构体名和<code>::</code>运算符来调用静态方法，例如<code>let sq = Rectangle::square(3);</code>来获得一个大小为3的正方形。</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 接上面</span><span class="token keyword">impl</span> Rectangle <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">square</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-></span> Rectangle <span class="token punctuation">{</span>        Rectangle <span class="token punctuation">{</span> width<span class="token punctuation">:</span> size<span class="token punctuation">,</span> height<span class="token punctuation">:</span> size <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>trait的功能类似于Java中的接口，trait可以翻译为“特性”，它可以为多种类型抽象出共同拥有的一些功能。一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义将方法签名组合起来，目的是定义一个实现某些目的所必需的行为的集合。这些方法既可以是成员方法，也可以是静态方法。trait可以用关键字<code>trait</code>来声明，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Shape <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码声明了一个名为<code>Shape</code>的trait，它有一个名为<code>area</code>的方法，即，若某个类型拥有<code>Shape</code>这个特性，那么它一定可以求面积。为某个类型实现trait使用<code>impl...for</code>关键字，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Rectangle <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>    height<span class="token punctuation">:</span> u32<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">trait</span> Shape <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">impl</span> Shape <span class="token keyword">for</span> Rectangle <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32 <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height    <span class="token punctuation">}</span>    <span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Just say hello!"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> rect <span class="token operator">=</span> Rectangle <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span>        <span class="token string">"The area of the rectangle is {} square pixels."</span><span class="token punctuation">,</span>        rect<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    Rectangle<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>trait中的方法也可以有默认实现，那么在针对具体类型实现的时候，就可以不用重写。我们也可以利用trait为其他类型扩展方法，哪怕这个类型不是我们自己写的。例如，可以为内置类型<code>i32</code>添加一个方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Double <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">impl</span> Double <span class="token keyword">for</span> i32 <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>        <span class="token operator">*</span><span class="token keyword">self</span> <span class="token operator">*</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> i<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span><span class="token function">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：10</span><span class="token punctuation">}</span></code></pre><h4 id="孤儿规则"><a href="#孤儿规则" class="headerlink" title="孤儿规则"></a>孤儿规则</h4><p>使用trait为类型扩展方法也要受到一定的限制，在声明trait和impl trait的时候，Rust规定了一个一致性规则，也称为孤儿规则：impl块要么与trait的声明在同一个crate中，要么与类型的声明在同一个crate中。也就是说，如果trait和类型都来自于外部的crate，那么便不允许为这个类型实现该trait。这是因为，该类型没有实现该trait，这可能是该类型作者有意的设计，强行实现可能会导致bug。</p><h4 id="trait和接口的区别"><a href="#trait和接口的区别" class="headerlink" title="trait和接口的区别"></a>trait和接口的区别</h4><p>之前我们说trait和接口在功能上类似，但它们在使用中是有区别的。trait本身不是具体类型，也不是指针类型，它只是定义了针对类型的抽象的约束，不同的类型可以实现同一个trait，而这些类型可能具有不同的大小，因此trait在编译阶段没有固定大小，所以，Rust中不能直接使用trait作为实例变量、参数和返回值，这一点和接口的习惯用法是不同的。例如，下面的代码就是编译错误的：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Shape <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> u32<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">test</span><span class="token punctuation">(</span>shape<span class="token punctuation">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// error[E0277]: the size for values of type `(dyn Shape + 'static)` cannot be known at compilation time</span></code></pre><h4 id="trait继承"><a href="#trait继承" class="headerlink" title="trait继承"></a>trait继承</h4><p>trait允许继承，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">trait</span> Derived<span class="token punctuation">:</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>这表示<code>Derived</code>继承了<code>Base</code>，它意味着，满足<code>Derived</code>的类型，必然也满足<code>Base</code>，所以，在针对一个具体类型<code>impl Derived</code>的时候，编译器也会要求同时<code>impl Base</code>，否则会报编译错误：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">trait</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">trait</span> Derived<span class="token punctuation">:</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">struct</span> T<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// error[E0277]: the trait bound `T: Base` is not satisfied</span><span class="token keyword">impl</span> Derived <span class="token keyword">for</span> T <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="常见trait简介"><a href="#常见trait简介" class="headerlink" title="常见trait简介"></a>常见trait简介</h3><p>标准库中有很多常见且很有用的trait，我们一起学习一下。</p><h4 id="Display和Debug"><a href="#Display和Debug" class="headerlink" title="Display和Debug"></a>Display和Debug</h4><p><code>Display</code>和<code>Debug</code>的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Display <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Formatter<span class="token operator">&lt;</span>'_<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> Debug <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> Formatter<span class="token operator">&lt;</span>'_<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这两个trait主要用在类似<code>println!</code>这样进行输出的地方。只有实现了<code>Display</code>的类型，才能用<code>&#123;&#125;</code>格式打印出来；只有实现了<code>Debug</code>的类型，才能用<code>&#123;:?&#125;</code>和<code>&#123;:#?&#125;</code>格式打印出来。它们之间的更多区别如下：</p><ul><li><code>Display</code>假定了这个类型可以用<code>utf-8</code>格式的字符串表示，它是准备给最终用户看的，并不是所有的类型都应该实现这个trait。标准库中还有一个常用的trait叫作<code>std::string::ToString</code>，对于所有实现<code>Display</code>的类型， 都自动实现了这个<code>ToString</code>trait，它包含了一个<code>to_string(&amp;self)-&gt;String</code>方法。</li><li><code>Debug</code>主要是为了调试使用，建议所有的作为API的公开类型都应当实现这个trait，以方便调试。</li></ul><h4 id="PartialOrd-Ord-PartialEq-Eq"><a href="#PartialOrd-Ord-PartialEq-Eq" class="headerlink" title="PartialOrd/Ord/PartialEq/Eq"></a>PartialOrd/Ord/PartialEq/Eq</h4><p>我们首先介绍一下全序和偏序的概念。对于集合<code>X</code>中的元素<code>a,b,c</code>：</p><ul><li>如果<code>a &lt; b</code>则一定有<code>!(a &gt; b)</code>，称为反对称性；</li><li>如果<code>a &lt; b</code>且<code>b &lt; c</code>则一定有<code>a &lt; c</code>，称为传递性；</li><li>对于<code>X</code>中的所有元素，都存在<code>a &lt; b</code>或<code>a &gt; b</code>或者<code>a == b</code>，三者必居其一，称为完全性。</li></ul><p>如果集合中的元素只具备上述前两条特征，则称<code>X</code>是偏序；同时具备以上所有特征，则称<code>X</code>是全序。</p><p>Rust设计了两个trait来对全序和偏序进行描述，<code>PartialOrd</code>代表偏序，<code>Ord</code>代表全序。只有满足全序的类型才可以进行排序，像浮点数这样的偏序类型就无法排序。同理，<code>PartialEq</code>用来描述只能部分元素进行相等比较，<code>Eq</code>表示全部元素都可以进行相等比较。这样的设计可以让我们在更早的阶段发现错误。</p><h4 id="Sized"><a href="#Sized" class="headerlink" title="Sized"></a>Sized</h4><p>这个trait表示类型是否有大小，它定义在<code>std::marker</code>模块中，它没有任何的成员方法，它与普通trait不同，编译器对它有特殊处理，用户也不能针对自己的类型实现这个trait。一个类型是否满足<code>Sized</code>约束完全是由编译器推导的，用户无权指定。</p><h4 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h4><p>Rust中没有C++中构造函数的概念，因为相比普通函数，构造函数本身并没有提供额外的抽象能力，反倒增加了语法上的负担，因此，Rust推荐使用普通的静态函数作为类型的构造器，例如<code>String::new()</code>。对于那种无参数无错误处理的简单情况，标准库提供了<code>Default</code>来做统一抽象，其定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> Default<span class="token punctuation">:</span> Sized <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Self<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="属性与derive"><a href="#属性与derive" class="headerlink" title="属性与derive"></a>属性与derive</h3><p>Rust中有一种语法，属性（attribute），基本格式类似于<code>#[xxx]</code>。属性可以用来注释声明，类似于Java中的注解。有一种非常实用的属性<code>derive</code>，可以帮助我们自动<code>impl</code>某些trait，因为实现某些<code>trait</code>的时候，逻辑是非常机械化的，例如<code>Debug</code>。示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">struct</span> Rectangle <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> u32<span class="token punctuation">,</span>    height<span class="token punctuation">:</span> u32<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> rect <span class="token operator">=</span> Rectangle <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出：Rectangle { width: 10, height: 20 }</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> rect<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>目前，Rust支持的可以自动<code>derive</code>的trait有以下这些：</p><pre class=" language-rust"><code class="language-rust">Debug Clone Copy Hash RustcEncodable RustcDecodable PartialEq Eq ParialOrd Ord Default FromPrimitive Send Sync</code></pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#4：语句和表达式</title>
      <link href="posts/5c979c5.html"/>
      <url>posts/5c979c5.html</url>
      
        <content type="html"><![CDATA[<p>严格的说，Rust中的所有东西只分为两类：表达式（Expression）和语句（Statement）。</p><ul><li>表达式：在维基百科的<a href="https://en.wikipedia.org/wiki/Expression_(computer_science)">定义</a>中，表达式是指由变量、常量和操作符等组合成的可求值的语法实体。</li><li>语句：语句分为声明语句和表达式语句两种。声明语句用于声明变量、结构体、函数等各种项以及通过<code>use</code>等关键字引入包等。表达式语句，由一个表达式和一个分号组成，即在表达式后面加一个分号就将一个表达式转变为了一个语句。</li></ul><p>可见，表达式在Rust中扮演了至关重要的角色，Rust基本上就是一个表达式语言。在Rust程序中，表达式可以是语句的一部分，反过来，语句也可以是表达式的一部分。<strong>一个表达式总是会产生一个值，因此它必然有类型</strong>；语句不产生值，它的类型永远是<code>()</code>。如果把一个表达式加上分号，那么它就变成了一个语句；如果把语句放到一个语句块中包起来，那么它就可以被当成一个表达式使用。</p><h3 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h3><p>从传统意义上讲，表达式的作用就是求值，它除了产生一个计算结果外，不应该改变参与计算过程的任何变量的值，这样的表达式称为无副作用的表达式。若一个表达式在求值过程中，改变了所使用的变量的值，则这样的表达式称为有副作用的表达式。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 没有改变任何变量的值，其为无副作用的表达式</span><span class="token number">5</span> <span class="token operator">+</span> x <span class="token comment" spellcheck="true">// 改变了变量y的值，其为有副作用的表达式</span>y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span> </code></pre><p>表达式语句就是表达式副作用的重要应用。任何表达式加一个分号都可以作为一个语句来使用，但无副作用的表达式语句没有任何意义，例如<code>5+x;</code>这个表达式语句就没有意义。</p><p>Rust有很多种表达式类型，具体可参见《Rust Reference》，点击<a href="https://doc.rust-lang.org/reference/expressions.html">这里</a>。下面介绍几种常见的表达式。</p><h3 id="运算表达式"><a href="#运算表达式" class="headerlink" title="运算表达式"></a>运算表达式</h3><p>运算表达式是含有运算符的表达式。运算符可分为以下几类：</p><ul><li>算术运算符：加（<code>+</code>），减（<code>-</code>），乘（<code>*</code>），除（<code>/</code>），求余（<code>%</code>）</li><li>比较运算符：等于（<code>==</code>），不等于（<code>!=</code>），小于（<code>&lt;</code>），大于（<code>&gt;</code>），小于等于（<code>&lt;=</code>），大于等于（<code>&gt;=</code>）。比较表达式的类型是<code>bool</code>。</li><li>逻辑运算符：逻辑与（<code>&amp;&amp;</code>），逻辑或（<code>||</code>），逻辑取反（<code>!</code>）</li><li>位运算符：按位取反（<code>!</code>），按位与（<code>&amp;</code>），按位或（<code>|</code>），按位异或（<code>^</code>），左移（<code>&lt;&lt;</code>），右移（<code>&gt;&gt;</code>）</li><li>复合运算符： <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>和 <code>&gt;&gt;</code>都可以和<code>=</code>组成复合运算符</li></ul><p>这些运算符的用法和C/C++中基本一致，需要注意的是以下两点：</p><ul><li>Rust禁止连续比较，例如<code>a == b == c</code>这是错误的，必须要加上括号才行。这样设计对减少歧义有很大好处。</li><li>按位取反和逻辑取反都是运算符<code>!</code>：如果被操作数是<code>bool</code>类型，则是逻辑取反，其他情况是按位取反。</li></ul><p>关于运算符之间优先级的细微知识这里就不展开讲了，因为不论在哪种编程语言中，我都建议，如果碰到复杂的表达式，要使用小括号来明确表达计算顺序。</p><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>一个左值表达式、赋值运算符（<code>=</code>）和右值表达式，可以构成一个赋值表达式。关于左值右值的知识可以参考《Rust学习笔记#2：变量声明、绑定与引用》。需要注意的是，赋值表达式的类型为<code>()</code>，这和C语言是不同的，C语言中赋值表达式的类型是左值表达式的类型。这样设计的好处有两点：</p><ul><li>防止连续赋值：<code>x = y = z</code>会产生编译错误，因为赋值运算符<code>=</code>要求两边的表达式同类型，而<code>y = z</code>是<code>()</code>类型所以会产生编译错误。</li><li>防止把<code>==</code>写成<code>=</code>：Rust中要求条件表达式的类型必须为<code>bool</code>，而赋值表达式的类型是<code>()</code>，会产生编译错误。</li></ul><h3 id="语句块表达式"><a href="#语句块表达式" class="headerlink" title="语句块表达式"></a>语句块表达式</h3><p>语句块由<code>&#123;&#125;</code>构成，其类型是语句块中最后一个表达式的类型。也就是说，如果最后一个表达式带了分号，那么语句块的类型就是语句的类型<code>()</code>；如果没带，就是表达式的类型。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x的类型为()</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x的类型为i32</span></code></pre><p>这样设计的好处是在写函数返回值时可以直接去掉最后一个语句的分号作为返回值，而不必写<code>return</code>。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>    <span class="token number">100</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">fn</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p><code>if-else</code>表达式在C语言中也有，我们这里讲一些不一样的地方：</p><ul><li><p><code>if-else</code>后必须要有大括号，不得省略，这样可以避免悬空<code>else</code>所导致的bug。</p></li><li><p>条件表达式不需要用小括号括起来，如果加上小括号，编译器会提示这是一个多余的小括号。</p></li><li><p><code>if-else</code>表达式的所有分支必须返回同一个类型的值，<code>if-else</code>的求值策略和语句块表达式相同。如果<code>else</code>分支省略，则默认<code>else</code>分支的类型为<code>()</code>。见下面的例子：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">if</span> a <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">{</span>    a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    a <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span></code></pre></li></ul><h3 id="循环表达式"><a href="#循环表达式" class="headerlink" title="循环表达式"></a>循环表达式</h3><p>Rust中包括三种循环表达式：<code>while</code>、<code>loop</code>和<code>for...in</code>，其用法和其他编程语言相应的表达式基本类似，也可以使用<code>continue</code>和<code>break</code>控制循环流程。注意，Rust中没有C语言中那种三段式<code>for</code>循环，这里的<code>for...in</code>本质上就是一个迭代器。</p><p><code>loop</code>表示一个无限死循环，<code>while</code>是带条件判断的循环语句。注意，<code>loop</code>和<code>while true</code>是不同的。相对于其他语言，Rust要做更多的静态分析，Rust认为<code>while</code>循环的条件可真可假，所以循环体里的表达式也会忽略不会进行分析，看下面的示例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0381]: borrow of possibly-uninitialized variable: `x`</span></code></pre><p>Rust无法得知变量<code>x</code>的值在<code>while</code>循环块里被初始化过，从而会报使用未初始化变量的错。</p><h3 id="match表达式"><a href="#match表达式" class="headerlink" title="match表达式"></a>match表达式</h3><p>Rust提供了<code>match</code>表达式用于匹配各种情况，有点类似于C语言中的<code>switch...case</code>语句，但功能更加强大。先看一个简单的<code>match</code>示例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>    East<span class="token punctuation">,</span>    West<span class="token punctuation">,</span>    South<span class="token punctuation">,</span>    North<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> x <span class="token operator">=</span> Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East<span class="token punctuation">;</span><span class="token keyword">match</span> x <span class="token punctuation">{</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"East"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>West <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"West"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>South <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"South"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>North <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"North"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：East</span></code></pre><p>上面的用法和<code>switch...case</code>语句很类似，下面讲讲不一样的地方：</p><ul><li><p>exhaustive特性：exhaustive的意思是无遗漏的，也就是说，Rust要求<code>match</code>必须对所有的情况做完整的、无遗漏的匹配，如果漏掉了某些情况，是不能通过编译的。这样做的好处是可以强迫程序员对所有的情况进行考虑，从而减少bug的发生。</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 同上面的代码</span><span class="token keyword">match</span> x <span class="token punctuation">{</span>     Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"East"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>West <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"West"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>South <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"South"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// error[E0004]: non-exhaustive patterns: `North` not covered</span></code></pre></li><li><p>下划线：当不想把每种情况一一列出时，可以用一个下划线来表达“除了列出来的那些之外的其他情况”。下划线存在的另外一个意义是，如果我们引用了他人的库中的某个<code>enum</code>类，但该类添加了新成员，这就会导致我们的代码编译失败。因此，不论何时，都推荐使用下划线作为容错措施。</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 同上面的代码</span><span class="token keyword">match</span> x <span class="token punctuation">{</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"East"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Else"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：East</span></code></pre></li><li><p>match可以作为表达式，但要求其每一个分支都返回相同的类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East<span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">match</span> x <span class="token punctuation">{</span>    Direction<span class="token punctuation">:</span><span class="token punctuation">:</span>East <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">,</span>    _ <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1</span></code></pre></li><li><p>可以使用范围作为匹配条件：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">'X'</span><span class="token punctuation">;</span><span class="token keyword">match</span> x <span class="token punctuation">{</span>    <span class="token string">'a'</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token string">'z'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"lowercase"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'A'</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token string">'Z'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"uppercase"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"something else"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：uppercase</span></code></pre></li><li><p>可以使用<code>if</code>作为匹配条件，当匹配成功且符合<code>if</code>条件时，才执行后面的语句：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">match</span> x <span class="token punctuation">{</span>    <span class="token function">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span>    _ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Nothing!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出：Nothing!</span></code></pre></li></ul><p>另外，Rust提供了<code>if let</code>语法糖来简化某些情况下的<code>match</code>表达式。如果我们有一个<code>Option&lt;T&gt;</code>类型的变量<code>opt_val</code>，如果我们需要取出里面的值，可以这样做：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">match</span> opt_val <span class="token punctuation">{</span>    <span class="token function">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// handle x</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    _ <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>但这样写比较冗长，而使用<code>if let</code>语法，可以这样做：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> opt_val <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// handle x</span><span class="token punctuation">}</span></code></pre><p><code>if let</code>的语法为：<code>if let PATTERN = EXPRESSION &#123;BODY&#125;</code>，它和<code>match</code>的区别是：它不需要完整匹配，只匹配感兴趣的某个特定分支即可。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#3：类型</title>
      <link href="posts/879d15dc.html"/>
      <url>posts/879d15dc.html</url>
      
        <content type="html"><![CDATA[<p>类型于20世纪50年代被FORTRAN语言引入，发展到今日，类型已经成为了各大编程语言的核心基础，Rust也不例外。所谓类型，就是对表示信息的值进行的细粒度的区分，比如整数、小数、文本等。不同的类型占用的内存不同，与直接操作比特位相比，直接操作类型可以更安全更有效地利用内存 。</p><p>Rust是一个<strong>强显式静态类型</strong>的语言。下面解释一下何为“强显式静态类型”：</p><ul><li>在编译期进行类型检查的语言属于静态类型，在运行期进行类型检查的语言属于动态类型。</li><li>不允许类型的自动隐式转换的语言属于强类型，反之则是弱类型。</li><li>在静态类型语言中，依靠编译器自动推导类型而不需要显式指定类型的语言属于显式静态类型，反之则是隐式。Rust的编译器具有自动推导类型的能力，但还不够强大，在很多地方仍需要显式指定类型，类型仍然是Rust语法的一部分。</li></ul><p>Rust中一切皆表达式，表达式皆有值，值皆有类型，因此，Rust中一切皆类型。Rust中包含基本的原生类型和复合类型，也包含线程崩溃等无返回值的never类型。Rust类型系统吸收百家之长，基本囊括了编程中会遇到的各种情况，一般不会有未定义的行为出现，所以说，Rust是类型安全的语言。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p> Rust内置了布尔类型，类型名为<code>bool</code>，它有两个值：<code>true</code>和<code>false</code>。示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不显示声明类型，自动推断x为bool类型</span><span class="token keyword">let</span> y<span class="token punctuation">:</span> bool <span class="token operator">=</span> <span class="token operator">!</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取反运算</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 逻辑与，带短路功能</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">||</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 逻辑或，带短路功能</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">&amp;</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位与</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">|</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位或</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按位异或</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用布尔值的主要场景是条件表达式，但注意，Rust并不支持将数字转换为<code>bool</code>类型。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> x <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// error[E0308]: mismatched types, expected `bool`, found integer</span></code></pre><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>字符类型由<code>char</code>表示，用单引号定义，代表一个unicode标量值。由于<code>char</code>类型的设计目的是描述任意一个unicode字符，所以它占据的空间不是1个字节，而是4个字节。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> heart_eyed_cat <span class="token operator">=</span> <span class="token string">'😻'</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> heart_eyed_cat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>Rust中，各种整数类型之间的主要区分特征是：有符号/无符号，占据空间大小。</p><table><thead><tr><th align="center">长度</th><th align="center">有符号</th><th align="center">无符号</th></tr></thead><tbody><tr><td align="center">8-bit</td><td align="center"><code>i8</code></td><td align="center"><code>u8</code></td></tr><tr><td align="center">16-bit</td><td align="center"><code>i16</code></td><td align="center"><code>u16</code></td></tr><tr><td align="center">32-bit</td><td align="center"><code>i32</code></td><td align="center"><code>u32</code></td></tr><tr><td align="center">64-bit</td><td align="center"><code>i64</code></td><td align="center"><code>u64</code></td></tr><tr><td align="center">128-bit</td><td align="center"><code>i128</code></td><td align="center"><code>u128</code></td></tr><tr><td align="center">arch</td><td align="center"><code>isize</code></td><td align="center"><code>usize</code></td></tr></tbody></table><p>有无符号代表数字能否为负值：</p><ul><li>有符号：每一个有符号的类型的表达范围为 [$-2^{n-1}$,  $2^{n-1} - 1$]，其中n为类型的长度。</li><li>无符号：每一个无符号的类型的表达范围为 [0,  $2^n - 1$]，其中n为类型的长度。</li></ul><p>另外，<code>isize</code>和<code>usize</code>依赖于运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。其他一些琐碎的知识点一并体现在下面的代码注释中：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 若编译器无法推断变量的具体类型，则自动默认为i32类型</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0x开头代表十六进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0o开头代表八进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0o55</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以0b开头代表二进制表示</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">0b1001</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可在数字字面量中任意地方添加下划线，以方便阅读</span><span class="token keyword">let</span> var <span class="token operator">=</span> 0x_1234_ABCD<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 字面量后面可以添加后缀，以标明具体类型</span><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token number">32u8</span><span class="token punctuation">;</span></code></pre><p>Rust的数字表达策略和C语言不同，C语言标准中对许多类型的大小并没有做强制规定，比如<code>int</code>类型在不同平台上可能是不同的大小，这给程序员带来了许多不必要的麻烦。相反，Rust在语言标准中规定好各个类型的大小，让编译器针对不同平台做适配，生成不同的代码，是更合理的选择。</p><p>整数运算中有一个让人头疼的问题是“溢出”。在C语言中，对于无符号类型，如果超过表示范围，则自动舍弃高位数据；对于有符号类型，如果超过表示范围，C标准规定这是未定义行为，这就是说编译器随便怎么处理都可以。未定义行为有利于编译器做一些更激进的性能优化，但这容易在极端场景下产生诡异的bug。</p><p>Rust的设计思路更倾向于预防bug，而不是无条件地压榨效率，Rust设计者希望尽可能减少整数溢出这种未定义行为。Rust的处理方式如下：</p><ul><li>debug模式：编译器会自动插入整数溢出检查，一旦发生溢出，则会引发panic（一种崩溃机制，暂且不表）;</li><li>release模式：不检查整数溢出，而是采用自动舍弃高位的方式。</li></ul><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>Rust提供了基于IEEE 754标准的浮点类型，按占据空间大小区分，分别为<code>f32</code>和<code>f64</code>，其使用方法与整型差别不大。如果不加后缀或没有指定类型，Rust会默认推断浮点数为<code>f64</code>类型，因为在现代CPU中，它与<code>f32</code>速度几乎一样，且精度还更高。</p><ul><li><code>f32</code>：数值范围为[$-3.4\times 10^{38}$, $3.4\times 10^{38}$]​</li><li><code>f64</code>：数值范围为[$-1.8\times 10^{308}$, $1.8\times 10^{308}$]</li></ul><p>浮点类型相对于整数类型的麻烦之处在于：它不仅可以表达正常的数值，还可以表达不正常的数值。参见下面的代码：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token operator">/</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}, y is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码的输出结果为<code>x is inf, y is NaN</code>，<code>inf</code>代表无穷大（infinite），<code>NaN</code>代表不是数字（Not a Number）。在标准库中，有一个<code>std::num::FpCategory</code>枚举类，表示了浮点数可能的状态：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> FpCategory <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// "Not a Number", often obtained by dividing by zero.</span>    Nan<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Positive or negative infinity.</span>    Infinite<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Positive or negative zero.</span>    Zero<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// De-normalized floating point representation (less precise than `Normal`).</span>    Subnormal<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// A regular floating point number.</span>    Normal<span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h4 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h4><p>我们一般将表示内存地址的类型称为指针。例如之前学习过的引用，它本质上就是一种非空指针，编译器会对引用进行借用检查，以保证内存安全和类型安全。原生指针主要用于<code>unsafe</code>代码块中，直接使用原生指针是不安全的，因为其可能为null，所以需要程序员自己保证安全。<code>unsafe</code>距离我们还很遥远，所以原生指针相关的只是暂且不表。</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是Rust内建的原始集合类型 ，数组的类型签名是<code>[T:N]</code>，其中T代表数组中元素的类型，N代表数组的长度，N为编译期常量，必须在编译时确定其值。对于两个数组类型，只有元素类型和元素个数都完全相同，这两个数组才是同类型的，才可以互相赋值。数组的特点为：</p><ul><li>数组大小固定</li><li>元素均为同类型</li><li>默认不可变</li></ul><p>Rust 中，数组中的值位于中括号内的逗号分隔的列表中。下面代码中定义了类型为<code>[i32; 3]</code>的数组，该数组是固定长度的，不允许对其添加或删除元素。即使通过<code>let mut</code>关键字定义，也只能修改已存在于索引位上的元素。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[1, 2, 3]</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[4, 2, 3]</span></code></pre><p>如果希望创建一个每个元素都相同的数组，可以在中括号内指定其初始值，后跟分号，再后跟数组的长度，如下所示：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出[3, 3, 3, 3, 3]</span></code></pre><p>Rust会在编译期尽可能地检查数组索引是否小于数组的长度，如果发现问题，会报编译错误：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: index out of bounds</span></code></pre><p>但静态分析的能力有限，数组越界错误不能够全部在编译期查出来，Rust会在运行时继续检查索引是否小于数组的长度，如果超出，则会panic。</p><p>一般情况下，<strong>Rust不鼓励大量使用索引操作</strong>，因为索引操作都会执行一次边界检查，所以其效率会比不执行边界检查的C/C++略低，更推荐的做法是使用迭代器。</p><h4 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h4><p>Rust内置了范围（Range）类型，包括左闭右开和全闭两种区间，语法为<code>begin..end</code>。<code>1..5</code>表示左闭右开区间，它是<code>std::ops::Range</code>的实例；<code>1..=5</code>表示全闭区间，它是<code>std::ops::RangeInclusive</code>的实例。每个<code>Range</code>都是一个迭代器，可以直接使用<code>for</code>循环进行打印：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片类型（Slice）是对一个数组的引用片段，切片代表一个指向数组起始位置的指针和数组长度。切片有利于安全有效地访问数组的一部分，因为切片引用的是已经存在的变量。使用引用操作符<code>&amp;</code>对数组进行引用，就产生了一个切片，也可以结合范围类型对数组进行切割：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：[1, 2, 3, 4, 5]</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：[3, 4]</span></code></pre><p>对于数组<code>[T;N]</code>，其借用指针的类型是<code>&amp;[T;N]</code>，但其切片的类型是<code>&amp;[T]</code>。<code>&amp;[T;N]</code>占用的空间大小和普通引用相同，而<code>&amp;[T]</code>占用的空间大小是普通引用的两倍：</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;i32 size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span>i32<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;i32 size is 8</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;[i32; 3] size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;[i32; 3] size is 8</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"&amp;[i32] size is {}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token punctuation">[</span>i32<span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：&amp;[i32] size is 16</span></code></pre><p>可以看到，数组切片的大小的确是普通引用的两倍，因为数组切片不止包含一个指向数组的指针，切片本身还含带长度信息。因此，切片还有一个非常形象的名字：胖指针（fat pointer）。胖指针的设计，避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题，保证了类型安全。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>出于内存安全的考虑，Rust提供了两种字符串类型：一种是固定长度字符串，不可以随便更改其长度，就是<code>str</code>字符串；另一种是可增长字符串，可以随便改变其长度，就是<code>String</code>字符串。</p><p>说到<code>str</code>，就不得不提到一个概念，动态大小类型（Dynamic Sized Type，DST），是指在编译阶段无法确定占用空间大小的类型。为了安全，指向DST的指针一般是胖指针。<code>str</code>就是DST类型，我们不能在栈上声明一个不定长大小的变量示例，也不能用它作为函数的参数和返回值。但是，<code>&amp;str</code>的大小是确定的，因此，<code>&amp;str</code>类型可以用作变量实例、函数参数和返回值。<code>&amp;str</code>又被称作字符串切片类型，平时对字符串常量的绑定也是获得的其切片：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">"jack"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：jack</span></code></pre><p>Rust的字符串内部默认使用<code>utf-8</code>编码格式，而内置的<code>char</code>类型是4字节的unicode，所以Rust里面的字符串不能视为<code>char</code>类型的数组，而更接近<code>u8</code>类型的数组。这样设计的缺点是不能支持<code>O(1)</code>复杂度的索引操作，它的复杂度是<code>O(n)</code>，因为<code>utf-8</code>是变长编码，如果不从头开始过一遍，根本不知道第n个字符的地址在什么地方。</p><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p>Rust提供了一种特殊数据类型，never类型，用<code>!</code>表示，代表永远不可能有返回值的计算类型，比如线程退出的时候，就不可能有返回值。Rust是一个类型安全的语言，所以也需要将这种情况纳入类型系统中进行统一管理。见下面的代码：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token keyword">match</span> num <span class="token punctuation">{</span>    <span class="token function">Some</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> num<span class="token punctuation">,</span>    None <span class="token operator">=</span><span class="token operator">></span> <span class="token function">panic!</span><span class="token punctuation">(</span><span class="token string">"Nothing!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：42</span></code></pre><p>上面的代码中使用了一种当下还没学到的语法，不过不必在意，只需知道<code>match</code>表达式要求所有的分支都必须返回相同的类型，而<code>num</code>是<code>i32</code>类型，<code>panic!</code>宏会返回<code>!</code>类型，但这里没有报错，是因为never类型是可以强制转换为其他任何类型的。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>为了防止隐藏的bug，Rust希望类型转换时要显式地标记出来，类型转换使用关键字<code>as</code>。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a<span class="token punctuation">:</span> i8 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> i16 <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error[E0308]: mismatched types</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> i16 <span class="token operator">=</span> a <span class="token keyword">as</span> i16<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确写法</span></code></pre><p>注意，<code>as</code>关键字也不是随便可以用的，它只允许编译器认为合理的类型转换。对于表达式<code>e as U</code>，下图中是所允许的类型转换。</p><p><img src="../images/10.png"></p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Rust提供了3种常用的复合数据类型，且都是异构数据类型，即可以使用它们将多种类型构建为统一的数据类型：</p><ul><li>元组（Tuple）</li><li>结构体（Struct）</li><li>枚举体（Enum）</li></ul><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p><code>tuple</code>指的是“元组”类型，它通过圆括号包含一组表达式构成，<code>tuple</code>内的元素没有名字，<code>tuple</code>是把几个类型组合到一起的最简单的方式。访问<code>tuple</code>内部元素可以通过模式匹配或者数字索引。示例如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有一个元素的元组要加一个逗号以区分表达式和元组</span><span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模式匹配访问元组元素</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> p<span class="token number">.0</span><span class="token punctuation">,</span> p<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数字索引访问元组元素</span></code></pre><p>元组内部也可以一个元素都没有，称为<code>unit</code>，占用0内存空间。</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>mem<span class="token punctuation">:</span><span class="token punctuation">:</span>size_of<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：0</span></code></pre><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p><code>struct</code>和<code>tuple</code>的区别是它的每个元素都有自己的名字，每个元素之间采用逗号分开，类型依旧跟在冒号后面，但必须显示指定不能省略：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> Point <span class="token punctuation">{</span>    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>    y<span class="token punctuation">:</span> i32<span class="token punctuation">}</span></code></pre><p><code>struct</code>类型的初始化使用<code>成员-冒号-值</code>的方式，如果有局部变量名字恰好和成员名字一致，则可以省略成员名字：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> p <span class="token operator">=</span> Point<span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">let</span> p <span class="token operator">=</span> Point<span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>访问结构体内部的元素使用“点”加变量名的方式，也可以使用模式匹配。</p><h4 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h4><p><code>tuple</code>本身和其元素都没有名字，<code>struct</code>本身和其元素都有名字，<code>tuple struct</code>本身有名字，但其元素没有名字：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token function">Color</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> i32<span class="token punctuation">,</span> i32<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>tuple struct</code>有一个特殊的用法，即当它只包含一个元素的时候，就是所谓的<code>newtype idiom</code>，可以让我们很方便地在一个类型的基础上创建一个新的类型。</p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>与C/C++中的枚举相比，Rust中的<code>enum</code>要强大得多，它可以为每个成员指定附属的类型信息。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> Number <span class="token punctuation">{</span>    <span class="token function">Int</span><span class="token punctuation">(</span>i32<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">Float</span><span class="token punctuation">(</span>f32<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p><code>enum</code>中每个元素可以像空结构体一样，不指定它的类型；也可以像<code>tuple struct</code>一样，用圆括号加无名成员；还可以像正常结构体一样，用大括号加带名字的成员。</p><p>Rust标准库中有一个极其常用的<code>enum</code>类型<code>Option&lt;T&gt;</code>，它的定义如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">enum</span> Option<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    None<span class="token punctuation">,</span>    <span class="token function">Some</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>其中T代表的是类型，这是一种泛型的写法。<code>Option&lt;T&gt;</code>的含义是“要么存在，要么不存在”，可以有效提升程序的健壮性。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#2：变量声明、绑定与引用</title>
      <link href="posts/f80c8a5a.html"/>
      <url>posts/f80c8a5a.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Rust中的变量分局部变量和全局变量两种，且必须先声明后使用，常见的声明语法为：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 声明局部变量，使用let关键字</span><span class="token keyword">let</span> var<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明全局变量，使用static关键字</span><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </code></pre><p>由于Rust非常注重内存安全，因此全局变量的使用有许多限制，我们日常使用最多的还是局部变量。与传统的C/C++语言相比，Rust的变量声明语法不同，这样设计主要有下列三种优点：</p><ul><li>语法分析更容易：Rust的局部变量声明一定是以关键字<code>let</code>开头，类型一定跟在<code>:</code>后面，语法歧义更少，语法分析器更容易编写。</li><li>类型推导更方便：Rust的变量声明的一个重要特点是，要声明的变量前置，对它的类型描述后置。这是吸取了其他语言的教训后的结果，因为在变量声明语句中，最重要的是变量本身，类型只是附属的额外描述，并非必不可少的部分，类型可以由编译器自动推导获得，因此类型后置的语法更合适。</li><li>支持模式解构：<code>let</code>不仅能声明局部变量，还具有模式结构（pattern destructure）的功能，这里暂且不表。</li></ul><p>Rust中变量声明默认是“只读”的，如果需要让变量可写，则需要使用<code>mut</code>关键字，<code>mut</code>是<code>mutable</code>的简写：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x为只读变量，因此会报编译错误</span><span class="token keyword">let</span> <span class="token keyword">mut</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用mut关键字声明一个可写变量</span>y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>Rust中变量必须被初始化后才可以使用，否则会报编译错误。因此，不被初始化的变量是没有默认值的。变量既可以在声明时初始化，也可以在使用前初始化：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> i32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明变量x</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化变量x，不需要x是mut，因为这是初始化不是修改</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>不过，为了减少代码阅读的负担，笔者还是建议在变量声明时就初始化。</p><p>Rust中的合法标识符（包括变量名、函数名等）必须由数字、字母、下划线组成，且不能以数字开头。注意，单独的下划线是一个特殊的标识符，在编译器内部是被特殊处理的，不能作为普通变量使用，其具体用法这里暂且不表。Rust中关于变量的命名规范是蛇形命名法，使用下划线，一般用小写，即<code>file_name</code>。</p><h4 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h4><p>Rust中允许在同一个代码块中声明同样名字的变量，如果这样做，后面声明的变量会将前面声明的变量遮蔽（Shadowing）起来，从而前面的变量将无法访问。例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面这种形式的代码在很多编程语言中是无法编译通过的，因为变量x被重复声明，但在Rust中是可以编译通过的：前后两个<code>x</code>是完全不同的两个变量，内存空间不同，类型也不同，只是恰巧名字相同。</p><p>Rust这种设计有时非常实用，例如，我们需要在同一个函数内部把一个变量转换为另一个类型的变量，但又不想给它们起不同的名字。但是，我个人认为变量遮蔽可能会带来阅读代码时的歧义，不建议滥用，建议有限使用，例如函数参数是字符串类型的<code>file_path</code>，这是使用变量遮蔽将其转换为Path类型的<code>file_path</code>就比较合适。但以我现在的水平尚不能仔细分析变量遮蔽这一特性的利弊权衡，或许未来能够在RFC中找到答案。</p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>Rust编译器的类型推导功能很强大，不仅可以从变量声明的当前语句中获取信息进行推导，而且还能通过上下文信息进行推导。类型推导和“动态类型”是两码事，Rust仍然是静态类型的，所有变量的类型都必须在编译阶段确定，类型推导只是辅助我们在某些情况下不需要显示写出类型而已。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用<code>type</code>关键字给同一个类型起个别名，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">type</span> Age <span class="token operator">=</span> u32<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// u32代表无符号的32位整数类型</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> Age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>可以用<code>static</code>关键字声明静态变量，这也是Rust中唯一的声明全局变量的方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">static</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>为了保证内存安全，全局变量的使用有很多限制：</p><ul><li>必须在声明时立即初始化</li><li>初始化必须是编译期可确定的常量</li><li>带有<code>mut</code>修饰的全局变量，在使用的时候必须使用<code>unsafe</code>关键字。</li></ul><p><code>unsafe</code>关键字用于逃过Rust编译器的检查以写一些可能存在危险的代码，当下无须深入研究。从上面第三条限制可以看出，Rust并不鼓励我们使用可变的全局变量，更希望我们把全局变量用成全局常量。注意，全局变量的声明周期是整个程序从启动到退出。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>可以使用<code>const</code>关键字声明一个常量：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">const</span> GLOBAL<span class="token punctuation">:</span> i32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>常量和静态变量最大的区别在于：编译器不一定会给常量分配内存空间，可能会在编译过程中将常量內联优化。</p><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>通过<code>let</code>关键字来创建变量，这是Rust语言从函数式语言中借鉴的语法形式。<code>let</code>创建的变量一般称为绑定（binding），而不是我们通常说的赋值，因为它表达的是位置表达式和值表达式之间建立的一种关联关系。</p><p>Rust中的表达式可以分为位置表达式和值表达式，在其他语言中，一般称为左值和右值。</p><ul><li>位置表达式：表示内存位置的表达式，有本地变量、静态变量、解引用、数组索引和字段引用五种。通过位置表达式可以对某个数据单元的内存进行读写。</li><li>值表达式：只引用了某个存储单元地址中的数据，相当于数据值，只能进行读操作。值表达式要么是字面量，要么是表达式求值过程中创建的临时值。</li></ul><p>表达式的求值过程在不同的上下文中会有不同的结果，求值上下文也分位置上下文和值上下文。下面几种表达式属于位置上下文（不必看懂，了解就好）：</p><ul><li>赋值或者复合赋值语句左侧的操作数</li><li>一元引用表达式的独立操作数</li><li>包含隐式借用的操作数</li><li>match判别式或let绑定右侧在使用ref模式匹配的时候也是位置上下文</li></ul><p>除了上述几种情况，其余表达式都属于值上下文。一般情况下，值表达式出现在值上下文中，位置表达式出现在位置上下文中，但也存在特殊情况：</p><ul><li>值表达式不能出现在位置上下文中，否则会报错：</li></ul><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// error[E0070]: invalid left-hand side of assignment</span><span class="token string">"hello"</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ul><li>当位置表达式出现在值上下文中时，该位置表达式会把<strong>所有权</strong>转移给另外一个位置表达式。</li></ul><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>我们刚刚看到了一个新名词，“所有权（ownership）”，所有权代表着以下意义：</p><ul><li>每个值在Rust中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者。</li><li>每个值在一个时间点上只有一个管理者。</li><li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li></ul><p>当位置表达式出现在值上下文中时，这种所有权转移在Rust中称为移动语义。但在日常开发中，有时候并不需要转移所有权，Rust提供了引用操作符<code>&amp;</code>，可以直接获得位置表达式的内存地址，并通过该地址进行读写操作，解引用使用<code>*</code>操作符。下面看一个引用和解引用的示例：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的代码中，32这个值的所有权归变量x所有，变量y中存储的是其地址，最后通过解引用操作符<code>*</code>将引用y中的值取出来，以供<code>assert_eq!</code>宏使用，因为变量x仍旧保留它们的所有权，所以引用也被称为借用。</p><p>生命周期是Rust的核心概念，而所有权、借用等概念又和生命周期息息相关，但目前先不必去深入了解它，待把基础语法掌握后，再去学习Rust的精髓，方能事半功倍。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#1：一个猜谜游戏小项目</title>
      <link href="posts/8ab0a41e.html"/>
      <url>posts/8ab0a41e.html</url>
      
        <content type="html"><![CDATA[<p>在深入探索Rust语法的细枝末节之前，先通过一个麻雀虽小但五脏俱全的小项目来整体把握Rust，这样可以避免迷失在细节的海洋中。我们可能会通过这个小项目一下子接触到很多新概念，但不必惊慌，我们只需浅尝辄止对这些概念有个印象即可。</p><p>《TRPL》（Rustaceans对《The Rust Programming Language》的爱称）中就给出了一个经典的猜谜游戏的例子，我们一起来学习它。</p><blockquote><p>猜谜游戏：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜错了，会请玩家继续猜测；如果猜对了，它会打印祝贺信息并退出。</p></blockquote><h3 id="Rust如何管理项目"><a href="#Rust如何管理项目" class="headerlink" title="Rust如何管理项目"></a>Rust如何管理项目</h3><p>并不是所有的代码都像<code>hello_world.rs</code>一样，一个文件就可以搞定。一个项目往往具有复杂的代码，我们需要一种机制来管理这种复杂性，将一个项目切分成若干小部分，每个部分再进行切分，层层抽象，直到达到人脑可以处理的规模。每种编程语言都有这样的机制，例如Java的package机制，Rust也不例外。</p><p>Rust用了两个概念来管理项目：一个是crate（项目），一个是mod（模块）。模块（mod）是用于在项目（crate）内部进行分层和封装的机制，模块内部可以包含模块。</p><ul><li>crate：可以简单理解为一个项目，crate是Rust中的独立编译单元（compile unit），每个crate对应生成一个库或者可执行文件。作为对比，我们比较熟悉的C语言中，一个单独的.c文件和其所有的include文件组成一个编译单元，每个.c生成一个.o，然后将这些.o链接起来生成可执行文件。</li><li>mod：可以简单理解为命名空间。mod可以嵌套（注意crate之间不能出现循环引用），还可以控制内部元素的可见性。</li></ul><p>说到可见性问题，在Rust中，元素默认都是私有的，用<code>pub</code>关键字修饰的元素才是公开的。公开和私有的访问权限规定如下：</p><ul><li>如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问</li><li>如果一个元素是公开的，那么可以在本模块外的作用域访问它。</li></ul><p>模块是一种抽象的概念，文件是承载这个概念的实体，但是模块和文件并不是简单的一一对应关系。在一个crate内部创建mod的方式有下面三种：</p><ul><li>在一个rs文件中创建内嵌模块，直接使用<code>mod</code>关键字即可。</li><li>独立的一个rs文件就是一个模块，文件名即是模块名。</li><li>一个文件夹也可以视为一个模块，文件夹内部要有一个<code>mod.rs</code>文件，这个文件是这个模块的入口。注意必须要在这个<code>mod.rs</code>中声明其子模块，否则子模块无法被当成这个项目的源码进行编译；另外，也需要在该文件夹所在的mod的入口文件中声明该文件夹。</li></ul><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>cargo不仅是Rust的包管理器，还可以用于创建项目。使用下列命令可以创建一个名为<code>guessing_game</code>的项目：</p><pre class=" language-bash"><code class="language-bash">cargo new guessing_game --bin</code></pre><p>注意，后面的<code>--bin</code>意味着我们希望项目生成的是可执行程序，如果希望是library，则可以使用<code>--lib</code>选项。</p><p>以上为在命令行中手工创建项目，在Clion中可以点击<code>File-&gt;New Project</code>后如下图填写，然后点击<code>Create</code>按钮：</p><p><img src="../images/4.png"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>我们可以使用<code>tree</code>命令或者直接在Clion中查看当前的文件夹结构，如下图所示：</p><p><img src="../images/5.png"></p><ul><li>src/main.rs：这是cargo自动生成的rs文件。还记得前面讲的crate和mod的概念吗？在这个项目中，<code>guessing_game</code>是crate，<code>src</code>文件夹是mod，<code>main.rs</code>是<code>src</code>mod的入口（相应的，<code>lib.rs</code>是library类型crate的入口）。我们可以在<code>src</code>mod中创建子模块，但注意，这些子模块都要在<code>main.rs</code>中声明，否则无法参与编译。</li><li>.gitignore：这是git忽略文件，不懂其作用的同学可以自行搜索。这里重点要说的是通过<code>cargo new</code>创建的项目天然就是一个git项目，这也印证了Rust对开源的拥护。</li><li>Cargo.toml：这是项目管理配置文件。TOML是一种非常简洁好用的配置文件格式，TOML是<code>Tom&#39;s Obvious, Minimal Language</code>的首字母缩写，这里的Tom是Github的联合创始人之一，感兴趣的同学可以进一步自行了解TOML配置文件的写法。</li><li>Cargo.lock：该文件包含项目依赖项的确切信息，由Cargo维护，我们无须关心它。</li></ul><h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><p>在<code>src/main.rs</code>里cargo已经自动生成了输出<code>Hello, world!</code>的代码，我们来运行一下它看能否正常输出。</p><p>插一句题外话，在你日后漫长的Rust编码生涯中，你会发现，你将在处理编译错误上耗费大量的时间。还记得吗，Rust 的一大特色是保证内存安全，这保证了Rust代码只要运行起来就几乎不会发生内存错误，这么诱人的效果的背后的代价就是，我们要在编码时付出额外的努力。Rust为了保证内存安全设计了一套复杂的规则，这导致我们的代码一不留神就会编译不过。所以，在你日后经常用的一个操作就是检查能否编译通过，而不是直接编译，因为直接编译还要进行代码优化等操作所以会相对费时。可以使用下列命令检查编译错误：</p><pre class=" language-bash"><code class="language-bash">cargo check</code></pre><p>在Clion中需要新加一个Configuration来执行<code>cargo check</code>命令，如下图所示：</p><p><img src="../images/6.png"></p><p>确保<code>cargo check</code>通过后，可以执行<code>cargo build</code>来执行编译。编译后会产生一个<code>target</code>文件夹，在<code>target/debug</code>下会有一个和crate同名的可执行文件。但一般为了方便，可以直接执行<code>cargo run</code>，这条命令等价于先编译后执行。下图是执行<code>cargo run</code>后Clion的控制台输出：</p><p><img src="../images/7.png"></p><h3 id="猜谜游戏"><a href="#猜谜游戏" class="headerlink" title="猜谜游戏"></a>猜谜游戏</h3><p>在完成了项目搭建后，接下来就要开始猜谜游戏的代码编写了，我将它们分成六部分：创建变量、输入、输出、错误处理、随机数生成、完整代码。</p><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><p>使用<code>let</code>语句创建变量，需要注意的是，在Rust中，变量默认是不可变的，可以在变量名前使用<code>mut</code>来使得变量可变：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不可变</span><span class="token keyword">let</span> <span class="token keyword">mut</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可变</span></code></pre><p>在上面的<code>let</code>语句中，我们并没有显示声明变量的类型，但这并不代表Rust是动态类型的，Rust仍然是静态类型的，只不过Rust有一个可以通过上下文推断类型的强大编译器。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>我们早已在<code>hello_world.rs</code>中见识过了最基本的输出方式：</p><pre class=" language-rust"><code class="language-rust"><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>需要注意的是，这里的<code>println!</code>是一个宏，而非一个函数，println后面的感叹号就是宏的标志。Rust中的宏与C/C++中的宏是完全不一样的东西，简单说，可以把它理解为一种安全版的编译期语法扩展。这里之所以使用输出宏而非函数，是因为标准输出宏可以完成编译期格式检查，更加安全。</p><p>如果需要输出某个变量的值，可以使用占位符<code>&#123;&#125;</code>，例如：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"x = {} and y = {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其输出结果为：</p><pre class=" language-bash"><code class="language-bash">x <span class="token operator">=</span> 0 and y <span class="token operator">=</span> 10</code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>为了从控制台中获取用户的输入，需要使用标准库<code>std::io</code>。使用<code>use</code>语句将该库引入当前作用域：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span></code></pre><p>我们可以使用<code>io</code>库中的函数<code>stdin</code>：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个字符串类型的可变变量</span>io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>stdin</code>函数返回一个<code>std::io::Stdin</code>的实例，这代表终端标准输入句柄的类型。然后调用<code>read_line</code>方法，可以从标准输入中读取一行并存入到<code>guess</code>变量中去。<code>&amp;</code>表示这是一个引用，这是一个复杂的特性，我们现在无须了解它。</p><p>读取用户输入后，我们需要判断用户是否正确输入了数字。<code>String</code>类型带有处理字符串处理的一些方法：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Please type a number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>字符串的 <code>parse </code>方法将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 <code>let guess: u32</code> 指定。<code>guess </code>后的冒号<code>:</code>告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型，u32 是一个无符号的 32 位整型。<code>trim</code>方法用于消除回车空格等符号。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>上一小节代码中还有一个<code>expect</code>没有分析，而这就涉及到Rust中的错误处理机制了。<code>read_line</code>的返回值类型是<code>io::Result</code>，它是<code>Result</code>类型在<code>io</code>模块的特化版本。<code>Result</code>是枚举类型，其成员为<code>Ok</code>和<code>Err</code>，<code>Ok</code> 成员表示操作成功，内部包含成功时产生的值。<code>Err </code>成员则意味着操作失败，内部包含失败的前因后果。</p><p><code>Result</code>类型的作用是编码错误处理信息。<code>Result </code>类型像其他类型一样，拥有定义于其上的方法。<code>io::Result</code>的实例拥有<code>expect</code>方法。如果 <code>io::Result </code>实例的值是 <code>Err</code>，<code>expect</code> 会导致程序崩溃，并打印参数传递给 <code>expect </code>的信息。如果<code>io::Result</code>实例的值是 <code>Ok</code>，<code>expect </code>会获取 <code>Ok </code>中的值并返回。在本例中，这个值是用户输入到标准输入中的字节数。</p><h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h4><p>猜谜游戏需要能够自动生成随机数。Rust标准库中并未包含随机数功能，但我们可以通过引入外部crate来获得随机数功能。还记得Rust的官方开源仓库吗，那里可是有很多宝贝的。打开<code>https://crates.io/</code>，在搜索框中键入<code>rand</code>来搜索具有随机数功能的crate，出来的第一个结果就是我们需要的crate。</p><p><img src="../images/8.png"></p><p>现在我们将这个库引入到我们的项目中。打开<code>Cargo.toml</code>，在<code>[dependencies]</code>下添加：</p><pre class=" language-toml"><code class="language-toml">[dependencies]rand = "0.8.3"</code></pre><p><code>[dependencies]</code> 告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。</p><p>下面使用<code>rand</code>库来产生随机数。首先，使用<code>use</code>语句引入<code>rand</code>，<code>use rand::Rng;</code>。然后调用下列函数产生一个1和100之间的数：</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">let</span> number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>猜谜游戏的完整代码如下。</p><pre class=" language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>io<span class="token punctuation">;</span><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cmp<span class="token punctuation">:</span><span class="token punctuation">:</span>Ordering<span class="token punctuation">;</span><span class="token keyword">use</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span>Rng<span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Guess the number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> secret_number <span class="token operator">=</span> rand<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Please input your guess."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> guess <span class="token operator">=</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        io<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">stdin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> guess<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read line"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> guess<span class="token punctuation">:</span> u32 <span class="token operator">=</span> <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">Ok</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> num<span class="token punctuation">,</span>            <span class="token function">Err</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">continue</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You guessed: {}"</span><span class="token punctuation">,</span> guess<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">match</span> guess<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>secret_number<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Less <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too small!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Greater <span class="token operator">=</span><span class="token operator">></span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Too big!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Ordering<span class="token punctuation">:</span><span class="token punctuation">:</span>Equal <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"You win!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，涉及控制流操作的<code>loop</code>、<code>match</code>、<code>continue</code>、<code>break</code>等语法，大家应当能够望文生义。对于这个完整代码，大家能够阅读并大概知道每一行干了啥即可，不必纠结于语法细节。</p><p>猜谜游戏运行结果如下：</p><p><img src="../images/9.png"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《The Rust Programming Language》</li><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记#0：初窥门径</title>
      <link href="posts/56021c3e.html"/>
      <url>posts/56021c3e.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么选择Rust"><a href="#为什么选择Rust" class="headerlink" title="为什么选择Rust"></a>为什么选择Rust</h3><p>这个世界上的编程语言不计其数，仅在 <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>（开发语言排行榜）上被纳入统计范围的就有273种之多，下图是当下最流行的前20种编程语言。</p><p><img src="../images/1.png"></p><p>这些优秀的编程语言往往都有自己的绝活，例如C性能非常高，Java便于抽象擅长组织大型程序，Python适合小巧的脚本，等等。但同样，它们也并非完美，性能高的C容易产生段错误（segfault，由访问不属于本程序拥有的内存所造成的崩溃，例如空指针解引用等），擅长抽象的Java需要垃圾回收（GC），上手快的Python解释执行速度较慢。所以，编程语言的设计和发展仍有进步的空间，而Rust就是近年来涌现的新一代的综合各大编程语言优点的集大成者。</p><p>Rust的设计者是这样定位这门语言的：</p><blockquote><p> Rust is a system’s programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>Rust的突出优势可以总结为以下三点（无须看懂，知道Rust很厉害就完事了）：</p><ul><li>内存安全：Rust最重要的特点就是可以提供内存安全保证，而且没有额外的性能损失。保证内存安全即不会出现内存访问错误，为此，Rust建立了严格的内存安全管理模型：<ul><li>所有权系统：每个被分配的内存都有一个独占其所有权的指针，只有当该指针被销毁时，其对应的内存才能随之被释放。所有权系统借鉴了C++的RAII机制，这是Rust无GC但是可以安全管理内存的基石。</li><li>借用和生命周期：每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。</li></ul></li><li>零成本抽象：抽象表达能力是使用编程语言高效开发的必要条件，有些语言的抽象表达能力是靠牺牲性能换来的，而Rust的抽象表达能力不会存在运行时性能开销。Rust零成本抽象的基石是泛型和trait。</li><li>并发：内存安全的bug和并发安全的bug产生都是由内存的不正当访问造成的，所以，利用装载了所有权的强大类型系统，Rust能够在编译期检查出多线程并发代码中的数据竞争问题。</li></ul><p>Rust以其独特的魅力已经连续多年荣膺StackOverflow网站最受程序员欢迎的编程语言，虽然目前其在TIOBE榜单上还未入前列，但未来互联网必定更加注重安全和高性能，所以应运而生的Rust必将大有可为。</p><p>在学习Rust的语法之前，我们先一起来了解一下Rust的周边知识。</p><h3 id="Rust常用网站"><a href="#Rust常用网站" class="headerlink" title="Rust常用网站"></a>Rust常用网站</h3><ul><li>官方网站：点击<a href="https://www.rust-lang.org/">这里</a>。在这里你可以找到官方教材TRPL等许多重要内容，所以探索一下此网站大有裨益。</li><li>编译器是开源的：点击<a href="https://github.com/rust-lang/rust">这里</a>。对Rust语言来说，开源社区也是语言的一部分，这是和其他商用语言的区别所在。</li><li>语言设计和相关讨论：点击<a href="https://github.com/rust-lang/rfcs">这里</a>。Rust每增加一个重要语言特性，都会经过标准的RFC流程，RFC文档是涵盖了语言特性的设计意图、详细设计、优缺点的完整技术方案。这对于我们学习者来说，可以通过阅读RFC来深入了解某个语言特性的来龙去脉，这将是一个极其宝贵的学习资源，有助于了解某个特性背后的原理。</li><li>官方开源仓库：点击<a href="https://crates.io/">这里</a>。该网站储存了Rust社区热门的开源库。</li></ul><h3 id="版本和发布策略"><a href="#版本和发布策略" class="headerlink" title="版本和发布策略"></a>版本和发布策略</h3><p>Rust编译器的版本号采用了“语义化版本号”（Semantic Versioning）的方案，版本格式为：主版本号.次版本号.修订号，其递增规则如下：</p><ul><li>主版本号：当做了不兼容的API修改</li><li>次版本号：当做了向下兼容的功能性新增</li><li>修订号：当做了向下兼容的问题修正</li></ul><p>Rust团队维护三个发行分支：</p><ul><li>开发版（nightly）：最新的功能将首先发布在此分支，供用户试用。</li><li>测试版（beta）：将nightly版本中验证过的功能开放给用户使用，可以看作是stable版本的预发布版本。</li><li>稳定版（stable）：每隔6个星期发布的稳定可靠的版本。</li></ul><p>Rust语言每个相对复杂一点的新功能，都要经历如下步骤才算真正稳定可用：</p><blockquote><p>RFC -&gt; Nightly -&gt; Beta -&gt; Stable</p></blockquote><p>有时一些新功能确实需要一定程度上破坏兼容性，为了最大程度上减少这些变动给用户带来的影响，Rust设计组又提出一个所谓的edition方案，目前有 2015 和 2018两种edition，我们可以设置”edition=2018”来告诉编译器我们使用的版本。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>根据官网的<a href="https://www.rust-lang.org/tools/install">推荐</a>，可以使用一个叫rustup的工具安装Rust相关的一整套工具链。命令如下：</p><pre class=" language-bash"><code class="language-bash">curl --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="token operator">|</span> sh</code></pre><p>我们可以使用rustup工具管理工具链：</p><pre class=" language-bash"><code class="language-bash">// 更新rustup本身rustup self update// 更新工具链rustup update</code></pre><p>也可以用它在<code>stable/beta/nightly</code>三种版本中轻松切换：</p><pre class=" language-bash"><code class="language-bash">// 安装nightly版本的工具链rustup <span class="token function">install</span> nightly// 设置默认工具链是nightly版本rustup default nightly</code></pre><p>若执行下列命令能够正确输出版本号则说明Rust安装成功：</p><pre class=" language-bash"><code class="language-bash">rustc --version</code></pre><p>若安装不成功，请尝试将<code>~/.cargo/bin</code>加入PATH环境变量中去。</p><p>在<code>~/.cargo/bin</code>目录下可以找到Rust的一些常用工具，如下图所示：</p><p><img src="../images/2.png"></p><ul><li>cargo：Rust的包管理器，类似于Python的pip、Node.js的npm。但cargo不仅局限于包管理，它还为Rust生态系统提供了标准的工作流，能够管理整个工作流程，从创建项目、运行单元测试和基准测试，到构建发布链接库，再到运行可执行文件，等等。</li><li>rustc：Rust的编译器，负责将Rust源代码编译为可执行文件或其他库文件。rustc使用Rust语言开发，其输出的错误信息非常友好和详尽，远超你见过的任何一款编译器。</li><li>rustdoc：文档生成器。</li><li>rls和racer：为编辑器准备的代码提示工具。</li><li>cargo-fmt和rustfmt：源代码格式化工具，有了这个，再也不用争论大括号是写在行尾还是另起一行了。</li><li>rust-gdb和rust-lldb：调试器。</li></ul><p>对于IDE，Rust尚没有专属的IDE，我推荐Clion+Rust插件，已经非常好用了。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>配置好了开发环境，如何能不写一个充满仪式感的Hello World程序呢？来，新建一个文件，命名为<code>hello_world.rs</code>，内容如下：</p><pre class=" language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// hello_world.rs</span><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后使用rustc编译它，可看到当前文件夹下生成了一个名为<code>hello_world</code>的可执行程序：</p><p><img src="../images/3.png"></p><h3 id="Rust的设计哲学"><a href="#Rust的设计哲学" class="headerlink" title="Rust的设计哲学"></a>Rust的设计哲学</h3><p>Rust是具有混合范式的“面向过程”式的编程语言，它包含了面向对象、函数式和泛型三种编程范式，其设计哲学如下：</p><ul><li>内存安全为第一准则</li><li>注重并发安全，避免数据竞争</li><li>持续提升性能</li><li>保持语言的高度一致性</li><li>语言必须有可见的实用性</li><li>注重开发体验和学习体验</li><li>现代化语言特性</li><li>拥抱开源社区</li></ul><h3 id="学习Rust的建议"><a href="#学习Rust的建议" class="headerlink" title="学习Rust的建议"></a>学习Rust的建议</h3><p>这些建议来自于张汉东老师，我认为还是十分中肯的，所以列在此处和大家分享。</p><ul><li>从整体出发，不要让自己陷入到细节中去。先有高屋建瓴的结构性的认知，再深入语法细节，有利于建立知识网络，可以事半功倍。</li><li>抛弃一次性学会的念头，分层次递进式学习。</li><li>和你已知的知识建立联系。新语言新特性出现的本质原因是为了解决某个问题，因此，当我们学习Rust的新特性时，可以和其他语言的旧特性进行对比，了解其改进的动机和方式，这有助于增强对语法的记忆和理解。</li><li>学会阅读源码，从源码中学习。建议在学习语法时，顺带阅读源码。</li><li>通过主题式阅读来填补知识空白。可以从其他语言的相同特性中了解语法的概念，观察不同语言对同一概念的不同实现方式，</li><li>时刻把握Rust设计哲学。我们要从Rust的设计哲学去思考某种特性这样设计的原因。</li><li>有意识地构建Rust的心智模型，有意识地训练以Rust的方法思考代码编写的方式。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《Rust编程之道》张汉东</li><li>《深入浅出Rust》范长春</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
